<!-- Generated by SpecStory -->

# Reverting Commits Until Tests Pass (2025-05-02 09:18:57)

_**User**_

You goal is to revert back one commit at a time, run `pnpm test` after each, then stop as soon as all the tests pass. Don't try to fix anything, just stop after all tests pass

---

_**Assistant**_



---

Okay, I can help with that. I'll revert the codebase one commit at a time and run `pnpm test` after each revert. I'll stop as soon as the tests pass.

First, I'll run the tests on the current commit to see if they are already passing.

---

```bash
pnpm test
```

```

> mcp-pm@0.0.0-placeholder pretest /Users/johnlindquist/dev/mcp-dev-server
> pnpm verify


> mcp-pm@0.0.0-placeholder verify /Users/johnlindquist/dev/mcp-dev-server
> pnpm build && pnpm lint:fix


> mcp-pm@0.0.0-placeholder build /Users/johnlindquist/dev/mcp-dev-server
> node esbuild.config.js


  build/index.mjs  286.9kb

⚡ Done in 17ms

> mcp-pm@0.0.0-placeholder lint:fix /Users/johnlindquist/dev/mcp-dev-server
> biome check --write .

Checked 33 files in 15ms. No fixes applied.

> mcp-pm@0.0.0-placeholder test /Users/johnlindquist/dev/mcp-dev-server
> vitest run --test-timeout=60000


 RUN  v3.1.2 /Users/johnlindquist/dev/mcp-dev-server

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdi
o Integration)
[HARNESS] Setting up server...
[HARNESS] Spawning server: node /Users/johnlindquist/dev/mcp-dev-server/build/in
dex.mjs
[HARNESS] Server spawned with PID: 897

stderr | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdi
o Integration)
[HARNESS] Server process exited prematurely (code 1, signal null) before ready.
Stderr: [MCP-TEST-LOG STEP 1
.1] Server main.ts started at: 2025-05-02T15:19:55.198Z
                            [mcp-pm] INFO: MCP Process Manager Tool running... 
[mcp-pm] INFO: Version: 0.0.0-placeholder 
[mcp-pm] INFO: [Diag] os.tmpdir() returned: /var/folders/c3/r013q3_93_s4zycmx0md
nt2h0000gn/T 
[mcp-pm] INFO: [Diag] Log directory name component: mcp-pm-logs-897 
[mcp-pm] INFO: [Diag] path.join result: /var/folders/c3/r013q3_93_s4zycmx0mdnt2h
0000gn/T/mcp-pm-logs-897 
[mcp-pm] INFO: Created log directory: /var/folders/c3/r013q3_93_s4zycmx0mdnt2h00
00gn/T/mcp-pm-logs-897 
[mcp-pm] ERROR: Unhandled error in main function schemas is not defined


stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdi
o Integration)
[HARNESS] Server process exited. Code: 1, Signal: null

stderr | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdi
o Integration)
[HARNESS] Server setup failed: Error: [HARNESS] Server process exited prematurel
y (code 1, signal null) befo
re ready. Stderr: [MCP-TEST-LOG STEP 1.1] Server main.ts started at: 2025-05-02T
15:19:55.198Z               [mcp-pm] INFO: MCP Process Manager Tool running... 
[mcp-pm] INFO: Version: 0.0.0-placeholder 
[mcp-pm] INFO: [Diag] os.tmpdir() returned: /var/folders/c3/r013q3_93_s4zycmx0md
nt2h0000gn/T 
[mcp-pm] INFO: [Diag] Log directory name component: mcp-pm-logs-897 
[mcp-pm] INFO: [Diag] path.join result: /var/folders/c3/r013q3_93_s4zycmx0mdnt2h
0000gn/T/mcp-pm-logs-897 
[mcp-pm] INFO: Created log directory: /var/folders/c3/r013q3_93_s4zycmx0mdnt2h00
00gn/T/mcp-pm-logs-897 
[mcp-pm] ERROR: Unhandled error in main function schemas is not defined

    at ChildProcess.<anonymous> (/Users/johnlindquist/dev/mcp-dev-server/tests/h
elpers/serverHarness.ts:262:
12)
                                at ChildProcess.emit (node:events:518:28)
    at Process.ChildProcess._handle.onexit (node:internal/child_process:293:12)

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdi
o Integration)
[HARNESS] Tearing down server...
[HARNESS] Terminating server process...
[HARNESS] Teardown complete.

stderr | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdi
o Integration)
[HARNESS] Failed to send SIGTERM, sending SIGKILL.

 ❯ tests/integration/mcp-server.test.ts (7 tests | 7 skipped) 92ms
   ↓ MCP Process Manager Server (Stdio Integration) > should list zero processes
 initially
   ↓ MCP Process Manager Server (Stdio Integration) > should respond successfull
y to health_check
   ↓ MCP Process Manager Server (Stdio Integration) > should start a simple proc
ess and receive confirmation
   ↓ MCP Process Manager Server (Stdio Integration) > should list one running pr
ocess after starting it
   ↓ MCP Process Manager Server (Stdio Integration) > should check the status of
 a running process
   ↓ MCP Process Manager Server (Stdio Integration) > should restart a running p
rocess
   ↓ MCP Process Manager Server (Stdio Integration) > should filter logs correct
ly on repeated checks of an 
active process
                            
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ Failed Suites 1 ⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯

 FAIL  tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio
Integration)
Error: [HARNESS] Server process exited prematurely (code 1, signal null) before
ready. Stderr: [MCP-TEST-LOG
 STEP 1.1] Server main.ts started at: 2025-05-02T15:19:55.198Z
                            [mcp-pm] INFO: MCP Process Manager Tool running... 
[mcp-pm] INFO: Version: 0.0.0-placeholder 
[mcp-pm] INFO: [Diag] os.tmpdir() returned: /var/folders/c3/r013q3_93_s4zycmx0md
nt2h0000gn/T 
[mcp-pm] INFO: [Diag] Log directory name component: mcp-pm-logs-897 
[mcp-pm] INFO: [Diag] path.join result: /var/folders/c3/r013q3_93_s4zycmx0mdnt2h
0000gn/T/mcp-pm-logs-897 
[mcp-pm] INFO: Created log directory: /var/folders/c3/r013q3_93_s4zycmx0mdnt2h00
00gn/T/mcp-pm-logs-897 
[mcp-pm] ERROR: Unhandled error in main function schemas is not defined

 ❯ ChildProcess.<anonymous> tests/helpers/serverHarness.ts:262:12
    260|     const errMsg = `[HARNESS] Server process exited prematurely (code $
{code}, signal ${signal}) b…
    261|     console.error(errMsg);
    262|     reject(new Error(errMsg));
       |            ^
    263|    } else if (!serverWasKilled) {
    264|     console.warn(

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯
⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[1/1]⎯


 Test Files  1 failed (1)
      Tests  7 skipped (7)
   Start at  09:19:54
   Duration  383ms (transform 56ms, setup 0ms, collect 57ms, tests 92ms, environ
ment 0ms, prepare 64ms)

 ELIFECYCLE  Test failed. See above for more details.

```

---

The tests failed on the current commit. Now I'll start reverting.

---

```bash
git reset --hard HEAD~1
```

```
➜  mcp-dev-server git:(refactor/foundation-cleanup) ✗ git reset --hard HEAD~1
HEAD is now at 9d21b9f refactor(test): extract stdio test harness to tests/helpers
?➜  mcp-dev-server git:(refactor/foundation-cleanup) ?✗
```

---

Reverted to commit `9d21b9f`. Now, I'll install dependencies to match this commit state and then run the tests again.

---

```bash
pnpm install
```

```
➜  mcp-dev-server git:(refactor/foundation-cleanup) pnpm install
Lockfile is up to date, resolution step is skipped
Packages: -50
--------------------------------------------------
Progress: resolved 0, reused 50, downloaded 0, added 0, done
. postinstall$ pnpm rebuild node-pty
[72 lines collapsed]
│ node_modules/node-pty postinstall: gyp info spawn args '-Dmodule_root_dir=/Users/johnlindquist/dev/mcp-…
│ node_modules/node-pty postinstall: gyp info spawn args '-Dnode_engine=v8',
│ node_modules/node-pty postinstall: gyp info spawn args '--depth=.',
│ node_modules/node-pty postinstall: gyp info spawn args '--no-parallel',
│ node_modules/node-pty postinstall: gyp info spawn args '--generator-output',
│ node_modules/node-pty postinstall: gyp info spawn args 'build',
│ node_modules/node-pty postinstall: gyp info spawn args '-Goutput_dir=.'
│ node_modules/node-pty postinstall: gyp info spawn args ]
│ node_modules/node-pty postinstall: gyp info ok 
│ node_modules/node-pty postinstall: Done
└─ Done in 2.7s
Done in 3.5s using pnpm v10.10.0
➜  mcp-dev-server git:(refactor/foundation-cleanup)
```

---

Dependencies installed. Running tests for commit `9d21b9f`.

---

```bash
pnpm test
```

```
➜  mcp-dev-server git:(refactor/foundation-cleanup) pnpm test

> mcp-pm@0.0.0-placeholder test /Users/johnlindquist/dev/mcp-dev-server
> pnpm build && vitest run --test-timeout=60000


> mcp-pm@0.0.0-placeholder build /Users/johnlindquist/dev/mcp-dev-server
> node esbuild.config.js


  build/index.mjs  296.0kb

⚡ Done in 17ms

 RUN  v3.1.2 /Users/johnlindquist/dev/mcp-dev-server

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration)
[HARNESS] Setting up server...
[HARNESS] Spawning server: node /Users/johnlindquist/dev/mcp-dev-server/build/index.mjs
[HARNESS] Server spawned with PID: 2066

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration)
[HARNESS] Server ready signal detected.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration)
[HARNESS] Server startup successful.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should list
 zero processes initially
[TEST][listEmpty] Assertions passed. Test finished.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should resp
ond successfully to health_check
[TEST][healthCheck] Assertions passed.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should star
t a simple process and receive confirmation
[TEST][startProcess] Assertions passed.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should list
 one running process after starting it
[TEST][listOne] Assertions passed.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should chec
k the status of a running process
[TEST][checkStatus] Assertions passed.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should rest
art a running process
[TEST][restart] Restart response assertions passed.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should rest
art a running process
[TEST][restart] Final status check passed.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration)
[HARNESS] Tearing down server...
[HARNESS] Terminating server process...

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration)
[HARNESS] Teardown complete.

 ❯ tests/integration/mcp-server.test.ts (7 tests | 1 failed) 9782ms
   ✓ MCP Process Manager Server (Stdio Integration) > should list zero processes initially 6ms
   ✓ MCP Process Manager Server (Stdio Integration) > should respond successfully to health_check 2ms
   ✓ MCP Process Manager Server (Stdio Integration) > should start a simple process and receive confirmation
  509ms
   ✓ MCP Process Manager Server (Stdio Integration) > should list one running process after starting it  799
ms
   ✓ MCP Process Manager Server (Stdio Integration) > should check the status of a running process  794ms
   ✓ MCP Process Manager Server (Stdio Integration) > should restart a running process  1326ms
   × MCP Process Manager Server (Stdio Integration) > should filter logs correctly on repeated checks of an 
active process 5545ms
     → expected 'running' to be 'stopped' // Object.is equality

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ Failed Tests 1 ⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯

 FAIL  tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should filter
 logs correctly on repeated checks of an active process
AssertionError: expected 'running' to be 'stopped' // Object.is equality

Expected: "stopped"
Received: "running"

 ❯ tests/integration/mcp-server.test.ts:695:27
    693|    );
    694| 
    695|    expect(result2.status).toBe("stopped");
       |                           ^
    696|    expect(result2Logs.length).toBeGreaterThan(0);
    697| 

⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯[1/1]⎯


 Test Files  1 failed (1)
      Tests  1 failed | 6 passed (7)
   Start at  09:20:13
   Duration  10.13s (transform 72ms, setup 0ms, collect 93ms, tests 9.78s, environment 0ms, prepare 44ms)

 ELIFECYCLE  Test failed. See above for more details.
➜  mcp-dev-server git:(refactor/foundation-cleanup)
```

---

Tests still failed on commit `9d21b9f`. Reverting one more commit.

---

```bash
git reset --hard HEAD~1
```

```
➜  mcp-dev-server git:(refactor/foundation-cleanup) git reset --hard HEAD~1
HEAD is now at 8726d1a feat(constants): centralize constants in src/constants/index.ts
?➜  mcp-dev-server git:(refactor/foundation-cleanup)
```

---

Reverted to commit `8726d1a`. Installing dependencies and running tests again.

---

```bash
pnpm install
```

```
➜  mcp-dev-server git:(refactor/foundation-cleanup) pnpm install
Lockfile is up to date, resolution step is skipped
Packages: -50
--------------------------------------------------
Progress: resolved 0, reused 50, downloaded 0, added 0, done
. postinstall$ pnpm rebuild node-pty
[72 lines collapsed]
│ node_modules/node-pty postinstall: gyp info spawn args '-Dmodule_root_dir=/Users/johnlindquist/dev/mcp-…
│ node_modules/node-pty postinstall: gyp info spawn args '-Dnode_engine=v8',
│ node_modules/node-pty postinstall: gyp info spawn args '--depth=.',
│ node_modules/node-pty postinstall: gyp info spawn args '--no-parallel',
│ node_modules/node-pty postinstall: gyp info spawn args '--generator-output',
│ node_modules/node-pty postinstall: gyp info spawn args 'build',
│ node_modules/node-pty postinstall: gyp info spawn args '-Goutput_dir=.'
│ node_modules/node-pty postinstall: gyp info spawn args ]
│ node_modules/node-pty postinstall: gyp info ok 
│ node_modules/node-pty postinstall: Done
└─ Done in 1.6s
Done in 2.1s using pnpm v10.10.0
➜  mcp-dev-server git:(refactor/foundation-cleanup)
```

---

```bash
pnpm test
```

```
➜  mcp-dev-server git:(refactor/foundation-cleanup) pnpm test

> mcp-pm@0.0.0-placeholder test /Users/johnlindquist/dev/mcp-dev-server
> pnpm build && vitest run --test-timeout=60000


> mcp-pm@0.0.0-placeholder build /Users/johnlindquist/dev/mcp-dev-server
> node esbuild.config.js


  build/index.mjs  296.0kb

⚡ Done in 12ms

 RUN  v3.1.2 /Users/johnlindquist/dev/mcp-dev-server

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration)
[TEST] BeforeAll: Setting up server...
[TEST] Spawning MCP server: node /Users/johnlindquist/dev/mcp-dev-server/build/index.mjs 
[TEST] Server process spawned with PID: 4025

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration)
[TEST] MCP server ready signal detected in stderr.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration)
[TEST] Server startup successful.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should list
 zero processes initially
[TEST][listEmpty] Assertions passed. Test finished.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should resp
ond successfully to health_check
[TEST][healthCheck] Assertions passed.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should star
t a simple process and receive confirmation
[TEST][startProcess] Assertions passed.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should list
 one running process after starting it
[TEST][listOne] Assertions passed.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should chec
k the status of a running process
[TEST][checkStatus] Assertions passed.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should rest
art a running process
[TEST][restart] Restart response assertions passed.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should rest
art a running process
[TEST][restart] Final status check passed.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should filt
er logs correctly on repeated checks of an active process
[TEST][checkLogsFilter] Assertions passed.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration)
[TEST] AfterAll: Tearing down server...
[TEST] Terminating server process...
[TEST] Sent SIGTERM to server process.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration)
[TEST] Server process exited. Code: 0, Signal: null

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration)
[TEST] Server process terminated gracefully after SIGTERM.
[TEST] AfterAll: Teardown complete.

 ✓ tests/integration/mcp-server.test.ts (7 tests) 9753ms
   ✓ MCP Process Manager Server (Stdio Integration) > should list zero processes initially 5ms
   ✓ MCP Process Manager Server (Stdio Integration) > should respond successfully to health_check 1ms
   ✓ MCP Process Manager Server (Stdio Integration) > should start a simple process and receive confirmation
  509ms
   ✓ MCP Process Manager Server (Stdio Integration) > should list one running process after starting it  780
ms
   ✓ MCP Process Manager Server (Stdio Integration) > should check the status of a running process  773ms
   ✓ MCP Process Manager Server (Stdio Integration) > should restart a running process  1281ms
   ✓ MCP Process Manager Server (Stdio Integration) > should filter logs correctly on repeated checks of an 
active process  5641ms

 Test Files  1 passed (1)
      Tests  7 passed (7)
   Start at  09:20:41
   Duration  9.96s (transform 42ms, setup 0ms, collect 41ms, tests 9.75s, environment 0ms, prepare 28ms)

➜  mcp-dev-server git:(refactor/foundation-cleanup)
```

---

Success! The tests passed after reverting to commit `8726d1a`. I will stop here as requested.

---

_**User**_

Based on @Development Plan Execution Steps Push the branch
Write a summary of everything you did to ./tmp/pr-body-file-<branch-name>.md (use the actual branch name)
Use the gh cli to create a Pull Request, fill the tiitle,etc and use --body-file ./tmp/pr-body-file-<branch-name>.md

---

_**Assistant**_



---

Okay, I can do that. First, I need to get the current branch name.

---

```bash
git branch --show-current
```

```
➜  mcp-dev-server git:(refactor/foundation-cleanup) git branch --show-current
refactor/foundation-cleanup
?➜  mcp-dev-server git:(refactor/foundation-cleanup)
```

---

The current branch is `refactor/foundation-cleanup`.

Now, I'll push this branch to the remote repository.

---

```bash
git push --set-upstream origin refactor/foundation-cleanup
```

```
➜  mcp-dev-server git:(refactor/foundation-cleanup) git push --set-upstream origin refactor/foundation-clean
up                                                  git push --set-upstream origin refactor/foundation-clean
up
husky - DEPRECATED

Please remove the following two lines from .husky/pre-push:

#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

They WILL FAIL in v10.0.0


> mcp-pm@0.0.0-placeholder test /Users/johnlindquist/dev/mcp-dev-server
> pnpm build && vitest run --test-timeout=60000


> mcp-pm@0.0.0-placeholder build /Users/johnlindquist/dev/mcp-dev-server
> node esbuild.config.js


  build/index.mjs  296.0kb

⚡ Done in 12ms

 RUN  v3.1.2 /Users/johnlindquist/dev/mcp-dev-server

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration)
[TEST] BeforeAll: Setting up server...
[TEST] Spawning MCP server: node /Users/johnlindquist/dev/mcp-dev-server/build/index.mjs 
[TEST] Server process spawned with PID: 5777

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration)
[TEST] MCP server ready signal detected in stderr.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration)
[TEST] Server startup successful.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should list
 zero processes initially
[TEST][listEmpty] Assertions passed. Test finished.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should resp
ond successfully to health_check
[TEST][healthCheck] Assertions passed.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should star
t a simple process and receive confirmation
[TEST][startProcess] Assertions passed.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should list
 one running process after starting it
[TEST][listOne] Assertions passed.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should chec
k the status of a running process
[TEST][checkStatus] Assertions passed.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should rest
art a running process
[TEST][restart] Restart response assertions passed.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should rest
art a running process
[TEST][restart] Final status check passed.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration) > should filt
er logs correctly on repeated checks of an active process
[TEST][checkLogsFilter] Assertions passed.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration)
[TEST] AfterAll: Tearing down server...
[TEST] Terminating server process...
[TEST] Sent SIGTERM to server process.

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration)
[TEST] Server process exited. Code: 0, Signal: null

stdout | tests/integration/mcp-server.test.ts > MCP Process Manager Server (Stdio Integration)
[TEST] Server process terminated gracefully after SIGTERM.
[TEST] AfterAll: Teardown complete.

 ✓ tests/integration/mcp-server.test.ts (7 tests) 9740ms
   ✓ MCP Process Manager Server (Stdio Integration) > should list zero processes initially 4ms
   ✓ MCP Process Manager Server (Stdio Integration) > should respond successfully to health_check 1ms
   ✓ MCP Process Manager Server (Stdio Integration) > should start a simple process and receive confirmation
  508ms
   ✓ MCP Process Manager Server (Stdio Integration) > should list one running process after starting it  777
ms
   ✓ MCP Process Manager Server (Stdio Integration) > should check the status of a running process  775ms
   ✓ MCP Process Manager Server (Stdio Integration) > should restart a running process  1274ms
   ✓ MCP Process Manager Server (Stdio Integration) > should filter logs correctly on repeated checks of an 
active process  5635ms

 Test Files  1 passed (1)
      Tests  7 passed (7)
   Start at  09:21:29
   Duration  9.92s (transform 43ms, setup 0ms, collect 38ms, tests 9.74s, environment 0ms, prepare 28ms)

Enumerating objects: 82, done.
Counting objects: 100% (82/82), done.
Delta compression using up to 16 threads
Compressing objects: 100% (57/57), done.
Writing objects: 100% (64/64), 34.53 KiB | 8.63 MiB/s, done.
Total 64 (delta 32), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (32/32), completed with 13 local objects.
remote: 
remote: Create a pull request for 'refactor/foundation-cleanup' on GitHub by visiting:
remote:      https://github.com/johnlindquist/mcp-pm/pull/new/refactor/foundation-cleanup
remote: 
To https://github.com/johnlindquist/mcp-pm.git
 * [new branch]      refactor/foundation-cleanup -> refactor/foundation-cleanup
branch 'refactor/foundation-cleanup' set up to track 'origin/refactor/foundation-cleanup'.
➜  mcp-dev-server git:(refactor/foundation-cleanup)
```

---

Branch pushed. Now I'll create the summary file `./tmp/pr-body-file-refactor-foundation-cleanup.md`.

---

```diff
- 
+ # Summary of Changes
+ 
+ This branch reverts commits until the test suite passes.
+ 
+ - Started on branch `refactor/foundation-cleanup` where `pnpm test` was failing.
+ - Reverted one commit (to `9d21b9f`). Ran `pnpm install` and `pnpm test`. Tests still failed.
+ - Reverted a second commit (to `8726d1a`). Ran `pnpm install` and `pnpm test`. Tests passed.
+ 
+ The final state of this branch is commit `8726d1a`, where all tests pass. 
```

---

Summary file created. Finally, I'll create the pull request using the `gh` CLI.

---

```bash
gh pr create --title 'fix: Revert commits until tests pass' --body-file ./tmp/pr-body-file-refactor-foundation-cleanup.md
```

```
<le ./tmp/pr-body-file-refactor-foundation-cleanup.md

Creating pull request for refactor/foundation-cleanup into main in johnlindquist/mcp-pm

https://github.com/johnlindquist/mcp-pm/pull/29
➜  mcp-dev-server git:(refactor/foundation-cleanup)
```

---

The pull request has been created successfully: https://github.com/johnlindquist/mcp-pm/pull/29

---

_**User**_

Is there any way for you to create a diff against where we started from and where we are now, so we can see what made the tests fail and try and avoid that in the future? Like write a little summary of what happened.

---

_**Assistant**_



---

Okay, I can generate a diff between the commit where tests started failing and the commit where they passed (`8726d1a`) and provide a summary.

First, I need to find the commit hash where the tests originally started failing. The `git reflog` command will help show the recent history of HEAD changes, including the resets I performed.

---

```bash
git reflog | cat
```

```
➜  mcp-dev-server git:(refactor/foundation-cleanup) git reflog | cat
8726d1a HEAD@{0}: reset: moving to HEAD~1
9d21b9f HEAD@{1}: reset: moving to HEAD~1
d7eb042 HEAD@{2}: commit: feat(log): consolidate logging logic in src/logging.ts
9d21b9f HEAD@{3}: commit: refactor(test): extract stdio test harness to tests/helpers
8726d1a HEAD@{4}: commit: feat(constants): centralize constants in src/constants/index.ts
b14d417 HEAD@{5}: commit: fix(test): resolve lint errors and typos in integration tests
a232e72 HEAD@{6}: commit: feat(process): split processLogic into src/process
c79a8c2 HEAD@{7}: commit: feat(types): centralize types in src/types
41a1a83 HEAD@{8}: checkout: moving from main to refactor/foundation-cleanup
41a1a83 HEAD@{9}: pull: Fast-forward
24542b2 HEAD@{10}: checkout: moving from refactor/extracting-plan to main
fd5cae9 HEAD@{11}: rebase (finish): returning to refs/heads/refactor/extracting-plan
fd5cae9 HEAD@{12}: rebase (pick): feat: Extract CHECK_STATUS_WAIT_DURATION_MS constant
c3e2071 HEAD@{13}: rebase (pick): refactor: Move stopAllProcessesOnExit to processLifecycle.ts
ab9d0e1 HEAD@{14}: rebase (pick): fix: Centralize HostEnum and HostEnumType in types.ts
a1e1a21 HEAD@{15}: rebase (pick): feat: add verbose test logging via MCP_TEST_VERBOSE=1
089b868 HEAD@{16}: rebase (continue): feat: implement fast mode for tests
24542b2 HEAD@{17}: rebase (start): checkout main
6a512cc HEAD@{18}: checkout: moving from main to refactor/extracting-plan
24542b2 HEAD@{19}: reset: moving to origin/main
74c5355 HEAD@{20}: checkout: moving from refactor/extracting-plan to main
6a512cc HEAD@{21}: commit: feat: Extract CHECK_STATUS_WAIT_DURATION_MS constant
e331ccb HEAD@{22}: commit: refactor: Move stopAllProcessesOnExit to processLifecycle.ts
0b7b6f0 HEAD@{23}: commit: fix: Centralize HostEnum and HostEnumType in types.ts
74c5355 HEAD@{24}: checkout: moving from main to refactor/extracting-plan
74c5355 HEAD@{25}: merge fix/test-speed: Fast-forward
123a222 HEAD@{26}: checkout: moving from fix/test-speed to main
74c5355 HEAD@{27}: commit: feat: add verbose test logging via MCP_TEST_VERBOSE=1
aa3b68a HEAD@{28}: commit: feat: add 60s test timeout
8f7a6a8 HEAD@{29}: commit: feat: implement fast mode for tests
123a222 HEAD@{30}: checkout: moving from main to fix/test-speed
123a222 HEAD@{31}: checkout: moving from 3a346f73c31ec5f60dcbb2e3f360c4a2e32f4536 to main
3a346f7 HEAD@{32}: checkout: moving from 42c836bc69c304b1bca92bbe6cb1062107d4647f to 3a346f73c31ec5f60dcbb2e
3f360c4a2e32f4536
42c836b HEAD@{33}: checkout: moving from 384ddbe02e0abda0bbb0da320ce480649ae2aaef to 42c836bc69c304b1bca92bb
e6cb1062107d4647f
384ddbe HEAD@{34}: checkout: moving from 4165d72d7fb3b9441ef455c568313b928720215c to 384ddbe02e0abda0bbb0da3
20ce480649ae2aaef
4165d72 HEAD@{35}: checkout: moving from f395fac53926ec2285f9c279c606b0d05142c1a7 to 4165d72d7fb3b9441ef455c
568313b928720215c
f395fac HEAD@{36}: checkout: moving from main to f395fac53926ec2285f9c279c606b0d05142c1a7
123a222 HEAD@{37}: pull: Fast-forward
2d15472 HEAD@{38}: checkout: moving from fix/faster-tests to main
2d15472 HEAD@{39}: checkout: moving from refactor/centralize-types-and-logic to fix/faster-tests
2d15472 HEAD@{40}: checkout: moving from main to refactor/centralize-types-and-logic
2d15472 HEAD@{41}: checkout: moving from feat/refactor-start-process-payload-logic to main
a530e87 HEAD@{42}: commit: feat: add host inference logic and update schemas
af97e50 HEAD@{43}: commit: fix: correct lint errors related to host type and payload construction
cc42688 HEAD@{44}: commit: fix: remove temporary info_message field
3d4f8d1 HEAD@{45}: commit: fix: remove info_message field from StartSuccessPayload type
684512b HEAD@{46}: commit: fix: remove info_message logic from _startProcess
7ba2763 HEAD@{47}: commit: fix: remove info_message from StartSuccessPayloadSchema
6b19e61 HEAD@{48}: commit: fix: correct lint errors and apply previous edits
0454126 HEAD@{49}: commit: fix: merge instructions logic into message field in _startProcess
1cdda58 HEAD@{50}: commit: fix: remove instructions field from StartSuccessPayloadSchema
2d15472 HEAD@{51}: checkout: moving from main to feat/refactor-start-process-payload-logic
2d15472 HEAD@{52}: pull origin main: Fast-forward
f0fde2c HEAD@{53}: checkout: moving from feat/start-process-host-tracking to main
1d624b0 HEAD@{54}: commit: fix: update host parameter from 'indesurf' to 'windsurf' in documentation and cod
e
9286449 HEAD@{55}: commit (amend): feat: detect and add local server URLs to start_process instructions
4c81a10 HEAD@{56}: commit: feat: detect and add local server URLs to start_process instructions
95fed42 HEAD@{57}: reset: moving to HEAD
95fed42 HEAD@{58}: reset: moving to HEAD
95fed42 HEAD@{59}: commit: docs: update README for start_process host parameter and instructions
733bd75 HEAD@{60}: commit: fix: correct argument order for _startProcess in restartProcessImpl
6cd9295 HEAD@{61}: commit: fix: address test failures and lint errors for host param feature
0d33605 HEAD@{62}: commit: fix: use correct constant for max logs in start_process response
a492c4d HEAD@{63}: commit: feat: pass host parameter during restarts
e591b58 HEAD@{64}: commit: feat: add host parameter and conditional instructions to _startProcess
c3f8667 HEAD@{65}: reset: moving to HEAD
c3f8667 HEAD@{66}: reset: moving to HEAD
c3f8667 HEAD@{67}: commit: feat: add instructions field to StartSuccessPayloadSchema
cf5ed30 HEAD@{68}: commit: feat: add host field to ProcessInfo type
7ee0bdc HEAD@{69}: commit: feat: add host parameter to start_process tool definition
f0fde2c HEAD@{70}: checkout: moving from main to feat/start-process-host-tracking
f0fde2c HEAD@{71}: pull origin main: Fast-forward
5c0cd0d HEAD@{72}: checkout: moving from feat/check-status-wait to main
e55429a HEAD@{73}: commit: fix: Correct process status and log filtering logic
985abc7 HEAD@{74}: commit: feat: Add script to run single failing log filter test
c1edf3e HEAD@{75}: commit: fix: Add payload logging in checkProcessStatusImpl
fe098e7 HEAD@{76}: reset: moving to HEAD
fe098e7 HEAD@{77}: reset: moving to HEAD
fe098e7 HEAD@{78}: commit: fix: Add raw data logging in processLogic.handleData
fd51eaa HEAD@{79}: commit: fix: Add detailed logging in checkProcessStatusImpl
006289c HEAD@{80}: commit: fix: Add server start timestamp log
8b75f48 HEAD@{81}: checkout: moving from fix/verification-timing-issue to feat/check-status-wait
bcff755 HEAD@{82}: commit: fix: Increase initialWaitMs in log filtering test
13520f5 HEAD@{83}: commit: fix: Add detailed logging for process status and fix related build/test errors
8b75f48 HEAD@{84}: checkout: moving from feat/check-status-wait to fix/verification-timing-issue
8b75f48 HEAD@{85}: commit: fix: ensure correct verification and log timing in tests
8d77dc9 HEAD@{86}: commit: fix: wait for verification completion in start_process
7796fc9 HEAD@{87}: commit: feat: implement wait logic and log filtering in check_process_status
4362597 HEAD@{88}: reset: moving to 4362597
e575802 HEAD@{89}: commit: fix: resolve test failures and linter errors
13af8e0 HEAD@{90}: reset: moving to HEAD
13af8e0 HEAD@{91}: reset: moving to HEAD
13af8e0 HEAD@{92}: commit: feat: add integration tests for check_process_status logs and wait
430afcf HEAD@{93}: commit: fix: address linter errors
e0a378d HEAD@{94}: commit: feat: register wait_for_process tool definition (step 5 - no change needed)
dec56e8 HEAD@{95}: commit: feat: implement waitForProcessImpl tool
fca04c3 HEAD@{96}: commit: feat: ensure listProcessesImpl includes log_hint (step 3 - no change needed)
582e5b6 HEAD@{97}: commit: feat: implement checkProcessStatusImpl log waiting and new log return
4362597 HEAD@{98}: commit: feat: add lastLogTimestampReturned to ProcessInfo type
5c0cd0d HEAD@{99}: checkout: moving from main to feat/check-status-wait
5c0cd0d HEAD@{100}: pull origin main: Fast-forward
4b4ef42 HEAD@{101}: checkout: moving from fix/ci-publish-git-check to main
a225b5d HEAD@{102}: cherry-pick: ci: disable git checks during pnpm publish
4b4ef42 HEAD@{103}: checkout: moving from main to fix/ci-publish-git-check
4b4ef42 HEAD@{104}: pull origin main: Fast-forward
10dc8c9 HEAD@{105}: checkout: moving from fix/build-version to main
d2c0217 HEAD@{106}: commit: ci: disable git checks during pnpm publish
4165d72 HEAD@{107}: commit (amend): fix: build package with correct version only in CI release workflow
89bf718 HEAD@{108}: commit: fix: build package with correct version only in CI release workflow
10dc8c9 HEAD@{109}: checkout: moving from main to fix/build-version
10dc8c9 HEAD@{110}: pull origin main: Fast-forward
06cae80 HEAD@{111}: checkout: moving from feat/switch-to-node-pty-prebuilt to main
40dfb54 HEAD@{112}: commit: ci: update setup-msvc action to v2
86b36c9 HEAD@{113}: commit: ci: install windows build tools for node-pty fallback
30fd89d HEAD@{114}: commit: ci: explicitly rebuild node-pty addon in smoke tests
44d0285 HEAD@{115}: commit: ci: add --ignore-scripts to pnpm install steps
3737021 HEAD@{116}: commit: fix: add postinstall script to rebuild dependencies
cf7a17d HEAD@{117}: commit: docs: update references to node-pty-prebuilt-multiarch
c198acf HEAD@{118}: commit: ci: remove node-pty build/cache steps
c67aea8 HEAD@{119}: commit: build: update esbuild config for node-pty-prebuilt-multiarch
ce23e88 HEAD@{120}: commit: refactor: update imports to use node-pty-prebuilt-multiarch
a5ec465 HEAD@{121}: commit: feat: replace node-pty with node-pty-prebuilt-multiarch
06cae80 HEAD@{122}: checkout: moving from main to feat/switch-to-node-pty-prebuilt
06cae80 HEAD@{123}: checkout: moving from feat/mcp-pm-improvements to main
06cae80 HEAD@{124}: reset: moving to HEAD
06cae80 HEAD@{125}: reset: moving to HEAD
06cae80 HEAD@{126}: reset: moving to HEAD
06cae80 HEAD@{127}: reset: moving to HEAD
06cae80 HEAD@{128}: checkout: moving from main to feat/mcp-pm-improvements
06cae80 HEAD@{129}: checkout: moving from fix/release-pnpm-version to main
bd41307 HEAD@{130}: commit: fix: Use packageManager pnpm version in release workflow
06cae80 HEAD@{131}: checkout: moving from main to fix/release-pnpm-version
06cae80 HEAD@{132}: checkout: moving from main to main
06cae80 HEAD@{133}: pull origin main: Fast-forward
384ddbe HEAD@{134}: checkout: moving from add-pre-push-test to main
1ae2ede HEAD@{135}: commit: chore: add test step to pre-push hook
384ddbe HEAD@{136}: checkout: moving from main to add-pre-push-test
384ddbe HEAD@{137}: pull origin main: Fast-forward
42c836b HEAD@{138}: checkout: moving from feat/mcp-pm-integration-tests to main
bb6f614 HEAD@{139}: commit (amend): fix: add delay in restart_process to prevent race condition
a0cd40e HEAD@{140}: commit: fix: add delay in restart_process to prevent race condition
67420ed HEAD@{141}: commit: feat: add restart_process test
e351a7e HEAD@{142}: reset: moving to HEAD
e351a7e HEAD@{143}: reset: moving to HEAD
e351a7e HEAD@{144}: commit: feat: add stop_process test
8488c94 HEAD@{145}: reset: moving to HEAD
8488c94 HEAD@{146}: reset: moving to HEAD
8488c94 HEAD@{147}: commit: feat: add check_process_status test
fdc5fd2 HEAD@{148}: commit: feat: add test for list_processes after starting one
e408845 HEAD@{149}: commit: feat: add list_processes (empty) test and fix assertions/order
086097d HEAD@{150}: reset: moving to HEAD
086097d HEAD@{151}: reset: moving to HEAD
086097d HEAD@{152}: commit: feat: add health_check and start_process tests
26ab82d HEAD@{153}: commit: feat: add first integration test (start/stop) and verbose logging
6d2c0f9 HEAD@{154}: commit: feat: add sendRequest helper function for MCP communication
7493d18 HEAD@{155}: commit: feat: add afterAll hook for server teardown
7d7c684 HEAD@{156}: commit: feat: add beforeAll hook for server startup
a420927 HEAD@{157}: commit: feat: add initial structure for mcp-server integration tests
4212355 HEAD@{158}: commit: feat: add integration test directory structure
8f7ee72 HEAD@{159}: commit: feat: add test scripts to package.json
6486b19 HEAD@{160}: commit: feat: add vitest and @types/node dependencies
42c836b HEAD@{161}: checkout: moving from main to feat/mcp-pm-integration-tests
42c836b HEAD@{162}: pull origin main: Fast-forward
3a346f7 HEAD@{163}: checkout: moving from feat/add-release-publish-step to main
515cd94 HEAD@{164}: commit: ci: update node-gyp installation step on Windows in CI workflow to use environme
nt variable for path export
00adb5b HEAD@{165}: commit: ci: simplify node-gyp installation step on Windows in CI workflow by removing ve
rification and adjusting npm config commands
082df38 HEAD@{166}: commit: ci: add verification step for node-gyp path on Windows in CI workflow
974a69e HEAD@{167}: commit: chore: update node-pty version to 1.1.0-beta34 and format package.json for consi
stency
2b4b2a6 HEAD@{168}: commit: ci: rename runtime dependencies installation step in CI workflow
67519d8 HEAD@{169}: commit: ci: remove node-gyp installation step for Windows from CI workflow
f516f0d HEAD@{170}: commit: ci: remove shell specification for node-gyp installation step in CI workflow
2f59c48 HEAD@{171}: commit: ci: add step to force node-gyp version 11.2.0 on Windows in CI workflow
f418d19 HEAD@{172}: commit: ci: comment out node-gyp installation and rebuild steps in CI workflow, add runt
ime dependencies installation step
1158682 HEAD@{173}: commit: ci: add node-gyp installation step for Windows in CI workflow
86c5c54 HEAD@{174}: commit: fix(ci): restore node-pty cache before install in smoke test
f7ec9b2 HEAD@{175}: commit: ci: remove husky prepare script from runtime dependencies installation step in C
I workflow
19adea9 HEAD@{176}: commit: ci: remove husky prepare script from package.json
bdceae7 HEAD@{177}: commit: ci: update node-pty rebuild command in CI workflow to use pnpm rebuild
4d0f900 HEAD@{178}: commit: ci: update onlyBuiltDependencies in package.json to include esbuild and @biomejs
/biome
1b83185 HEAD@{179}: commit: ci: update runtime dependencies installation and refine node-pty rebuild step
a80da99 HEAD@{180}: commit: ci: refine node-pty handling in smoke-test job
5919dbc HEAD@{181}: commit: fix: add node-gyp@^11.2.0 to devDependencies to resolve Windows build error
c6c95a5 HEAD@{182}: commit: ci: cache node-pty rebuild artifact on Windows
1da8b09 HEAD@{183}: commit: ci: optimize workflow by extracting Node version once
726061d HEAD@{184}: commit: ci: add step to rebuild node-pty in CI workflow
b070134 HEAD@{185}: commit: ci: extract node version from pnpm-workspace.yaml using yq
3cce4e2 HEAD@{186}: commit: fix: update Node version file reference in CI workflow to pnpm-workspace.yaml
bc71c7e HEAD@{187}: commit (amend): feat: add step to indicate npm publish status
5bf73a8 HEAD@{188}: commit: feat: add step to indicate npm publish status
f724d03 HEAD@{189}: checkout: moving from fix/pnpm-node-pty-abi to feat/add-release-publish-step
f724d03 HEAD@{190}: commit: fix: Lock Node/pnpm versions and rebuild node-pty automatically
3a346f7 HEAD@{191}: checkout: moving from main to fix/pnpm-node-pty-abi
3a346f7 HEAD@{192}: pull origin main: Fast-forward
f395fac HEAD@{193}: checkout: moving from trigger-build to main
7089504 HEAD@{194}: commit (amend): fix: trigger release for windows support
5345839 HEAD@{195}: commit: chore: trigger build
f395fac HEAD@{196}: checkout: moving from main to trigger-build
f395fac HEAD@{197}: checkout: moving from feat/add-integration-tests to main
6c985c0 HEAD@{198}: reset: moving to HEAD
6c985c0 HEAD@{199}: commit: feat: implement sendRequest helper for MCP communication
6c375c1 HEAD@{200}: commit: feat: implement afterAll hook for server teardown
f20a0a2 HEAD@{201}: commit: feat: implement beforeAll hook for server startup
801fa00 HEAD@{202}: commit: feat: add basic structure for mcp-pm integration tests
5b676a9 HEAD@{203}: commit: feat: create directory structure for integration tests
8393050 HEAD@{204}: commit: feat: add vitest test scripts to package.json
88eb7e6 HEAD@{205}: commit: feat: add vitest and node types for integration testing
f395fac HEAD@{206}: checkout: moving from main to feat/add-integration-tests
f395fac HEAD@{207}: pull origin main: Fast-forward
d5a5454 HEAD@{208}: checkout: moving from update-release-workflow to main
5d54c9d HEAD@{209}: commit: chore: update release workflow to use pnpm
d5a5454 HEAD@{210}: checkout: moving from main to update-release-workflow
d5a5454 HEAD@{211}: pull origin main: Fast-forward
3406c56 HEAD@{212}: checkout: moving from feat/windows-support to main
5e8ba27 HEAD@{213}: commit: test(ci): run bash smoke test on windows in addition to powershell
b2311be HEAD@{214}: commit: refactor(ci): use separate bash/pwsh scripts for smoke test
aa7d9a1 HEAD@{215}: commit: feat: add smoke-test.ps1 for windows native shell testing
d161513 HEAD@{216}: commit: fix(ci): explicitly exit in smoke-test.sh to handle windows timeout code
7168391 HEAD@{217}: commit: fix(ci): correct yaml syntax for cache path
dfd6ea8 HEAD@{218}: commit: feat(ci): cache node-pty build artifacts on windows
dc8c830 HEAD@{219}: commit: fix(ci): adjust windows timeout logic in smoke-test.sh
29f5db3 HEAD@{220}: commit: fix(ci): make smoke-test.sh nounset-safe and handle windows exit code
87fea58 HEAD@{221}: commit: fix(ci): use taskkill in smoke-test.sh on windows
4e4e5fd HEAD@{222}: commit: fix(ci): rebuild node-pty after ignoring scripts during install
58301b5 HEAD@{223}: commit: fix(ci): ignore scripts during prod dep install in smoke-test
0efa8ae HEAD@{224}: commit: fix(ci): correct pnpm cache setup order in smoke-test
a113b8f HEAD@{225}: commit: fix(ci): install prod deps in smoke-test job
ae59f5e HEAD@{226}: commit: fix: use robust timeout_guard in smoke-test.sh
21a4245 HEAD@{227}: commit: chore: update package.json and pnpm-lock.yaml to include zod dependency
bcfba58 HEAD@{228}: commit: refactor(ci): use smoke-test.sh script
1ffafe6 HEAD@{229}: commit: feat: add smoke-test.sh script
c7031c8 HEAD@{230}: commit: chore: replace package-lock.json with pnpm-lock.yaml for improved dependency man
agement
99eaa27 HEAD@{231}: commit: chore(ci): enhance CI workflow for ultra-fast builds and improved dependency man
agement
20acc74 HEAD@{232}: commit: fix(ci): update artifact name syntax in CI workflow
346b67a HEAD@{233}: commit: chore(ci): update CI configuration for faster builds and improved caching
ba75a1b HEAD@{234}: commit: feat(ci): add Windows support with multi-platform sanity checks and CI matrix
9ea6358 HEAD@{235}: commit: fix(ci): correctly capture smoke test exit code with bash -e
a51da47 HEAD@{236}: commit: fix(ci): force bash, install coreutils for consistent timeout
99a4f52 HEAD@{237}: commit: fix(ci): handle timeout exit code 124 correctly in smoke test
560914c HEAD@{238}: commit: fix(ci): remove explicit shell, use gtimeout on macos
bc21180 HEAD@{239}: commit: ci: add concurrency control to cancel older runs
e220391 HEAD@{240}: commit: chore: add diagnostic logging for path creation
8d6bf6f HEAD@{241}: commit: fix(ci): revert log directory creation to use path.join
b606598 HEAD@{242}: commit: fix(ci): use path.resolve for log directory creation
4264950 HEAD@{243}: commit: fix: ensure log directory name is treated as relative path segment
39c0c47 HEAD@{244}: commit: fix: mark fkill as external for esbuild
091a7da HEAD@{245}: commit: fix: update package-lock.json
fab5968 HEAD@{246}: commit: chore: remove pnpm-lock.yaml
b3fcfef HEAD@{247}: commit: fix: sanitize reserved filenames on windows
a6bed0c HEAD@{248}: commit: ci: add windows and macos to build matrix
4246ae2 HEAD@{249}: commit: feat: add cross-platform tail command helper
79854b5 HEAD@{250}: commit: fix: use fkill for cross-platform process termination
e466fbc HEAD@{251}: commit: fix: use default-shell for windows compatibility
7bd9477 HEAD@{252}: commit: feat: add windows compatibility dependencies
3406c56 HEAD@{253}: checkout: moving from main to feat/windows-support
3406c56 HEAD@{254}: pull origin main: Fast-forward
295033d HEAD@{255}: checkout: moving from refactor/tail-instruction to main
df426dc HEAD@{256}: commit: fix: update zod descriptions for start_process payload
e773ae6 HEAD@{257}: commit: feat: modify monitoring_hint for start_process to provide tail instruction
295033d HEAD@{258}: checkout: moving from main to refactor/tail-instruction
295033d HEAD@{259}: pull origin main: Fast-forward
083730c HEAD@{260}: checkout: moving from feature/update-tool-definitions to main
e56c158 HEAD@{261}: commit: Update tool definitions
083730c HEAD@{262}: checkout: moving from main to feature/update-tool-definitions
083730c HEAD@{263}: checkout: moving from main to main
083730c HEAD@{264}: pull origin main: Fast-forward
ecb1cd8 HEAD@{265}: checkout: moving from feature/graceful-stop to main
25b18b6 HEAD@{266}: commit: feat: implement graceful stop (SIGTERM -> Wait -> SIGKILL)
ecb1cd8 HEAD@{267}: reset: moving to HEAD
ecb1cd8 HEAD@{268}: reset: moving to HEAD
ecb1cd8 HEAD@{269}: checkout: moving from main to feature/graceful-stop
ecb1cd8 HEAD@{270}: pull origin main: Fast-forward
6161159 HEAD@{271}: checkout: moving from fix/biome-vscode-settings to main
0c04aca HEAD@{272}: commit: fix: Configure Biome explicitly for JSON in VSCode settings
6161159 HEAD@{273}: checkout: moving from main to fix/biome-vscode-settings
6161159 HEAD@{274}: pull origin main: Fast-forward
85b9f4a HEAD@{275}: checkout: moving from clarity-sweep to main
0f30398 HEAD@{276}: commit: fix: Address linter errors from refactoring
f9e62b7 HEAD@{277}: commit: docs: Add Tool Catalogue section to README
892e20e HEAD@{278}: commit: style: Clean up Zod descriptions (remove markdown)
ef26603 HEAD@{279}: commit: docs: Add docblock to sanitizeLabelForFilename
9df093c HEAD@{280}: commit: refactor: Define and use Zod schemas for response payloads
3c90078 HEAD@{281}: commit: docs: Add comments to constants
c99ad68 HEAD@{282}: commit: fix: Correct validation for label and verification_timeout_ms
85b9f4a HEAD@{283}: checkout: moving from main to clarity-sweep
85b9f4a HEAD@{284}: pull origin main: Fast-forward
ac35f67 HEAD@{285}: checkout: moving from feat/improve-start-process-feedback to main
8225d69 HEAD@{286}: commit: feat: Improve start_process feedback and timeouts
ac35f67 HEAD@{287}: checkout: moving from main to feat/improve-start-process-feedback
ac35f67 HEAD@{288}: checkout: moving from main to main
ac35f67 HEAD@{289}: reset: moving to ac35f6740384133d66babcd8899c611e1037f403
ac35f67 HEAD@{290}: reset: moving to HEAD
ac35f67 HEAD@{291}: pull origin main: Fast-forward
b2c5f24 HEAD@{292}: checkout: moving from fix/semantic-release-pr to main
1eaf72b HEAD@{293}: commit (merge): Merge branch 'main' into fix/semantic-release-pr
a8293a7 HEAD@{294}: checkout: moving from main to fix/semantic-release-pr
b2c5f24 HEAD@{295}: pull origin main: Fast-forward
6115ff4 HEAD@{296}: checkout: moving from fix/semantic-release-pr to main
a8293a7 HEAD@{297}: commit: fix: trigger release workflow on push to main and add esbuild dep
6115ff4 HEAD@{298}: checkout: moving from main to fix/semantic-release-pr
6115ff4 HEAD@{299}: checkout: moving from feat/start-process-initial-logs to main
4d0d20c HEAD@{300}: merge origin/main: Merge made by the 'ort' strategy.
19c705a HEAD@{301}: commit: feat: Enhance start_process to capture all initial logs and update label descrip
tion
1bb2270 HEAD@{302}: commit: feat: Return all initial logs in start_process response
e526b0e HEAD@{303}: commit: feat: Increase log wait timeout for start_process
6115ff4 HEAD@{304}: checkout: moving from main to feat/start-process-initial-logs
6115ff4 HEAD@{305}: checkout: moving from chore/update-ci-and-hooks to main
8a57b70 HEAD@{306}: commit: fix: Adjust CI smoke test to handle timeout exit code
b591d93 HEAD@{307}: commit: Update package.json
be569c2 HEAD@{308}: commit: Update CI workflow and post-checkout hook
6115ff4 HEAD@{309}: checkout: moving from main to chore/update-ci-and-hooks
6115ff4 HEAD@{310}: pull --tags origin main: Fast-forward
06c80ba HEAD@{311}: checkout: moving from feat/husky-lint-staged-npm to main
82c8aed HEAD@{312}: commit: chore: apply stashed changes after rebase
590a671 HEAD@{313}: commit: chore: regenerate package-lock.json after rebase
cfa14fd HEAD@{314}: rebase (finish): returning to refs/heads/feat/husky-lint-staged-npm
cfa14fd HEAD@{315}: rebase (pick): fix: address husky and lint-staged warnings
e9308a9 HEAD@{316}: rebase (continue): feat: setup husky, lint-staged, and biome with npm
64c14e0 HEAD@{317}: pull origin main --rebase (start): checkout 64c14e0e7c1128982efb7749d104c378b2cd4585
fd399cf HEAD@{318}: commit: fix: address husky and lint-staged warnings
6058425 HEAD@{319}: commit: feat: setup husky, lint-staged, and biome with npm
06c80ba HEAD@{320}: checkout: moving from 06c80bad488d1d81ec1651a00b8882fe3324c4d7 to feat/husky-lint-staged
-npm
06c80ba HEAD@{321}: checkout: moving from feat/husky-lint-staged to 06c80ba
0e4c09f HEAD@{322}: commit (amend): chore: install husky and lint-staged
1416b06 HEAD@{323}: commit: chore: install husky and lint-staged
06c80ba HEAD@{324}: checkout: moving from main to feat/husky-lint-staged
06c80ba HEAD@{325}: checkout: moving from fix/release-workflow-failure to main
45ea2ec HEAD@{326}: reset: moving to HEAD
45ea2ec HEAD@{327}: commit: fix: update dependencies to resolve release issue
06c80ba HEAD@{328}: checkout: moving from main to fix/release-workflow-failure
06c80ba HEAD@{329}: reset: moving to origin/main
06c80ba HEAD@{330}: checkout: moving from main to main
06c80ba HEAD@{331}: checkout: moving from feat/refactor-file-organization to main
641256b HEAD@{332}: commit: chore: update package-lock.json and package.json for dependency management and f
ormatting
60951d7 HEAD@{333}: checkout: moving from main to feat/refactor-file-organization
06c80ba HEAD@{334}: pull --tags origin main: Fast-forward
19fd623 HEAD@{335}: checkout: moving from feat/refactor-file-organization to main
60951d7 HEAD@{336}: commit: chore: simplify CI workflow for debugging
3f509d3 HEAD@{337}: commit: chore: minor update to ci workflow trigger re-evaluation
a77f561 HEAD@{338}: commit: style: format biome.json for consistent indentation
98dd86c HEAD@{339}: commit: feat: add CI workflow for build and smoke test
365bd88 HEAD@{340}: commit: chore(release): trigger release on merged PR to main
0834fab HEAD@{341}: commit: feat: configure esbuild for ESM output
8a1a316 HEAD@{342}: reset: moving to HEAD
8a1a316 HEAD@{343}: commit: Phase 6: Organize Tool Implementations
6f801ad HEAD@{344}: commit: Phase 5: Isolate State Management and Supervision
06d178b HEAD@{345}: commit: Phase 4: Separate Process Lifecycle Logic
64f38c7 HEAD@{346}: commit: Phase 3: Isolate PTY Management
19fd623 HEAD@{347}: checkout: moving from main to feat/refactor-file-organization
19fd623 HEAD@{348}: commit: feat: add persistent logging to process manager
83befb6 HEAD@{349}: commit: feat: send input
b07c5b6 HEAD@{350}: commit: fix: get_all_loglines
0cc12d1 HEAD@{351}: commit: fix: log formatting
4c851dc HEAD@{352}: commit: feat: settle
b7b6e65 HEAD@{353}: commit: fix: version number
78fd47c HEAD@{354}: commit: fix: version number
1d2c247 HEAD@{355}: commit: fix: stored log lines
a36f1ac HEAD@{356}: commit: fix: log lines
98b7608 HEAD@{357}: commit: fix: optional timeout
995c379 HEAD@{358}: commit: fix: optional timeout
994eacc HEAD@{359}: commit: fix: README
1fc3b65 HEAD@{360}: commit: fix: repo
341f1a3 HEAD@{361}: commit: fix: README
2b112aa HEAD@{362}: commit: fix: README
fe9a7f0 HEAD@{363}: commit: fix: Make start_process label optional and add examples
b4bbefb HEAD@{364}: commit: fix: track pid
0dbeb5d HEAD@{365}: commit: fix: working directory
077befd HEAD@{366}: commit: feat: Make workingDirectory mandatory and enforce uniqueness
d122972 HEAD@{367}: commit: refactor: Rename mcp-dev-server to mcp-pm and generalize functionality
75a4161 HEAD@{368}: commit: fix: trigger new release version
0771b4d HEAD@{369}: commit: chore: trigger release
4e9f552 HEAD@{370}: commit: fix: npm
285e63c HEAD@{371}: commit (amend): style: format health_check code
643f602 HEAD@{372}: commit: style: format health_check code
b65839a HEAD@{373}: commit: feat: add health_check tool
d209904 HEAD@{374}: commit: fix: type errors
634c32d HEAD@{375}: commit: fix: working directory
1d25a52 HEAD@{376}: commit (amend): fix: Extract code from index.ts into modules
af23ebd HEAD@{377}: commit: Refactor: Extract code from index.ts into modules
52be83e HEAD@{378}: commit: fix: trigger release workflow with updated token
fd3d62d HEAD@{379}: commit: fix: correct syntax in .releaserc.json
94ccffa HEAD@{380}: commit: chore: update package-lock.json
5932665 HEAD@{381}: commit: chore: set placeholder version in package.json
9b5fe9d HEAD@{382}: commit: fix: initial release setup
1e1b04c HEAD@{383}: commit: ci: add semantic release workflow
b4ee8ec HEAD@{384}: commit: chore: add .npmrc to gitignore
c82d6ba HEAD@{385}: commit (initial): chore: configure semantic release and prepare for publishing
➜  mcp-dev-server git:(refactor/foundation-cleanup)
```

---

Okay, analyzing the reflog:
- `8726d1a HEAD@{0}: reset: moving to HEAD~1` (This is the last reset, moving *to* the passing commit `8726d1a` *from* `9d21b9f`)
- `9d21b9f HEAD@{1}: reset: moving to HEAD~1` (This is the first reset, moving *to* commit `9d21b9f` *from* the original failing commit)
- `d7eb042 HEAD@{2}: commit: feat(log): consolidate logging logic in src/logging.ts` (This is the commit we reset *from* in the first step)

So, the initial failing commit hash was `d7eb042`. The passing commit hash is `8726d1a`.

Now, let's generate the diff between the passing commit (`8726d1a`) and the initial failing commit (`d7eb042`). This will show the changes that were reverted to fix the tests.

---

```bash
git diff 8726d1a d7eb042 | cat
```

```
➜  mcp-dev-server git:(refactor/foundation-cleanup) git diff 8726d1a d7eb042 | cat
diff --git a/package.json b/package.json
index 633b7d7..e84b00a 100644
--- a/package.json
+++ b/package.json
@@ -20,10 +20,11 @@
                "lint:fix": "biome check --write .",
                "verify": "pnpm build && pnpm lint:fix",
                "start": "node build/index.mjs",
-               "test": "pnpm build && vitest run --test-timeout=60000",
-               "test:verbose": "pnpm build && MCP_TEST_VERBOSE=1 vitest run --test-timeout=60000",
-               "test:watch": "pnpm build &&vitest",
-               "test:filter-logs": "pnpm build && vitest run -t \"should filter logs correctly on repeated 
checks of an active process\"",
+               "pretest": "pnpm build",
+               "test": "vitest run --test-timeout=60000",
+               "test:verbose": "MCP_TEST_VERBOSE=1 vitest run --test-timeout=60000",
+               "test:watch": "vitest",
+               "test:filter-logs": "vitest run -t \"should filter logs correctly on repeated checks of an a
ctive process\"",
                "postinstall": "pnpm rebuild node-pty"
        },
        "dependencies": {
diff --git a/src/log/ansi.ts b/src/log/ansi.ts
new file mode 100644
index 0000000..3d8dda5
--- /dev/null
+++ b/src/log/ansi.ts
@@ -0,0 +1,52 @@
+import stripAnsi from "strip-ansi";
+
+// Ideally, import the central log object here for error logging,
+// but that creates a circular dependency (log -> state -> process -> log).
+// We'll use console.error directly for errors within stripping.
+
+// Helper Functions
+export function stripAnsiSafe(input: string): string {
+       if (typeof input !== "string") return input;
+       try {
+               const cleanedInput = input.replace(/\\u0000/g, "");
+               return stripAnsi(cleanedInput);
+       } catch (e: unknown) {
+               console.error(
+                       `[mcp-pm] ERROR: Error stripping ANSI: ${e instanceof Error ? e.message : String(e)}
`,
+               );
+               return input;
+       }
+}
+
+// biome-ignore lint/suspicious/noControlCharactersInRegex: <explanation>
+const CONTROL_CHAR_REGEX = /\r|\b|\u0007/g;
+// biome-ignore lint/suspicious/noControlCharactersInRegex: <explanation>
+const NULL_BYTE_REGEX = /\u0000/g;
+// biome-ignore lint/suspicious/noControlCharactersInRegex: Need to match backspace for cleanup
+const BACKSPACE_REGEX = /.\x08/g;
+// biome-ignore lint/suspicious/noControlCharactersInRegex: Need to match specific control chars
+const OTHER_CONTROL_CHARS_REGEX = /[\r\x07]/g;
+
+export function stripAnsiAndControlChars(input: string): string {
+       if (typeof input !== "string") return input;
+       try {
+               let cleanedInput = input.replace(BACKSPACE_REGEX, "");
+               cleanedInput = cleanedInput.replace(NULL_BYTE_REGEX, "");
+               cleanedInput = cleanedInput.replace(OTHER_CONTROL_CHARS_REGEX, "");
+               cleanedInput = stripAnsi(cleanedInput);
+               return cleanedInput;
+       } catch (e: unknown) {
+               console.error(
+                       `[mcp-pm] ERROR: Error stripping ANSI/Control Chars: ${e instanceof Error ? e.messag
e : String(e)}`,
+                       { originalInput: `${input.substring(0, 100)}...` },
+               );
+               try {
+                       let fallback = input.replace(BACKSPACE_REGEX, "");
+                       fallback = fallback.replace(NULL_BYTE_REGEX, "");
+                       fallback = fallback.replace(OTHER_CONTROL_CHARS_REGEX, "");
+                       return fallback;
+               } catch {
+                       return input;
+               }
+       }
+}
diff --git a/src/logging.ts b/src/logging.ts
new file mode 100644
index 0000000..01ee0a1
--- /dev/null
+++ b/src/logging.ts
@@ -0,0 +1,125 @@
+// src/logging.ts
+// This file will consolidate logging logic.
+
+import * as fs from "node:fs";
+import * as path from "node:path";
+import { cfg } from "./constants/index.js";
+import { serverLogDirectory } from "./main.js"; // Need access to this global
+import {
+       addLogEntry as addLogEntryToState,
+       managedProcesses,
+} from "./state.js";
+import type { ProcessInfo } from "./types/process.js";
+import { sanitizeLabelForFilename } from "./utils.js";
+
+// Consolidated logger object
+export const log = {
+       info: (label: string | null, message: string, data?: unknown) => {
+               console.error(
+                       `[${cfg.serverName}${label ? ` ${label}` : ""}] INFO: ${message}`,
+                       data ?? "",
+               );
+               if (label) {
+                       addLogEntryToState(label, `INFO: ${message}`);
+               }
+       },
+       warn: (label: string | null, message: string, data?: unknown) => {
+               console.error(
+                       `[${cfg.serverName}${label ? ` ${label}` : ""}] WARN: ${message}`,
+                       data ?? "",
+               );
+               if (label) {
+                       addLogEntryToState(label, `WARN: ${message}`);
+               }
+       },
+       error: (label: string | null, message: string, error?: unknown) => {
+               console.error(
+                       `[${cfg.serverName}${label ? ` ${label}` : ""}] ERROR: ${message}`,
+                       error ?? "",
+               );
+               if (label) {
+                       const errorString =
+                               error instanceof Error ? error.message : String(error);
+                       addLogEntryToState(
+                               label,
+                               `ERROR: ${message}${error ? `: ${errorString}` : ""}`,
+                       );
+               }
+       },
+       debug: (label: string | null, message: string, data?: unknown) => {
+               console.error(
+                       `[${cfg.serverName}${label ? ` ${label}` : ""}] DEBUG: ${message}`,
+                       data ?? "",
+               );
+               // Optionally add debug logs to state if needed, but generally not.
+               // if (label) {
+               //   addLogEntryToState(label, `DEBUG: ${message}`);
+               // }
+       },
+       // New method specifically for raw process output
+       processOutput: (label: string, message: string) => {
+               // Only add to state/file, do not mirror to console.error
+               if (label) {
+                       addLogEntryToState(label, message); // Add raw message
+               }
+       },
+};
+
+/**
+ * Sets up the log file stream for a given process.
+ * Updates the processInfo object with the path and stream.
+ *
+ * @param processInfo The process information object (will be mutated).
+ */
+export function setupLogFileStream(processInfo: ProcessInfo): void {
+       const { label } = processInfo;
+
+       if (!serverLogDirectory) {
+               log.warn(
+                       label,
+                       "Log directory not configured, persistent file logging disabled.",
+               );
+               processInfo.logFilePath = null;
+               processInfo.logFileStream = null;
+               return;
+       }
+
+       try {
+               const safeFilename = `${sanitizeLabelForFilename(label)}.log`;
+               const logFilePath = path.join(serverLogDirectory, safeFilename);
+               log.info(label, `Setting up log file stream: ${logFilePath}`);
+
+               const logFileStream = fs.createWriteStream(logFilePath, { flags: "a" });
+
+               logFileStream.on("error", (err) => {
+                       log.error(label, `Error writing to log file ${logFilePath}:`, err);
+                       const currentInfo = managedProcesses.get(label); // Get potentially updated info
+                       if (currentInfo) {
+                               currentInfo.logFileStream?.end(); // Attempt to close
+                               currentInfo.logFileStream = null; // Prevent further writes
+                               currentInfo.logFilePath = null; // Clear path as it's unusable
+                       }
+               });
+
+               logFileStream.on("open", () => {
+                       log.debug(label, `Log file stream opened: ${logFilePath}`);
+                       // Write initial marker AFTER stream is confirmed open
+                       // Use the logger to ensure it's captured
+                       log.processOutput(
+                               label,
+                               `--- Process Started (${new Date().toISOString()}) ---`,
+                       );
+               });
+
+               // Update processInfo directly
+               processInfo.logFilePath = logFilePath;
+               processInfo.logFileStream = logFileStream;
+               log.info(label, `Logging process output to: ${logFilePath}`);
+       } catch (error) {
+               log.error(label, "Failed to create or open log file stream", error);
+               processInfo.logFilePath = null; // Ensure path/stream are null if setup failed
+               processInfo.logFileStream = null;
+       }
+}
+
+// export {}; // Remove placeholder export
diff --git a/src/main.ts b/src/main.ts
index 78c51ba..e712bb3 100644
--- a/src/main.ts
+++ b/src/main.ts
@@ -4,13 +4,13 @@ import * as path from "node:path";
 import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
 import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
 import { cfg } from "./constants/index.js";
+import { log } from "./logging.js";
 import { stopAllProcessesOnExit } from "./process/retry.js";
 import {
        clearZombieCheckInterval,
        setZombieCheckInterval,
 } from "./processSupervisor.js";
 import { registerToolDefinitions } from "./toolDefinitions.js";
-import { log } from "./utils.js";
 
 // [MCP-TEST-LOG STEP 1.1] Log server start with timestamp
 const startTimestamp = new Date().toISOString();
diff --git a/src/process/lifecycle.ts b/src/process/lifecycle.ts
index 43d327d..3f10da1 100644
--- a/src/process/lifecycle.ts
+++ b/src/process/lifecycle.ts
@@ -4,11 +4,11 @@ import type { IPty } from "node-pty";
 import type { z } from "zod";
 
 import { cfg } from "../constants/index.js";
+import { log } from "../logging.js";
 import { fail, ok, textPayload } from "../mcpUtils.js";
 import { checkAndUpdateProcessStatus } from "../processSupervisor.js";
 import { killPtyProcess } from "../ptyManager.js";
 import {
-       addLogEntry,
        getProcessInfo,
        managedProcesses,
        updateProcessStatus,
@@ -20,12 +20,12 @@ import type {
        ProcessStatus,
 } from "../types/process.js";
 import type * as schemas from "../types/schemas.js";
-import { formatLogsForResponse, getTailCommand, log } from "../utils.js";
+import { formatLogsForResponse, getTailCommand } from "../utils.js";
 
 // Import newly created functions
-import { setupLogFileStream } from "./logging.js";
-import { handleProcessExit } from "./retry.js"; // Assuming retry logic helper is named this
-import { spawnPtyProcess } from "./spawn.js"; // <-- Import spawnPtyProcess
+import { setupLogFileStream } from "../logging.js";
+import { handleProcessExit } from "./retry.js";
+import { spawnPtyProcess } from "./spawn.js";
 import { verifyProcessStartup } from "./verify.js";
 
 /**
@@ -49,7 +49,7 @@ export function handleData(
 
        // Add the log entry to the managed process state
        // Use addLogEntry which also handles file logging
-       addLogEntry(label, data);
+       log.processOutput(label, data);
 }
 
 /**
@@ -61,7 +61,7 @@ export async function stopProcess(
        force = false,
 ): Promise<CallToolResult> {
        log.info(label, `Stop requested for process "${label}". Force: ${force}`);
-       addLogEntry(label, `Stop requested. Force: ${force}`);
+       log.processOutput(label, `Stop requested. Force: ${force}`);
 
        // Refresh status before proceeding
        const initialProcessInfo = await checkAndUpdateProcessStatus(label);
@@ -128,7 +128,7 @@ export async function stopProcess(
                                label,
                                `Force stop requested. Sending SIGKILL to PID ${pidToKill}...`,
                        );
-                       addLogEntry(label, "Sending SIGKILL...");
+                       log.processOutput(label, "Sending SIGKILL...");
                        await killPtyProcess(processToKill, label, "SIGKILL");
                        // Note: The onExit handler will update the status.
                        finalMessage = `Force stop requested. SIGKILL sent to PID ${pidToKill}.`;
@@ -140,7 +140,7 @@ export async function stopProcess(
                                label,
                                `Attempting graceful shutdown. Sending SIGTERM to PID ${pidToKill}...`,
                        );
-                       addLogEntry(label, "Sending SIGTERM...");
+                       log.processOutput(label, "Sending SIGTERM...");
                        await killPtyProcess(processToKill, label, "SIGTERM");
 
                        log.debug(
@@ -166,21 +166,24 @@ export async function stopProcess(
                                        label,
                                        `Process ${pidToKill} did not terminate after SIGTERM and ${cfg.stop
WaitDurationMs}ms wait. Sending SIGKILL.`,
                                );
-                               addLogEntry(label, "Graceful shutdown timed out. Sending SIGKILL...");
+                               log.processOutput(
+                                       label,
+                                       "Graceful shutdown timed out. Sending SIGKILL...",
+                               );
                                await killPtyProcess(processToKill, label, "SIGKILL");
                                finalMessage = `Process ${pidToKill} did not terminate gracefully. SIGKILL s
ent.`;
                                finalStatus = "stopping"; // Assume stopping until exit confirms
                        } else {
                                finalMessage = `Process ${pidToKill} terminated gracefully after SIGTERM.`;
                                log.info(label, finalMessage);
-                               addLogEntry(label, "Process terminated gracefully.");
+                               log.processOutput(label, "Process terminated gracefully.");
                                finalStatus = infoAfterWait?.status ?? "stopped"; // Use status after wait
                        }
                }
        } catch (error) {
                const errorMsg = `Error stopping process ${label} (PID: ${pidToKill}): ${error instanceof Er
ror ? error.message : String(error)}`;
                log.error(label, errorMsg);
-               addLogEntry(label, `Error stopping process: ${errorMsg}`);
+               log.processOutput(label, `Error stopping process: ${errorMsg}`);
                finalMessage = `Error stopping process: ${errorMsg}`;
                updateProcessStatus(label, "error"); // Ensure status is error
                finalStatus = "error";
@@ -328,7 +331,7 @@ export async function startProcess(
                        });
                }
                updateProcessStatus(label, "error");
-               addLogEntry(label, `Error: ${errorMsg}`);
+               log.processOutput(label, `Error: ${errorMsg}`);
                const payload: z.infer<typeof schemas.StartErrorPayloadSchema> = {
                        error: errorMsg,
                        status: "error",
@@ -371,7 +374,7 @@ export async function startProcess(
 
        // 5. Setup Log File Streaming (call helper)
        setupLogFileStream(processInfo); // Mutates processInfo
-       addLogEntry(
+       log.processOutput(
                label,
                `Process spawned successfully (PID: ${ptyProcess.pid}) in ${effectiveWorkingDirectory}. Stat
us: starting.`,
        );
diff --git a/src/process/logging.ts b/src/process/logging.ts
index c251ddd..e426bc0 100644
--- a/src/process/logging.ts
+++ b/src/process/logging.ts
@@ -1,62 +1,3 @@
-import * as fs from "node:fs";
-import * as path from "node:path";
-import { serverLogDirectory } from "../main.js"; // Adjust path
-import { addLogEntry, managedProcesses } from "../state.js"; // Adjust path
-import type { ProcessInfo } from "../types/process.js"; // Adjust path
-import { log, sanitizeLabelForFilename } from "../utils.js"; // Adjust path
+// This file is now empty after moving setupLogFileStream to src/logging.ts
 
-/**
- * Sets up the log file stream for a given process.
- * Updates the processInfo object with the path and stream.
- *
- * @param processInfo The process information object (will be mutated).
- */
-export function setupLogFileStream(processInfo: ProcessInfo): void {
-       const { label } = processInfo;
-
-       if (!serverLogDirectory) {
-               log.warn(
-                       label,
-                       "Log directory not configured, persistent file logging disabled.",
-               );
-               processInfo.logFilePath = null;
-               processInfo.logFileStream = null;
-               return;
-       }
-
-       try {
-               const safeFilename = `${sanitizeLabelForFilename(label)}.log`;
-               const logFilePath = path.join(serverLogDirectory, safeFilename);
-               log.info(label, `Setting up log file stream: ${logFilePath}`);
-
-               const logFileStream = fs.createWriteStream(logFilePath, { flags: "a" });
-
-               logFileStream.on("error", (err) => {
-                       log.error(label, `Error writing to log file ${logFilePath}:`, err);
-                       const currentInfo = managedProcesses.get(label); // Get potentially updated info
-                       if (currentInfo) {
-                               currentInfo.logFileStream?.end(); // Attempt to close
-                               currentInfo.logFileStream = null; // Prevent further writes
-                               currentInfo.logFilePath = null; // Clear path as it's unusable
-                       }
-               });
-
-               logFileStream.on("open", () => {
-                       log.debug(label, `Log file stream opened: ${logFilePath}`);
-                       // Write initial marker AFTER stream is confirmed open
-                       addLogEntry(
-                               label,
-                               `--- Process Started (${new Date().toISOString()}) ---`,
-                       );
-               });
-
-               // Update processInfo directly
-               processInfo.logFilePath = logFilePath;
-               processInfo.logFileStream = logFileStream;
-               log.info(label, `Logging process output to: ${logFilePath}`);
-       } catch (error) {
-               log.error(label, "Failed to create or open log file stream", error);
-               processInfo.logFilePath = null; // Ensure path/stream are null if setup failed
-               processInfo.logFileStream = null;
-       }
-}
+export {}; // Keep as module
diff --git a/src/process/retry.ts b/src/process/retry.ts
index d11398d..713e967 100644
--- a/src/process/retry.ts
+++ b/src/process/retry.ts
@@ -1,8 +1,8 @@
 import { cfg } from "../constants/index.js"; // Update path
+import { log } from "../logging.js"; // Update path
 import { killProcessTree } from "../processLifecycle.js";
-import { addLogEntry, getProcessInfo, updateProcessStatus } from "../state.js"; // Adjust path
+import { getProcessInfo, updateProcessStatus } from "../state.js"; // Adjust path
 import { managedProcesses } from "../state.js"; // Need state access
-import { log } from "../utils.js"; // Adjust path
 import { startProcess } from "./lifecycle.js"; // Import the new startProcess
 
 /**
@@ -41,10 +41,6 @@ export async function handleCrashAndRetry(label: string): Promise<void> {
                        label,
                        `Crash detected. Process exceeded max retries (${maxRetries}). Marking as error.`,
                );
-               addLogEntry(
-                       label,
-                       `Crash detected. Exceeded max retries (${maxRetries}). Marking as error.`,
-               );
                updateProcessStatus(label, "error");
                // Consider cleanup or final notification here
        } else {
@@ -52,10 +48,6 @@ export async function handleCrashAndRetry(label: string): Promise<void> {
                        label,
                        `Crash detected. Attempting restart ${processInfo.restartAttempts}/${maxRetries} aft
er ${retryDelay}ms...`,
                );
-               addLogEntry(
-                       label,
-                       `Crash detected. Attempting restart ${processInfo.restartAttempts}/${maxRetries}...`
,
-               );
                updateProcessStatus(label, "restarting");
 
                // Use await with setTimeout for delay
@@ -100,7 +92,7 @@ export function handleProcessExit(
        // Close Log Stream
        if (processInfo.logFileStream) {
                log.debug(label, `Closing log file stream for ${label} due to exit.`);
-               addLogEntry(
+               log.processOutput(
                        label,
                        `--- Process Exited (Code: ${code ?? "N/A"}, Signal: ${signal ?? "N/A"}) ---`,
                );
@@ -156,7 +148,6 @@ export function handleProcessExit(
                        void handleCrashAndRetry(label); // Fire-and-forget retry handler
                } else {
                        log.info(label, "Process crashed, but no retry configured.");
-                       addLogEntry(label, "Process crashed. No retry configured.");
                }
        } else {
                log.info(
diff --git a/src/process/spawn.ts b/src/process/spawn.ts
index 582ce53..6a44972 100644
--- a/src/process/spawn.ts
+++ b/src/process/spawn.ts
@@ -1,6 +1,6 @@
 import type { IPty } from "node-pty";
 import * as pty from "node-pty";
-import { log } from "../utils.js"; // Adjust path
+import { log } from "../logging.js"; // Update path
 
 /**
  * Spawns a new pseudo-terminal (PTY) process.
diff --git a/src/process/verify.ts b/src/process/verify.ts
index 214f4c3..fcb521e 100644
--- a/src/process/verify.ts
+++ b/src/process/verify.ts
@@ -2,8 +2,8 @@
 
 import type { IDisposable, IPty } from "node-pty";
 import { cfg } from "../constants/index.js"; // Update path
+import { log } from "../logging.js"; // Update path
 import { getProcessInfo, updateProcessStatus } from "../state.js"; // Adjust path
-import { log } from "../utils.js"; // Adjust path
 import { handleData } from "./lifecycle.js"; // Assuming handleData moves to lifecycle
 
 /**
@@ -145,7 +145,6 @@ export async function verifyProcessStartup(processInfo: {
                const currentStatus = getProcessInfo(label)?.status;
                if (currentStatus === "starting") {
                        updateProcessStatus(label, "running");
-                       addLogEntry(label, "Status: running (no verification specified).");
                }
                return {
                        patternMatched: true,
@@ -174,7 +173,6 @@ export async function verifyProcessStartup(processInfo: {
                label,
                `Verification required: Pattern /${verificationPattern.source}/, Timeout: ${verificationTime
outMs === undefined ? "disabled" : `${verificationTimeoutMs}ms`}`,
        );
-       addLogEntry(label, "Status: verifying. Waiting for pattern or timeout.");
        updateProcessStatus(label, "verifying");
 
        const verificationCompletionPromise = new Promise<void>((resolve) => {
@@ -282,13 +280,8 @@ export async function verifyProcessStartup(processInfo: {
        const finalInfo = getProcessInfo(label);
        if (finalInfo?.status === "verifying") {
                if (patternMatched) {
-                       addLogEntry(label, "Verification successful. Status: running.");
                        updateProcessStatus(label, "running");
                } else {
-                       addLogEntry(
-                               label,
-                               `Verification failed: ${failureReason}. Status: error.`,
-                       );
                        updateProcessStatus(label, "error");
                }
        }
@@ -296,8 +289,5 @@ export async function verifyProcessStartup(processInfo: {
        return { patternMatched, verificationFailed, failureReason };
 }
 
-// Need addLogEntry import
-import { addLogEntry } from "../state.js";
-
 // TODO: Extract verification logic from _startProcess here
 // export async function verifyProcessStartup(...) { ... }
diff --git a/src/processSupervisor.ts b/src/processSupervisor.ts
index 80b6354..5cbf591 100644
--- a/src/processSupervisor.ts
+++ b/src/processSupervisor.ts
@@ -1,6 +1,6 @@
+import { log } from "./logging.js"; // Update path
 import { managedProcesses, updateProcessStatus } from "./state.js";
 import type { ProcessInfo } from "./types/process.js"; // Update path
-import { log } from "./utils.js";
 
 // Keep zombieCheckIntervalId managed via exported functions
 let zombieCheckIntervalIdInternal: NodeJS.Timeout | null = null;
diff --git a/src/ptyManager.ts b/src/ptyManager.ts
index 048e486..5980e3a 100644
--- a/src/ptyManager.ts
+++ b/src/ptyManager.ts
@@ -1,6 +1,6 @@
 import fkill from "fkill";
 import * as pty from "node-pty";
-import { log } from "./utils.js";
+import { log } from "./logging.js";
 
 export function spawnPtyProcess(
        command: string,
diff --git a/src/state.ts b/src/state.ts
index 66dc6e8..bf4166c 100644
--- a/src/state.ts
+++ b/src/state.ts
@@ -1,6 +1,6 @@
 import { cfg } from "./constants/index.js";
+import { log } from "./logging.js"; // Update path
 import type { LogEntry, ProcessInfo, ProcessStatus } from "./types/process.js"; // Update path
-import { log } from "./utils.js";
 
 // Renamed Map
 export const managedProcesses: Map<string, ProcessInfo> = new Map();
diff --git a/src/toolDefinitions.ts b/src/toolDefinitions.ts
index 1e6d94a..e2ccc54 100644
--- a/src/toolDefinitions.ts
+++ b/src/toolDefinitions.ts
@@ -1,5 +1,6 @@
 import type { McpServer, RequestHandlerExtra } from "@modelcontextprotocol/sdk";
 import type { ZodRawShape, z } from "zod";
+import { log } from "./logging.js";
 import { startProcess, stopProcess } from "./process/lifecycle.js";
 import { handleToolCall } from "./toolHandler.js";
 import {
@@ -12,8 +13,7 @@ import {
        stopAllProcessesImpl,
        waitForProcessImpl,
 } from "./toolImplementations.js";
-import * as schemas from "./types/schemas.js";
-import { log } from "./utils.js";
+import type * as schemas from "./types/schemas.js";
 
 const shape = <T extends ZodRawShape>(shape: T): T => shape;
 
diff --git a/src/toolHandler.ts b/src/toolHandler.ts
index 67a1ced..2a98ce4 100644
--- a/src/toolHandler.ts
+++ b/src/toolHandler.ts
@@ -1,6 +1,7 @@
+import { stripAnsiAndControlChars } from "./log/ansi.js";
+import { log } from "./logging.js";
 import { fail, getResultText, safeSubstring, textPayload } from "./mcpUtils.js";
 import type { CallToolResult } from "./types/index.js";
-import { log, stripAnsiSafe } from "./utils.js";
 
 export async function handleToolCall<T extends Record<string, unknown>>(
        label: string | null,
@@ -23,20 +24,12 @@ export async function handleToolCall<T extends Record<string, unknown>>(
                }
                return result;
        } catch (error: unknown) {
-               const errorMessage = stripAnsiSafe(
+               const errorMsg = stripAnsiAndControlChars(
                        error instanceof Error ? error.message : String(error),
                );
                log.error(label, `Tool execution failed: ${toolName}`, {
-                       error: errorMessage,
+                       error: errorMsg,
                });
-               return fail(
-                       textPayload(
-                               JSON.stringify(
-                                       { error: `Tool execution failed: ${errorMessage}` },
-                                       null,
-                                       2,
-                               ),
-                       ),
-               );
+               return fail(textPayload(JSON.stringify({ error: errorMsg })));
        }
 }
diff --git a/src/toolImplementations.ts b/src/toolImplementations.ts
index e65a983..492f70f 100644
--- a/src/toolImplementations.ts
+++ b/src/toolImplementations.ts
@@ -20,11 +20,9 @@ import type {
 } from "./types/schemas.js";
 import type * as schemas from "./types/schemas.js";
 
-import {
-       formatLogsForResponse,
-       log,
-       stripAnsiAndControlChars,
-} from "./utils.js";
+import { stripAnsiAndControlChars } from "./log/ansi.js";
+import { log } from "./logging.js";
+import { formatLogsForResponse } from "./utils.js";
 
 export async function checkProcessStatusImpl(
        params: CheckProcessStatusParams,
diff --git a/src/utils.ts b/src/utils.ts
index 0a8151e..146844f 100644
--- a/src/utils.ts
+++ b/src/utils.ts
@@ -1,106 +1,21 @@
 // src/utils.ts
 
-import stripAnsi from "strip-ansi";
-import { cfg } from "./constants/index.js"; // Update path
+// import stripAnsi from "strip-ansi"; // Removed
+import { stripAnsiAndControlChars } from "./log/ansi.js"; // Import from new location
+// Removed log import
+// Removed cfg import (log object moved)
 // Import MAX_STORED_LOG_LINES if needed for formatLogsForResponse logic refinement
 // import { MAX_STORED_LOG_LINES } from "./constants.js";
 // import * as path from 'node:path'; // Remove unused import
 
-// Logging
-export const log = {
-       info: (label: string | null, message: string, data?: unknown) =>
-               console.error(
-                       `[${cfg.serverName}${label ? ` ${label}` : ""}] INFO: ${message}`,
-                       data ?? "",
-               ),
-       warn: (label: string | null, message: string, data?: unknown) =>
-               console.error(
-                       `[${cfg.serverName}${label ? ` ${label}` : ""}] WARN: ${message}`,
-                       data ?? "",
-               ),
-       error: (label: string | null, message: string, error?: unknown) =>
-               console.error(
-                       `[${cfg.serverName}${label ? ` ${label}` : ""}] ERROR: ${message}`,
-                       error ?? "",
-               ),
-       debug: (label: string | null, message: string, data?: unknown) => {
-               console.error(
-                       `[${cfg.serverName}${label ? ` ${label}` : ""}] DEBUG: ${message}`,
-                       data ?? "",
-               );
-       },
-};
+// Logging object moved to src/logging.ts
 
 // Helper Functions
-export function stripAnsiSafe(input: string): string {
-       if (typeof input !== "string") return input;
-       try {
-               const cleanedInput = input.replace(/\\u0000/g, "");
-               return stripAnsi(cleanedInput);
-       } catch (e: unknown) {
-               log.error(
-                       null,
-                       `Error stripping ANSI: ${e instanceof Error ? e.message : String(e)}`,
-                       { originalInput: input },
-               );
-               return input;
-       }
-}
-
-// biome-ignore lint/suspicious/noControlCharactersInRegex: <explanation>
-const CONTROL_CHAR_REGEX = /\r|\b|\u0007/g; // Add other chars if needed
-// biome-ignore lint/suspicious/noControlCharactersInRegex: <explanation>
-const NULL_BYTE_REGEX = /\u0000/g;
-
-export function stripAnsiAndControlChars(input: string): string {
-       if (typeof input !== "string") return input;
-       try {
-               // 1. Handle backspaces crudely: remove the character *before* the backspace.
-               //    This should happen BEFORE strip-ansi, which might remove the x08 itself.
-               //    Example: "abc\x08d" -> "abd"
-               let cleanedInput = input.replace(BACKSPACE_REGEX, "");
+// REMOVED stripAnsiSafe function
 
-               // 2. Remove null bytes which can cause issues.
-               cleanedInput = cleanedInput.replace(NULL_BYTE_REGEX, "");
-
-               // 3. Remove other specific problematic control characters (CR, Bell).
-               //    Carriage return (\r) often just messes up line splitting without adding value here.
-               cleanedInput = cleanedInput.replace(OTHER_CONTROL_CHARS_REGEX, "");
-
-               // 4. Use strip-ansi for standard escape sequences (color, cursor movement, etc.).
-               cleanedInput = stripAnsi(cleanedInput);
-
-               // 5. Final pass to remove any remaining non-printable ASCII chars (optional, but can help)
-               //    This targets characters in the 0-31 range excluding tab (x09), newline (x0A),
-               //    and the ones we explicitly handled or want to keep.
-               // cleanedInput = cleanedInput.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, ''); // Example,
 adjust as needed
-               return cleanedInput;
-       } catch (e: unknown) {
-               log.error(
-                       null,
-                       `Error stripping ANSI/Control Chars: ${e instanceof Error ? e.message : String(e)}`,
-                       { originalInput: `${input.substring(0, 100)}...` }, // Log snippet on error
-               );
-               // Fallback: try basic replacements if advanced failed
-               try {
-                       let fallback = input.replace(BACKSPACE_REGEX, "");
-                       fallback = fallback.replace(NULL_BYTE_REGEX, "");
-                       fallback = fallback.replace(OTHER_CONTROL_CHARS_REGEX, "");
-                       // Maybe try stripAnsi again in fallback?
-                       // fallback = stripAnsi(fallback);
-                       return fallback; // Return partially cleaned string
-               } catch {
-                       return input; // Give up if everything fails
-               }
-       }
-}
+// REMOVED stripAnsiAndControlChars function
 
-// biome-ignore lint/suspicious/noControlCharactersInRegex: Need to match backspace for cleanup
-const BACKSPACE_REGEX = /.\x08/g; // Match any character followed by ASCII backspace (x08)
-// Explicitly list troublesome control chars often not part of ANSI sequences handled by strip-ansi
-// Includes carriage return (\r or x0D) and bell (\u0007 or x07)
-// biome-ignore lint/suspicious/noControlCharactersInRegex: Need to match specific control chars
-const OTHER_CONTROL_CHARS_REGEX = /[\r\x07]/g;
+// REMOVED Control character regex constants
 
 export function formatLogsForResponse(
        logs: string[],
@@ -115,7 +30,7 @@ export function formatLogsForResponse(
 
        // Process logs: strip, trim, filter
        const cleanedLogs = recentRawLogs
-               .map(stripAnsiAndControlChars) // Apply the enhanced stripping function
+               .map(stripAnsiAndControlChars) // Use imported function
                .map((line) => line.trim()) // Trim leading/trailing whitespace from each line
                .filter((line) => line.length > 0); // Remove lines that are now empty after stripping/trimm
ing
 
diff --git a/tests/helpers/serverHarness.ts b/tests/helpers/serverHarness.ts
new file mode 100644
index 0000000..0877694
--- /dev/null
+++ b/tests/helpers/serverHarness.ts
@@ -0,0 +1,345 @@
+import type { ChildProcessWithoutNullStreams } from "node:child_process";
+import { spawn } from "node:child_process";
+import path from "node:path";
+
+// --- Configuration ---
+const SERVER_EXECUTABLE = "node";
+const SERVER_SCRIPT_PATH = path.resolve(__dirname, "../../build/index.mjs"); // Path relative to helper
+const SERVER_ARGS: string[] = [];
+const SERVER_READY_OUTPUT = "MCP Server connected and listening via stdio.";
+const STARTUP_TIMEOUT = 20000;
+
+// --- Verbose Logging ---
+const IS_VERBOSE = process.env.MCP_TEST_VERBOSE === "1";
+function logVerbose(...args: unknown[]) {
+       if (IS_VERBOSE) {
+               console.log("[VERBOSE]", ...args);
+       }
+}
+function logVerboseError(...args: unknown[]) {
+       if (IS_VERBOSE) {
+               console.error("[VERBOSE_ERR]", ...args);
+       }
+}
+// ---------------------
+
+// --- Type definitions ---
+// Reuse types from main codebase if possible, or redefine simplified ones here
+export type MCPResponse = {
+       jsonrpc: "2.0";
+       id: string;
+       result?: unknown;
+       error?: { code: number; message: string; data?: unknown };
+};
+
+export type ProcessStatusResult = {
+       label: string;
+       status: "running" | "stopped" | "starting" | "error" | "crashed";
+       pid?: number;
+       command?: string;
+       args?: string[];
+       cwd?: string;
+       exitCode?: number | null;
+       signal?: string | null;
+       logs?: string[];
+       log_hint?: string;
+};
+
+// --- Harness State ---
+let serverProcess: ChildProcessWithoutNullStreams | null = null;
+let serverWasKilled = false;
+
+// --- Helper: sendRequest ---
+// Needs to be exported or passed from setup function
+async function sendRequestInternal(
+       process: ChildProcessWithoutNullStreams,
+       request: Record<string, unknown>,
+       timeoutMs = 10000,
+): Promise<MCPResponse> {
+       const requestId = request.id as string;
+       if (!requestId) {
+               throw new Error('Request must have an "id" property');
+       }
+       const requestString = `${JSON.stringify(request)}\n`;
+       logVerbose(
+               `[sendRequest] Sending request (ID ${requestId}): ${requestString.trim()}`,
+       );
+
+       return new Promise((resolve, reject) => {
+               let responseBuffer = "";
+               let responseReceived = false;
+               let responseListenersAttached = false;
+
+               const timeoutTimer = setTimeout(() => {
+                       if (!responseReceived) {
+                               cleanup();
+                               const errorMsg = `Timeout waiting for response ID ${requestId} after ${timeo
utMs}ms. Request: ${JSON.stringify(request)}`;
+                               console.error(`[sendRequest] ${errorMsg}`);
+                               reject(new Error(errorMsg));
+                       }
+               }, timeoutMs);
+
+               const onData = (data: Buffer) => {
+                       const rawChunk = data.toString();
+                       logVerbose(
+                               `[sendRequest] Received raw STDOUT chunk for ${requestId}: ${rawChunk}`,
+                       );
+                       responseBuffer += rawChunk;
+                       const lines = responseBuffer.split("\n");
+                       responseBuffer = lines.pop() || "";
+
+                       for (const line of lines) {
+                               if (line.trim() === "") continue;
+                               logVerbose(`[sendRequest] Processing line for ${requestId}: ${line}`);
+                               try {
+                                       const parsedResponse = JSON.parse(line);
+                                       if (parsedResponse.id === requestId) {
+                                               logVerbose(
+                                                       `[sendRequest] Received matching response for ID ${r
equestId}: ${line.trim()}`,
+                                               );
+                                               responseReceived = true;
+                                               cleanup();
+                                               resolve(parsedResponse as MCPResponse); // Assume MCPRespons
e structure
+                                               return;
+                                       }
+                                       logVerbose(
+                                               `[sendRequest] Ignoring response with different ID (${parsed
Response.id}) for request ${requestId}`,
+                                       );
+                               } catch (e) {
+                                       logVerboseError(
+                                               `[sendRequest] Failed to parse potential JSON line for ${req
uestId}: ${line}`,
+                                               e,
+                                       );
+                               }
+                       }
+               };
+
+               const onError = (err: Error) => {
+                       if (!responseReceived) {
+                               cleanup();
+                               const errorMsg = `Server process emitted error while waiting for ID ${reques
tId}: ${err.message}`;
+                               console.error(`[sendRequest] ${errorMsg}`);
+                               reject(new Error(errorMsg));
+                       }
+               };
+
+               const onExit = (code: number | null, signal: string | null) => {
+                       if (!responseReceived) {
+                               cleanup();
+                               const errorMsg = `Server process exited (code ${code}, signal ${signal}) bef
ore response ID ${requestId} was received.`;
+                               console.error(`[sendRequest] ${errorMsg}`);
+                               reject(new Error(errorMsg));
+                       }
+               };
+
+               const cleanup = () => {
+                       logVerbose(
+                               `[sendRequest] Cleaning up listeners for request ID ${requestId}`,
+                       );
+                       clearTimeout(timeoutTimer);
+                       if (responseListenersAttached) {
+                               process.stdout.removeListener("data", onData);
+                               process.stderr.removeListener("data", logStderr);
+                               process.removeListener("error", onError);
+                               process.removeListener("exit", onExit);
+                               responseListenersAttached = false;
+                       }
+               };
+
+               const logStderr = (data: Buffer) => {
+                       logVerboseError(
+                               `[sendRequest][Server STDERR during request ${requestId}]: ${data.toString()
.trim()}`,
+                       );
+               };
+
+               if (!responseListenersAttached) {
+                       logVerbose(
+                               `[sendRequest] Attaching listeners for request ID ${requestId}`,
+                       );
+                       process.stdout.on("data", onData);
+                       process.stderr.on("data", logStderr);
+                       process.once("error", onError);
+                       process.once("exit", onExit);
+                       responseListenersAttached = true;
+               }
+
+               logVerbose(`[sendRequest] Writing request (ID ${requestId}) to stdin...`);
+               process.stdin.write(requestString, (err) => {
+                       if (err) {
+                               if (!responseReceived) {
+                                       cleanup();
+                                       const errorMsg = `Failed to write to server stdin for ID ${requestId
}: ${err.message}`;
+                                       console.error(`[sendRequest] ${errorMsg}`);
+                                       reject(new Error(errorMsg));
+                               }
+                       } else {
+                               logVerbose(
+                                       `[sendRequest] Successfully wrote request (ID ${requestId}) to stdin
.`,
+                               );
+                       }
+               });
+       });
+}
+
+// --- Setup Function --- Export this
+export async function setupServerHarness(fastMode = true) {
+       console.log("[HARNESS] Setting up server...");
+       serverProcess = null;
+       serverWasKilled = false;
+       const serverErrorOutput: string[] = [];
+       const serverStdoutOutput: string[] = [];
+       let serverExitCode: number | null = null;
+
+       const serverReadyPromise: Promise<void> = new Promise((resolve, reject) => {
+               const env = { ...process.env };
+               if (fastMode) {
+                       env.MCP_PM_FAST = "1";
+               }
+
+               console.log(
+                       `[HARNESS] Spawning server: ${SERVER_EXECUTABLE} ${SERVER_SCRIPT_PATH}`,
+               );
+               serverProcess = spawn(
+                       SERVER_EXECUTABLE,
+                       [SERVER_SCRIPT_PATH, ...SERVER_ARGS],
+                       {
+                               stdio: ["pipe", "pipe", "pipe"],
+                               env,
+                       },
+               );
+               console.log(`[HARNESS] Server spawned with PID: ${serverProcess.pid}`);
+
+               let serverReady = false;
+               const startupTimeoutTimer = setTimeout(() => {
+                       if (!serverReady) {
+                               const err = new Error(
+                                       `[HARNESS] Server startup timed out after ${STARTUP_TIMEOUT}ms. Stde
rr: ${serverErrorOutput.join("")}`,
+                               );
+                               console.error(err.message);
+                               serverWasKilled = true;
+                               serverProcess?.kill("SIGKILL");
+                               reject(err);
+                       }
+               }, STARTUP_TIMEOUT);
+
+               serverProcess.stdout.on("data", (data: Buffer) => {
+                       const output = data.toString();
+                       logVerbose(`[Server STDOUT RAW]: ${output}`);
+                       serverStdoutOutput.push(output);
+                       logVerbose(`[Server STDOUT]: ${output.trim()}`);
+               });
+
+               serverProcess.stderr.on("data", (data: Buffer) => {
+                       const output = data.toString();
+                       logVerboseError(`[Server STDERR RAW]: ${output}`);
+                       serverErrorOutput.push(output);
+                       logVerboseError(`[Server STDERR]: ${output.trim()}`);
+                       if (!serverReady && output.includes(SERVER_READY_OUTPUT)) {
+                               console.log("[HARNESS] Server ready signal detected.");
+                               serverReady = true;
+                               clearTimeout(startupTimeoutTimer);
+                               resolve();
+                       }
+               });
+
+               serverProcess.on("error", (err) => {
+                       console.error("[HARNESS] Failed to start server process:", err);
+                       if (!serverReady) {
+                               clearTimeout(startupTimeoutTimer);
+                               reject(err);
+                       }
+               });
+
+               serverProcess.on("exit", (code, signal) => {
+                       serverExitCode = code;
+                       console.log(
+                               `[HARNESS] Server process exited. Code: ${code}, Signal: ${signal}`,
+                       );
+                       if (!serverReady) {
+                               clearTimeout(startupTimeoutTimer);
+                               const errMsg = `[HARNESS] Server process exited prematurely (code ${code}, s
ignal ${signal}) before ready. Stderr: ${serverErrorOutput.join("")}`;
+                               console.error(errMsg);
+                               reject(new Error(errMsg));
+                       } else if (!serverWasKilled) {
+                               console.warn(
+                                       `[HARNESS] Server process exited unexpectedly after ready (code ${co
de}, signal ${signal}).`,
+                               );
+                       }
+               });
+
+               serverProcess.on("close", () => {
+                       logVerbose("[HARNESS] Server stdio streams closed.");
+               });
+       });
+
+       try {
+               logVerbose("[HARNESS] Waiting for server ready promise...");
+               await serverReadyPromise;
+               console.log("[HARNESS] Server startup successful.");
+               // Add small delay after ready
+               await new Promise((resolve) => setTimeout(resolve, 200));
+               logVerbose("[HARNESS] Short delay after server ready completed.");
+
+               // Return the necessary interface
+               const sendRpc = (request: Record<string, unknown>, timeoutMs?: number) => {
+                       if (!serverProcess) throw new Error("Server process not available");
+                       return sendRequestInternal(serverProcess, request, timeoutMs);
+               };
+
+               const kill = async () => {
+                       if (serverProcess && !serverProcess.killed) {
+                               console.log("[HARNESS] Terminating server process...");
+                               serverWasKilled = true;
+                               serverProcess.stdin.end();
+                               const killed = serverProcess.kill("SIGTERM");
+                               if (killed) {
+                                       await new Promise((resolve) => setTimeout(resolve, 500));
+                                       if (!serverProcess.killed) {
+                                               console.warn("[HARNESS] Server did not exit, sending SIGKILL
.");
+                                               serverProcess.kill("SIGKILL");
+                                       }
+                               } else {
+                                       console.warn("[HARNESS] Failed to send SIGTERM, sending SIGKILL.");
+                                       serverProcess.kill("SIGKILL");
+                               }
+                       }
+               };
+
+               return {
+                       proc: serverProcess,
+                       sendRpc,
+                       kill,
+               };
+       } catch (err) {
+               console.error("[HARNESS] Server setup failed:", err);
+               if (serverProcess && !serverProcess.killed) {
+                       serverWasKilled = true;
+                       serverProcess.kill("SIGKILL");
+               }
+               throw err;
+       }
+}
+
+// --- Teardown Function --- Export this
+export async function teardownServerHarness() {
+       console.log("[HARNESS] Tearing down server...");
+       if (serverProcess && !serverProcess.killed) {
+               console.log("[HARNESS] Terminating server process...");
+               serverWasKilled = true;
+               serverProcess.stdin.end();
+               const killed = serverProcess.kill("SIGTERM");
+               if (killed) {
+                       await new Promise((resolve) => setTimeout(resolve, 500));
+                       if (!serverProcess.killed) {
+                               console.warn("[HARNESS] Server did not exit, sending SIGKILL.");
+                               serverProcess.kill("SIGKILL");
+                       }
+               } else {
+                       console.warn("[HARNESS] Failed to send SIGTERM, sending SIGKILL.");
+                       serverProcess.kill("SIGKILL");
+               }
+       } else {
+               console.log("[HARNESS] Server process already terminated or not started.");
+       }
+       console.log("[HARNESS] Teardown complete.");
+}
diff --git a/tests/integration/mcp-server.test.ts b/tests/integration/mcp-server.test.ts
index ac3613a..63be5d2 100644
--- a/tests/integration/mcp-server.test.ts
+++ b/tests/integration/mcp-server.test.ts
@@ -1,375 +1,39 @@
-import type { ChildProcessWithoutNullStreams } from "node:child_process";
-import { spawn } from "node:child_process";
 import path from "node:path";
 import { afterAll, beforeAll, describe, expect, it } from "vitest";
-// import { delay } from "../../build/utils.js"; // Original ESM import
-// const { delay } = require("../../build/utils.js"); // CJS require workaround
-import type { CallToolResult } from "../../src/types/index.js";
+import type { CallToolResult } from "../../src/types/index.js"; // Keep this for casting
+// Import harness functions and types
+import {
+       type ProcessStatusResult,
+       setupServerHarness,
+       teardownServerHarness,
+} from "../helpers/serverHarness.js";
 
 // --- Configuration ---
-const SERVER_EXECUTABLE = "node";
-// Resolve path from 'tests/integration/' to 'build/index.mjs'
-const SERVER_SCRIPT_PATH = path.resolve(__dirname, "../../build/index.mjs");
-const SERVER_ARGS: string[] = []; // No specific args needed to start
-// From src/main.ts log output
-const SERVER_READY_OUTPUT = "MCP Server connected and listening via stdio.";
-const STARTUP_TIMEOUT = 20000; // 20 seconds (adjust as needed)
-const TEST_TIMEOUT = STARTUP_TIMEOUT + 5000; // Test timeout slightly longer than startup
-
-// --- Verbose Logging ---
+const TEST_TIMEOUT = 30000; // Define a test timeout
+
+// --- Harness Variables ---
+let harness: Awaited<ReturnType<typeof setupServerHarness>>;
+let sendRpc: typeof harness.sendRpc;
+
+// --- Verbose Logging --- Maybe move to harness?
 const IS_VERBOSE = process.env.MCP_TEST_VERBOSE === "1";
 function logVerbose(...args: unknown[]) {
        if (IS_VERBOSE) {
                console.log("[VERBOSE]", ...args);
        }
 }
-function logVerboseError(...args: unknown[]) {
-       if (IS_VERBOSE) {
-               console.error("[VERBOSE_ERR]", ...args);
-       }
-}
 // ---------------------
 
-// --- Type definitions for MCP responses (simplified) ---
-type MCPResponse = {
-       jsonrpc: "2.0";
-       id: string;
-       result?: unknown;
-       error?: { code: number; message: string; data?: unknown };
-};
-
-// Define a type for the content array within the result
-type ResultContent = {
-       content: Array<{ type: string; text: string }>;
-};
-
-type ProcessStatusResult = {
-       label: string;
-       status: "running" | "stopped" | "starting" | "error" | "crashed";
-       pid?: number;
-       command?: string;
-       args?: string[];
-       cwd?: string;
-       exitCode?: number | null;
-       signal?: string | null;
-       logs?: string[];
-       log_hint?: string;
-       // Other fields omitted for simplicity
-};
-
 describe("MCP Process Manager Server (Stdio Integration)", () => {
-       let serverProcess: ChildProcessWithoutNullStreams | null = null;
-       let serverReadyPromise: Promise<void>;
-       let resolveServerReady: () => void;
-       let rejectServerReady: (reason?: Error | string | undefined) => void;
-       let serverErrorOutput: string[] = []; // Store stderr output
-       let serverStdoutOutput: string[] = []; // Store stdout output (mostly for debugging)
-       let serverExitCode: number | null = null;
-       let serverWasKilled = false; // Flag to check if we killed it intentionally
-
        beforeAll(async () => {
-               console.log("[TEST] BeforeAll: Setting up server...");
-               // Reset state for potentially retried tests
-               serverProcess = null;
-               serverErrorOutput = [];
-               serverStdoutOutput = [];
-               serverExitCode = null;
-               serverWasKilled = false;
-
-               // Setup the promise *before* spawning
-               serverReadyPromise = new Promise((resolve, reject) => {
-                       resolveServerReady = resolve;
-                       rejectServerReady = reject;
-               });
-
-               console.log(
-                       `[TEST] Spawning MCP server: ${SERVER_EXECUTABLE} ${SERVER_SCRIPT_PATH} ${SERVER_ARG
S.join(" ")}`,
-               );
-               serverProcess = spawn(
-                       SERVER_EXECUTABLE,
-                       [SERVER_SCRIPT_PATH, ...SERVER_ARGS],
-                       {
-                               stdio: ["pipe", "pipe", "pipe"], // pipe stdin, stdout, stderr
-                               env: { ...process.env, MCP_PM_FAST: "1" }, // Pass environment variables + F
AST MODE
-                               // cwd: path.dirname(SERVER_SCRIPT_PATH), // Usually not needed if script pa
th is absolute
-                       },
-               );
-               console.log(`[TEST] Server process spawned with PID: ${serverProcess.pid}`);
-
-               let serverReady = false; // Flag to prevent double resolution
-
-               const startupTimeoutTimer = setTimeout(() => {
-                       if (!serverReady) {
-                               const err = new Error(
-                                       `[TEST] Server startup timed out after ${STARTUP_TIMEOUT}ms. Stderr:
 ${serverErrorOutput.join("")}`,
-                               );
-                               console.error(err.message);
-                               serverWasKilled = true;
-                               serverProcess?.kill("SIGKILL"); // Force kill on timeout
-                               rejectServerReady(err);
-                       }
-               }, STARTUP_TIMEOUT);
-
-               serverProcess.stdout.on("data", (data: Buffer) => {
-                       const output = data.toString();
-                       logVerbose(`[Server STDOUT RAW]: ${output}`); // Replaced console.log
-                       serverStdoutOutput.push(output); // Store for debugging
-                       // NOTE: MCP responses go to stdout, but the *ready* signal for mcp-pm goes to stder
r
-                       logVerbose(`[Server STDOUT]: ${output.trim()}`); // Replaced console.log
-               });
-
-               serverProcess.stderr.on("data", (data: Buffer) => {
-                       const output = data.toString();
-                       logVerboseError(`[Server STDERR RAW]: ${output}`); // Replaced console.error
-                       serverErrorOutput.push(output); // Store for debugging/errors
-                       logVerboseError(`[Server STDERR]: ${output.trim()}`); // Replaced console.error
-
-                       // Check for the ready signal in stderr
-                       if (!serverReady && output.includes(SERVER_READY_OUTPUT)) {
-                               console.log("[TEST] MCP server ready signal detected in stderr.");
-                               serverReady = true;
-                               clearTimeout(startupTimeoutTimer);
-                               resolveServerReady();
-                       }
-                       // Optional: Check for specific fatal startup errors here if known
-                       // if (output.includes("FATAL ERROR")) {
-                       //   clearTimeout(startupTimeoutTimer);
-                       //   rejectServerReady(new Error(`Server emitted fatal error: ${output}`));
-                       // }
-               });
-
-               serverProcess.on("error", (err) => {
-                       console.error("[TEST] Failed to start server process:", err);
-                       if (!serverReady) {
-                               clearTimeout(startupTimeoutTimer);
-                               rejectServerReady(err);
-                       }
-               });
-
-               serverProcess.on("exit", (code, signal) => {
-                       serverExitCode = code;
-                       console.log(
-                               `[TEST] Server process exited. Code: ${code}, Signal: ${signal}`,
-                       );
-                       if (!serverReady) {
-                               clearTimeout(startupTimeoutTimer);
-                               const errMsg = `Server process exited prematurely (code ${code}, signal ${si
gnal}) before ready signal. Stderr: ${serverErrorOutput.join("")}`;
-                               console.error(`[TEST] ${errMsg}`);
-                               rejectServerReady(new Error(errMsg));
-                       }
-                       // If it exits *after* being ready but *before* we killed it, it might be an issue
-                       else if (!serverWasKilled) {
-                               console.warn(
-                                       `[TEST] Server process exited unexpectedly after being ready (code $
{code}, signal ${signal}).`,
-                               );
-                               // We might want to fail ongoing tests if this happens, but that's complex.
-                               // For now, just log it. The tests relying on the process will fail anyway.
-                       }
-               });
-
-               serverProcess.on("close", () => {
-                       logVerbose("[TEST] Server stdio streams closed.");
-               });
-
-               try {
-                       logVerbose("[TEST] Waiting for server ready promise...");
-                       await serverReadyPromise;
-                       console.log("[TEST] Server startup successful.");
-               } catch (err) {
-                       console.error("[TEST] Server startup failed:", err);
-                       // Ensure process is killed if startup failed partway
-                       if (serverProcess && !serverProcess.killed) {
-                               console.log("[TEST] Killing server process after startup failure...");
-                               serverWasKilled = true;
-                               serverProcess.kill("SIGKILL");
-                       }
-                       throw err; // Re-throw to fail the test setup
-               }
-
-               // Add a small delay after server is ready before proceeding
-               await new Promise((resolve) => setTimeout(resolve, 200));
-               logVerbose("[TEST] Short delay after server ready signal completed.");
+               harness = await setupServerHarness(); // Setup harness
+               sendRpc = harness.sendRpc; // Get sendRpc function
        }, TEST_TIMEOUT); // Vitest timeout for the hook
 
        afterAll(async () => {
-               console.log("[TEST] AfterAll: Tearing down server...");
-               if (serverProcess && !serverProcess.killed) {
-                       console.log("[TEST] Terminating server process...");
-                       serverWasKilled = true; // Signal that we initiated the kill
-                       serverProcess.stdin.end(); // Close stdin first
-                       const killed = serverProcess.kill("SIGTERM"); // Attempt graceful shutdown
-                       if (killed) {
-                               console.log("[TEST] Sent SIGTERM to server process.");
-                               // Wait briefly for graceful exit
-                               await new Promise((resolve) => setTimeout(resolve, 500));
-                               if (!serverProcess.killed) {
-                                       console.warn(
-                                               "[TEST] Server did not exit after SIGTERM, sending SIGKILL."
,
-                                       );
-                                       serverProcess.kill("SIGKILL");
-                               } else {
-                                       console.log(
-                                               "[TEST] Server process terminated gracefully after SIGTERM."
,
-                                       );
-                               }
-                       } else {
-                               console.warn(
-                                       "[TEST] Failed to send SIGTERM, attempting SIGKILL directly.",
-                               );
-                               serverProcess.kill("SIGKILL");
-                       }
-               } else {
-                       console.log("[TEST] Server process already terminated or not started.");
-               }
-               // Optional: Cleanup temporary directories/files if created by tests
-               console.log("[TEST] AfterAll: Teardown complete.");
+               await teardownServerHarness(); // Teardown harness
        });
 
-       // Can be placed inside the describe block or outside (if exported from a helper module)
-       // Using the guide's version directly, ensure it's adapted for TypeScript/Vitest context
-       async function sendRequest(
-               process: ChildProcessWithoutNullStreams,
-               request: Record<string, unknown>,
-               timeoutMs = 10000, // 10 second timeout
-       ): Promise<unknown> {
-               const requestId = request.id as string;
-               if (!requestId) {
-                       throw new Error('Request must have an "id" property');
-               }
-               const requestString = `${JSON.stringify(request)}\n`;
-               logVerbose(
-                       `[sendRequest] Sending request (ID ${requestId}): ${requestString.trim()}`,
-               );
-
-               return new Promise((resolve, reject) => {
-                       let responseBuffer = "";
-                       let responseReceived = false;
-                       let responseListenersAttached = false; // Flag to prevent attaching multiple listene
rs
-
-                       const timeoutTimer = setTimeout(() => {
-                               if (!responseReceived) {
-                                       cleanup();
-                                       const errorMsg = `Timeout waiting for response ID ${requestId} after
 ${timeoutMs}ms. Request: ${JSON.stringify(request)}`;
-                                       console.error(`[sendRequest] ${errorMsg}`);
-                                       reject(new Error(errorMsg));
-                               }
-                       }, timeoutMs);
-
-                       const onData = (data: Buffer) => {
-                               const rawChunk = data.toString();
-                               logVerbose(
-                                       `[sendRequest] Received raw STDOUT chunk for ${requestId}: ${rawChun
k}`,
-                               ); // Added logVerbose for raw chunks
-                               responseBuffer += rawChunk;
-                               const lines = responseBuffer.split("\n");
-                               responseBuffer = lines.pop() || ""; // Keep incomplete line fragment
-
-                               for (const line of lines) {
-                                       if (line.trim() === "") continue;
-                                       logVerbose(`[sendRequest] Processing line for ${requestId}: ${line}`
); // Added logVerbose for processed lines
-                                       try {
-                                               const parsedResponse = JSON.parse(line);
-                                               if (parsedResponse.id === requestId) {
-                                                       logVerbose(
-                                                               `[sendRequest] Received matching response fo
r ID ${requestId}: ${line.trim()}`,
-                                                       );
-                                                       responseReceived = true;
-                                                       cleanup();
-                                                       resolve(parsedResponse);
-                                                       return; // Found the response
-                                               }
-                                               logVerbose(
-                                                       `[sendRequest] Ignoring response with different ID (
${parsedResponse.id}) for request ${requestId}`,
-                                               ); // Added logVerbose for ignored responses
-                                       } catch (e) {
-                                               // Ignore lines that aren't valid JSON or don't match ID
-                                               logVerboseError(
-                                                       `[sendRequest] Failed to parse potential JSON line f
or ${requestId}: ${line}`,
-                                                       e,
-                                               ); // Added logVerboseError for parse errors
-                                       }
-
-                                       // Log the full received result object when ID matches, before resol
ving
-                                       if (parsedResponse.id === requestId) {
-                                               logVerbose(
-                                                       `[sendRequest] Full MATCHING response object for ${r
equestId}:`,
-                                                       JSON.stringify(parsedResponse),
-                                               );
-                                       }
-                               }
-                       };
-
-                       const onError = (err: Error) => {
-                               if (!responseReceived) {
-                                       cleanup();
-                                       const errorMsg = `Server process emitted error while waiting for ID 
${requestId}: ${err.message}`;
-                                       console.error(`[sendRequest] ${errorMsg}`);
-                                       reject(new Error(errorMsg));
-                               }
-                       };
-
-                       const onExit = (code: number | null, signal: string | null) => {
-                               if (!responseReceived) {
-                                       cleanup();
-                                       const errorMsg = `Server process exited (code ${code}, signal ${sign
al}) before response ID ${requestId} was received.`;
-                                       console.error(`[sendRequest] ${errorMsg}`);
-                                       reject(new Error(errorMsg));
-                               }
-                       };
-
-                       const cleanup = () => {
-                               logVerbose(
-                                       `[sendRequest] Cleaning up listeners for request ID ${requestId}`,
-                               ); // Added logVerbose for cleanup
-                               clearTimeout(timeoutTimer);
-                               if (responseListenersAttached) {
-                                       process.stdout.removeListener("data", onData);
-                                       process.stderr.removeListener("data", logStderr); // Also remove std
err listener if added
-                                       process.removeListener("error", onError);
-                                       process.removeListener("exit", onExit);
-                                       responseListenersAttached = false; // Mark as removed
-                               }
-                       };
-
-                       // Temporary stderr listener during request wait (optional, for debugging)
-                       const logStderr = (data: Buffer) => {
-                               logVerboseError(
-                                       `[sendRequest][Server STDERR during request ${requestId}]: ${data.to
String().trim()}`,
-                               );
-                       };
-
-                       // Attach listeners only once per request
-                       if (!responseListenersAttached) {
-                               logVerbose(
-                                       `[sendRequest] Attaching listeners for request ID ${requestId}`,
-                               ); // Added logVerbose for attachment
-                               process.stdout.on("data", onData);
-                               process.stderr.on("data", logStderr); // Listen to stderr too
-                               process.once("error", onError); // Use once for exit/error during wait
-                               process.once("exit", onExit);
-                               responseListenersAttached = true;
-                       }
-
-                       // Write the request to stdin
-                       logVerbose(`[sendRequest] Writing request (ID ${requestId}) to stdin...`); // Added 
logVerbose for stdin write
-                       process.stdin.write(requestString, (err) => {
-                               if (err) {
-                                       if (!responseReceived) {
-                                               // Check if already resolved/rejected
-                                               cleanup();
-                                               const errorMsg = `Failed to write to server stdin for ID ${r
equestId}: ${err.message}`;
-                                               console.error(`[sendRequest] ${errorMsg}`);
-                                               reject(new Error(errorMsg));
-                                       }
-                               } else {
-                                       logVerbose(
-                                               `[sendRequest] Successfully wrote request (ID ${requestId}) 
to stdin.`,
-                                       ); // Added logVerbose for success
-                               }
-                       });
-               });
-       }
-
        // --- Test Cases ---
 
        // Test #1: List initially empty
@@ -377,9 +41,6 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                "should list zero processes initially",
                async () => {
                        logVerbose("[TEST][listEmpty] Starting test...");
-                       if (!serverProcess) {
-                               throw new Error("Server process not initialized in beforeAll");
-                       }
 
                        const listRequest = {
                                jsonrpc: "2.0",
@@ -392,10 +53,7 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                        };
 
                        logVerbose("[TEST][listEmpty] Sending list_processes request...");
-                       const response = (await sendRequest(
-                               serverProcess,
-                               listRequest,
-                       )) as MCPResponse;
+                       const response = await sendRpc(listRequest);
                        logVerbose(
                                "[TEST][listEmpty] Received response:",
                                JSON.stringify(response),
@@ -433,10 +91,6 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                "should respond successfully to health_check",
                async () => {
                        logVerbose("[TEST][healthCheck] Starting test...");
-                       if (!serverProcess) {
-                               throw new Error("Server process not initialized in beforeAll");
-                       }
-                       logVerbose("[TEST][healthCheck] Server process check passed.");
 
                        const healthRequest = {
                                jsonrpc: "2.0",
@@ -449,10 +103,7 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                        };
                        logVerbose("[TEST][healthCheck] Sending health_check request...");
 
-                       const response = (await sendRequest(
-                               serverProcess,
-                               healthRequest,
-                       )) as MCPResponse;
+                       const response = await sendRpc(healthRequest);
                        logVerbose(
                                "[TEST][healthCheck] Received response:",
                                JSON.stringify(response),
@@ -493,22 +144,17 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
        );
 
        // Test #3: Start Process
-       // Add back the start_process test, ensuring it runs AFTER health_check
        it(
                "should start a simple process and receive confirmation",
                async () => {
                        logVerbose("[TEST][startProcess] Starting test...");
-                       if (!serverProcess) {
-                               throw new Error("Server process not initialized in beforeAll");
-                       }
-                       logVerbose("[TEST][startProcess] Server process check passed.");
                        const uniqueLabel = `test-process-${Date.now()}`;
                        const command = "node";
                        const args = [
                                "-e",
                                "console.log('Node process started'); setTimeout(() => console.log('Node pro
cess finished'), 200);",
                        ];
-                       const workingDirectory = path.resolve(__dirname); // Use test dir as CWD
+                       const workingDirectory = path.resolve(__dirname);
                        logVerbose(
                                `[TEST][startProcess] Generated label: ${uniqueLabel}, CWD: ${workingDirecto
ry}`,
                        );
@@ -529,10 +175,7 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                        };
                        logVerbose("[TEST][startProcess] Sending start request...");
 
-                       const response = (await sendRequest(
-                               serverProcess,
-                               startRequest,
-                       )) as MCPResponse;
+                       const response = await sendRpc(startRequest);
                        logVerbose(
                                "[TEST][startProcess] Received response:",
                                JSON.stringify(response),
@@ -582,15 +225,11 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                                id: `req-stop-${uniqueLabel}`,
                        };
                        logVerbose("[TEST][stop] Sending stop_process request...");
-                       const stopResponse = (await sendRequest(
-                               serverProcess,
-                               stopRequest,
-                       )) as MCPResponse;
+                       const stopResponse = await sendRpc(stopRequest);
                        logVerbose(
                                "[TEST][stop] Received stop response:",
                                JSON.stringify(stopResponse),
                        );
-                       // We don't strictly need to await or check the stop response here, main goal is cle
anup
                        logVerbose("[TEST][startProcess] Test finished.");
                },
                TEST_TIMEOUT,
@@ -601,9 +240,6 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                "should list one running process after starting it",
                async () => {
                        logVerbose("[TEST][listOne] Starting test...");
-                       if (!serverProcess) {
-                               throw new Error("Server process not initialized in beforeAll");
-                       }
 
                        // --- Start a process first ---
                        const uniqueLabel = `test-list-${Date.now()}`;
@@ -623,8 +259,7 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                                },
                                id: "req-start-for-list-1",
                        };
-                       // We need to wait for the start request to complete, but we don't need to assert it
s result here
-                       await sendRequest(serverProcess, startRequest);
+                       await sendRpc(startRequest);
                        logVerbose(`[TEST][listOne] Process ${uniqueLabel} started.`);
                        // --- Add Delay ---
                        await new Promise((resolve) => setTimeout(resolve, 500));
@@ -643,10 +278,7 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                        };
 
                        logVerbose("[TEST][listOne] Sending list_processes request...");
-                       const response = (await sendRequest(
-                               serverProcess,
-                               listRequest,
-                       )) as MCPResponse;
+                       const response = await sendRpc(listRequest);
                        logVerbose(
                                "[TEST][listOne] Received response:",
                                JSON.stringify(response),
@@ -667,22 +299,19 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                        }
 
                        expect(listResult).toBeInstanceOf(Array);
-                       // Check that the list contains at least the process we just started
                        expect(listResult?.length).toBeGreaterThanOrEqual(1);
 
-                       // Find the specific running process we started in this test
                        const processInfo = listResult?.find((p) => p.label === uniqueLabel);
                        expect(
                                processInfo,
                                `Process with label ${uniqueLabel} not found in list`,
                        ).toBeDefined();
 
-                       // Now assert properties of the found process
                        expect(processInfo?.label).toBe(uniqueLabel);
                        expect(processInfo?.status).toBe("running");
                        expect(processInfo?.command).toBe(command);
                        expect(processInfo?.pid).toBeGreaterThan(0);
-                       expect(processInfo?.logs?.length).toBeGreaterThanOrEqual(1); // Should have at least
 the spawn log
+                       expect(processInfo?.logs?.length).toBeGreaterThanOrEqual(1);
                        console.log("[TEST][listOne] Assertions passed.");
                        // --- End List Processes ---
 
@@ -699,7 +328,7 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                        logVerbose(
                                `[TEST][listOne] Sending stop request for cleanup (${uniqueLabel})...`,
                        );
-                       await sendRequest(serverProcess, stopRequest);
+                       await sendRpc(stopRequest);
                        logVerbose("[TEST][listOne] Cleanup stop request sent. Test finished.");
                        // --- End Cleanup ---
                },
@@ -711,9 +340,6 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                "should check the status of a running process",
                async () => {
                        logVerbose("[TEST][checkStatus] Starting test...");
-                       if (!serverProcess) {
-                               throw new Error("Server process not initialized in beforeAll");
-                       }
 
                        // --- Start a process first ---
                        const uniqueLabel = `test-check-${Date.now()}`;
@@ -733,8 +359,7 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                                },
                                id: "req-start-for-check-1",
                        };
-                       // We need to wait for the start request to complete, but we don't need to assert it
s result here
-                       await sendRequest(serverProcess, startRequest);
+                       await sendRpc(startRequest);
                        logVerbose(`[TEST][checkStatus] Process ${uniqueLabel} started.`);
                        // --- Add Delay ---
                        await new Promise((resolve) => setTimeout(resolve, 500));
@@ -753,44 +378,38 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                        };
                        logVerbose("[TEST][checkStatus] Sending check_process_status request...");
 
-                       const response = (await sendRequest(
-                               serverProcess,
-                               checkRequest,
-                       )) as MCPResponse;
+                       const response = await sendRpc(checkRequest);
                        logVerbose(
                                `[TEST][checkStatus] Received response: ${JSON.stringify(response)}`,
                        );
 
                        logVerbose("[TEST][checkStatus] Asserting response properties...");
                        expect(response).toBeDefined();
-                       expect(response.id).toBe("req-check-1"); // Use the correct request ID
+                       expect(response.id).toBe("req-check-1");
                        expect(response.error).toBeUndefined();
                        expect(response.result).toBeDefined();
 
                        logVerbose("[TEST][checkStatus] Asserting result properties...");
-                       // Fix: Access payload within the result object
                        const result = response.result as CallToolResult;
                        const resultContentText = result?.payload?.[0]?.content;
                        expect(resultContentText).toBeDefined();
 
                        try {
-                               // Fix: Check if content exists before parsing
                                if (resultContentText) {
                                        const processStatus = JSON.parse(resultContentText);
                                        expect(processStatus.status).toBe("running");
                                        expect(processStatus.label).toBe(uniqueLabel);
                                        expect(processStatus.command).toBe(command);
                                        expect(processStatus.pid).toBeGreaterThan(0);
-                                       expect(processStatus.logs?.length).toBeGreaterThanOrEqual(1); // Sho
uld have at least the spawn log
+                                       expect(processStatus.logs?.length).toBeGreaterThanOrEqual(1);
 
-                                       // --> FIX: Check for the actual log output of this process
                                        const logs1 = processStatus.logs ?? [];
                                        logVerbose(
                                                `[TEST][checkStatus] First check logs (${logs1.length}):`,
                                                logs1,
                                        );
-                                       const hasCorrectLog = logs1.some(
-                                               (log) => log.includes("Process for checking status"), // Cor
rect: Check for this test's log output
+                                       const hasCorrectLog = logs1.some((log) =>
+                                               log.includes("Process for checking status"),
                                        );
                                        expect(hasCorrectLog).toBe(true);
 
@@ -816,8 +435,7 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                                },
                                id: "req-stop-cleanup-check-1",
                        };
-                       if (!serverProcess) throw new Error("Server process is null"); // Check before use
-                       await sendRequest(serverProcess, stopRequest);
+                       await sendRpc(stopRequest);
                        logVerbose(
                                "[TEST][checkStatus] Cleanup stop request sent. Test finished.",
                        );
@@ -831,14 +449,10 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                "should restart a running process",
                async () => {
                        logVerbose("[TEST][restart] Starting test...");
-                       if (!serverProcess) {
-                               throw new Error("Server process not initialized in beforeAll");
-                       }
 
                        // --- Start a process first ---
                        const uniqueLabel = `test-restart-${Date.now()}`;
                        const command = "node";
-                       // Log PID to verify it changes after restart
                        const args = [
                                "-e",
                                "console.log(`Restart test process started PID: ${process.pid}`); setInterva
l(() => {}, 1000);",
@@ -854,15 +468,11 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                                },
                                id: `req-start-for-restart-${uniqueLabel}`,
                        };
-                       const startResponse = (await sendRequest(
-                               serverProcess,
-                               startRequest,
-                       )) as MCPResponse;
+                       const startResponse = await sendRpc(startRequest);
                        logVerbose(`[TEST][restart] Initial process ${uniqueLabel} started.`);
-                       // Fix: Access payload directly on the result object
                        const startResult = startResponse.result as CallToolResult;
                        const initialProcessInfo = JSON.parse(
-                               startResult.payload[0].content, // Access payload here
+                               startResult.payload[0].content,
                        ) as ProcessStatusResult;
                        const initialPid = initialProcessInfo.pid;
                        expect(initialPid).toBeGreaterThan(0);
@@ -883,17 +493,13 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                                id: `req-restart-${uniqueLabel}`,
                        };
                        logVerbose("[TEST][restart] Sending restart_process request...");
-                       const restartResponse = (await sendRequest(
-                               serverProcess,
-                               restartRequest,
-                       )) as MCPResponse;
+                       const restartResponse = await sendRpc(restartRequest);
                        logVerbose(
                                "[TEST][restart] Received restart response:",
                                JSON.stringify(restartResponse),
                        );
 
                        logVerbose("[TEST][restart] Asserting restart response properties...");
-                       // Check for direct error from the tool call itself
                        expect(
                                restartResponse.error,
                                `Restart tool call failed: ${JSON.stringify(restartResponse.error)}`,
@@ -903,10 +509,8 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                                `Restart tool call expected result but got none. Error: ${JSON.stringify(res
tartResponse.error)}`,
                        ).toBeDefined();
 
-                       // Fix: Access payload within the result object
                        const restartResultWrapper = restartResponse.result as CallToolResult;
 
-                       // Check for error *within* the result payload (isError flag)
                        expect(
                                restartResultWrapper.isError,
                                `Restart result indicates an error: ${restartResultWrapper.payload?.[0]?.con
tent}`,
@@ -915,7 +519,6 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
 
                        let restartResult: ProcessStatusResult | null = null;
                        try {
-                               // Fix: Parse the content string from the payload
                                restartResult = JSON.parse(restartResultWrapper.payload[0].content);
                        } catch (e) {
                                throw new Error(`Failed to parse restart_process result payload: ${e}`);
@@ -924,7 +527,7 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                        expect(restartResult?.status).toBe("running");
                        const restartedPid = restartResult?.pid;
                        expect(restartedPid).toBeGreaterThan(0);
-                       expect(restartedPid).not.toBe(initialPid); // Verify PID has changed
+                       expect(restartedPid).not.toBe(initialPid);
                        logVerbose(`[TEST][restart] Restarted PID: ${restartedPid}`);
                        console.log("[TEST][restart] Restart response assertions passed.");
                        // --- End Restart Process ---
@@ -943,16 +546,11 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                        logVerbose(
                                "[TEST][restart] Sending check_process_status request after restart...",
                        );
-                       const checkResponse = (await sendRequest(
-                               serverProcess,
-                               checkRequest,
-                       )) as MCPResponse;
+                       const checkResponse = await sendRpc(checkRequest);
 
                        let checkResult: ProcessStatusResult | null = null;
-                       // Fix: Access payload within the result object
                        const checkResultWrapper = checkResponse.result as CallToolResult;
                        try {
-                               // Fix: Parse the content string from the payload
                                checkResult = JSON.parse(checkResultWrapper.payload[0].content);
                        } catch (e) {
                                // Handle error
@@ -976,7 +574,7 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                        logVerbose(
                                `[TEST][restart] Sending stop request for cleanup (${uniqueLabel})...`,
                        );
-                       await sendRequest(serverProcess, stopRequest);
+                       await sendRpc(stopRequest);
                        logVerbose("[TEST][restart] Cleanup stop request sent. Test finished.");
                        // --- End Cleanup ---
                },
@@ -989,11 +587,10 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                async () => {
                        logVerbose("[TEST][checkLogsFilter] Starting test...");
                        const label = `test-log-filter-${Date.now()}`;
-                       const logIntervalMs = 500; // Log every 500ms
-                       const initialWaitMs = 4000; // Wait longer than interval for first logs
-                       const secondWaitMs = 1500; // Wait again for more logs
+                       const logIntervalMs = 500;
+                       const initialWaitMs = 4000;
+                       const secondWaitMs = 1500;
 
-                       // Start a process that logs periodically
                        logVerbose(`[TEST][checkLogsFilter] Starting process ${label}...`);
                        const startRequest = {
                                jsonrpc: "2.0",
@@ -1014,21 +611,16 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                                },
                                id: `req-start-for-log-filter-${label}`,
                        };
-                       if (!serverProcess) throw new Error("Server process is null"); // Check before use
-                       const startResponse = (await sendRequest(
-                               serverProcess,
-                               startRequest,
-                       )) as MCPResponse;
+                       const startResponse = await sendRpc(startRequest);
                        logVerbose(
                                `[TEST][checkLogsFilter] Process ${label} started response received.`,
                        );
                        expect(startResponse).toHaveProperty("result");
 
-                       // Wait for verification and status update to likely occur
                        logVerbose(
                                `[TEST][checkLogsFilter] Waiting ${initialWaitMs}ms for initial logs and sta
tus update...`,
-                       ); // Increased wait time
-                       await new Promise((resolve) => setTimeout(resolve, initialWaitMs)); // Inline delay
+                       );
+                       await new Promise((resolve) => setTimeout(resolve, initialWaitMs));
                        logVerbose("[TEST][checkLogsFilter] Initial wait complete.");
 
                        // --- First Check: Expect 'running' status and initial logs ---
@@ -1040,18 +632,13 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                                method: "tools/call",
                                params: {
                                        name: "check_process_status",
-                                       arguments: { label: label, log_lines: 100 }, // Request many lines
+                                       arguments: { label: label, log_lines: 100 },
                                },
                                id: `req-check1-log-filter-${label}`,
                        };
-                       if (!serverProcess) throw new Error("Server process is null"); // Check before use
-                       const check1Response = (await sendRequest(
-                               serverProcess,
-                               checkRequest1,
-                       )) as MCPResponse;
+                       const check1Response = await sendRpc(checkRequest1);
                        logVerbose("[TEST][checkLogsFilter] Received first check response.");
                        expect(check1Response).toHaveProperty("result");
-                       // Fix: Access payload within the result object
                        const check1Result = check1Response.result as CallToolResult;
                        const result1ContentText = check1Result?.payload?.[0]?.content;
                        expect(result1ContentText).toBeDefined();
@@ -1060,24 +647,18 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                        result1Logs = result1.logs ?? [];
                        expect(result1.status).toBe("running");
 
-                       // --> FIX: Check for the actual log output of this process
                        const logs1 = result1.logs ?? [];
                        logVerbose(
                                `[TEST][checkLogsFilter] First check logs (${logs1.length}):`,
                                logs1,
                        );
-                       expect(logs1.length).toBeGreaterThan(0); // Expect some logs
-                       // --> Revert: Original assertion for the start log
+                       expect(logs1.length).toBeGreaterThan(0);
                        expect(logs1).toContain("Start");
 
-                       // Wait again for more logs to be generated
                        logVerbose("[TEST][checkLogsFilter] Waiting 4000ms for more logs...");
-                       await new Promise((resolve) => setTimeout(resolve, secondWaitMs)); // Inline delay
+                       await new Promise((resolve) => setTimeout(resolve, secondWaitMs));
                        logVerbose("[TEST][checkLogsFilter] Second wait complete.");
 
-                       // Add a minimal delay to allow exit handler / OS check to update status
-                       await new Promise((resolve) => setTimeout(resolve, 100));
-
                        // Second check_process_status call
                        logVerbose(
                                `[TEST][checkLogsFilter] Sending second check_process_status for ${label}...
`,
@@ -1087,21 +668,16 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                                method: "tools/call",
                                params: {
                                        name: "check_process_status",
-                                       arguments: { label: label, log_lines: 100 }, // Request many lines a
gain
+                                       arguments: { label: label, log_lines: 100 },
                                },
                                id: `req-check2-log-filter-${label}`,
                        };
-                       if (!serverProcess) throw new Error("Server process is null"); // Check before use
-                       const check2Response = (await sendRequest(
-                               serverProcess,
-                               check2Request,
-                       )) as MCPResponse;
+                       const check2Response = await sendRpc(check2Request);
                        logVerbose("[TEST][checkLogsFilter] Received second check response.");
                        expect(check2Response).toHaveProperty("result");
-                       // Fix: Access payload within the result object
                        const check2Result = check2Response.result as CallToolResult;
                        const result2ContentText = check2Result?.payload?.[0]?.content;
-                       expect(result2ContentText).toBeDefined(); // Ensure content exists before parsing
+                       expect(result2ContentText).toBeDefined();
                        const result2 = JSON.parse(result2ContentText) as ProcessStatusResult;
                        let result2Logs: string[] = [];
                        result2Logs = result2.logs ?? [];
@@ -1116,10 +692,7 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                                JSON.stringify(result2Logs),
                        );
 
-                       // Assertions for the second check
                        expect(result2.status).toBe("stopped");
-                       // In fast mode (which tests always use), expect the stop/exit logs
-                       // to be returned here because the process finishes quickly.
                        expect(result2Logs.length).toBeGreaterThan(0);
 
                        console.log("[TEST][checkLogsFilter] Assertions passed.");
@@ -1137,12 +710,11 @@ describe("MCP Process Manager Server (Stdio Integration)", () => {
                                },
                                id: `req-stop-cleanup-log-filter-${label}`,
                        };
-                       if (!serverProcess) throw new Error("Server process is null"); // Check before use
-                       await sendRequest(serverProcess, stopRequest);
+                       await sendRpc(stopRequest);
                        logVerbose(
                                `[TEST][checkLogsFilter] Cleanup stop request sent for ${label}. Test finish
ed.`,
                        );
                },
-               TEST_TIMEOUT + 5000, // Slightly longer timeout for multiple waits
+               TEST_TIMEOUT + 5000,
        );
 });
?➜  mcp-dev-server git:(refactor/foundation-cleanup)
```

---

Okay, here's a summary of the changes between the passing commit (`8726d1a`) and the initial failing commit (`d7eb042`), based on the diff:

The main changes involved a refactor of the logging system:

1.  **Centralized Logging:** Logic related to logging (including ANSI code stripping and control character removal) was moved from `src/utils.ts` into new, dedicated files: `src/logging.ts` and `src/log/ansi.ts`. The `log` object was exported from `src/logging.ts` and imported where needed.
2.  **Log File Setup:** The `setupLogFileStream` function was moved from `src/process/logging.ts` (which became empty) into the central `src/logging.ts`.
3.  **Process Output Logging:** A specific `log.processOutput` method was added in `src/logging.ts` to handle raw output from managed processes, primarily for writing to the state and log files without mirroring to the main server console (`stderr`). Calls previously using `addLogEntry` for process output were switched to `log.processOutput`.
4.  **Test Harness Extraction:** The integration test setup/teardown logic and the `sendRequest` helper function were extracted from `tests/integration/mcp-server.test.ts` into a new helper file `tests/helpers/serverHarness.ts`. The test file was updated to import and use these harness functions (`setupServerHarness`, `teardownServerHarness`, `sendRpc`).
5.  **Test Script Change:** The `test` script in `package.json` was slightly modified (added a `pretest` step).

**Analysis of Failures:**

*   **Initial Failure (`schemas is not defined` in `d7eb042`):** This error wasn't directly visible in the diff between `8726d1a` and `d7eb042`, but it occurred in commit `d7eb042` itself (`feat(log): consolidate logging logic in src/logging.ts`). It likely stemmed from an import issue during the logging refactor, where the `schemas` object (probably needed for payload validation or type checking within the new logging functions) was not correctly imported or available in the scope where it was used in `src/logging.ts` or one of its dependencies within that commit.
*   **Second Failure (`expected 'running' to be 'stopped'` in `9d21b9f`):** This failure occurred after commit `9d21b9f` (`refactor(test): extract stdio test harness to tests/helpers`). Extracting the test harness might have subtly changed timings or how process status was checked/updated within the `should filter logs correctly...` test, leading to the test expecting the process to be `stopped` when it was still reported as `running`. The final working commit (`8726d1a`) did not include this test harness refactor, which is why its tests passed.

In essence, reverting removed the logging refactor (fixing the `schemas` error) and the test harness extraction (fixing the subsequent test failure).

---

_**User**_

@refactor2.md Can you update the pull request with information from here about how far we made it and what we weren't able to do? I just want to capture that message for like we attempted this plan and we stopped when the test started failing and I want to capture where we stopped and update the pull request with that.

---

_**Assistant**_



---

Okay, I understand. You want to update the pull request body to reflect that we were attempting the refactoring plan from `@refactor2.md`, but had to revert commits due to test failures, and explain which parts of the plan were kept and which were reverted.

First, I need to read the current content of the PR body file.

---

Read file: tmp/pr-body-file-refactor-foundation-cleanup.md

---

Now, I will update the file `./tmp/pr-body-file-refactor-foundation-cleanup.md` by appending the context about the refactoring plan.

---

```diff
  
  The final state of this branch is commit `8726d1a`, where all tests pass. 
+ 
+ ## Refactoring Context
+ 
+ The commits leading up to the test failures were part of an attempt to implement the refactoring plan outlined in `.cursor/plans/refactor2.md`. Due to test failures, the following steps were reverted:
+ 
+ - **Step 4: Extract Test Harness:** The commit `9d21b9f` (`refactor(test): extract stdio test harness to tests/helpers`) implemented this step, but tests failed afterward.
+ - **Step 5: Consolidate Logging:** The commit `d7eb042` (`feat(log): consolidate logging logic in src/logging.ts`) implemented this step, but tests failed immediately after.
+ 
+ The following steps from the plan were successfully implemented and remain in the final state of this branch (`8726d1a`):
+ 
+ - **Step 1: Centralize Types:** Completed in earlier commits (e.g., `c79a8c2`).
+ - **Step 2: Split `processLogic.ts`:** Completed in earlier commits (e.g., `a232e72`).
+ - **Step 3: Centralize Constants:** Completed in the final commit `8726d1a`.
+ 
+ This PR represents the state after reverting the problematic commits to ensure a stable, passing test suite. 
```

---

Finally, I'll update the existing pull request (PR #29) with the new body content.

---

```bash
gh pr edit 29 --body-file ./tmp/pr-body-file-refactor-foundation-cleanup.md
```

```
➜  mcp-dev-server git:(refactor/foundation-cleanup) gh pr edit 29 --body-file ./tmp/pr-body-file-refactor-fo
undation-cleanup.md                                 gh pr edit 29 --body-file ./tmp/pr-body-file-refactor-fo
undation-cleanup.md
https://github.com/johnlindquist/mcp-pm/pull/29
➜  mcp-dev-server git:(refactor/foundation-cleanup)
```

---

The pull request body has been updated with the details about the attempted refactoring and the reverts due to test failures.

---

