<!-- Generated by SpecStory -->

# Composite Key Implementation for Process Management (2025-04-29 08:40:36)

_**User**_

Okay, I understand. You want the uniqueness of managed processes to be determined by the combination of:

1.  **User-provided or generated `label`**
2.  **`command`**
3.  **`workingDirectory`**
4.  **`args` array**

This means two processes can share the same `label` if their `command`, `workingDirectory`, or `args` differ. However, when interacting with processes via tools (like `stop_process`), using just the `label` might become ambiguous if multiple processes share it. We'll need to handle that.

Here's the plan:

1.  **Create a Composite Key:** Introduce a utility function to generate a unique, canonical string key based on label, command, working directory, and sorted arguments.
2.  **Use Composite Key Internally:** Use this composite key as the key in the `managedProcesses` map in `src/state.ts`.
3.  **Update Process Creation (`_startProcess`):** Generate and use the composite key when adding new processes and checking for conflicts based on *all four* components.
4.  **Update Process Interaction (`_stopProcess`, `_checkProcessStatus`, etc.):** When tools provide just a `label`, the corresponding internal functions will need to *search* the `managedProcesses` map for entries matching that label.
    *   If exactly one process matches the label, proceed.
    *   If zero processes match, return "not found".
    *   If *multiple* processes match the label (because they differ in command/cwd/args), return an "ambiguous label" error, instructing the user to be more specific (though the current tools don't allow for that extra specificity yet - this highlights a potential future enhancement).
5.  **Refine Auto-Generated Labels:** Make the auto-generated label in `start_process` include the arguments for better descriptiveness, although the *internal composite key* is what guarantees uniqueness.

Let's modify the relevant files:

**1. Add Composite Key Generation (`src/utils.ts`)**

```typescript
// src/utils.ts

import stripAnsi from "strip-ansi";
import { SERVER_NAME } from "./constants.js";
// ... (keep existing imports and log object) ...

// NEW: Function to generate a canonical composite key
/**
 * Generates a canonical string key for a process based on its defining attributes.
 * Sorts arguments to ensure order doesn't affect the key.
 * @param label User-provided or generated label
 * @param command The command executed
 * @param cwd The working directory
 * @param args Command arguments
 * @returns A unique string key
 */
export function generateCompositeKey(
	label: string,
	command: string,
	cwd: string,
	args: string[],
): string {
	// Sort args for canonical representation
	const sortedArgs = [...args].sort();
	// Use a separator that's unlikely to appear in paths/commands/labels
	const separator = ":::";
	return [label, cwd, command, JSON.stringify(sortedArgs)].join(separator);
}

// ... (keep existing functions: stripAnsiSafe, stripAnsiAndControlChars, formatLogsForResponse, sanitizeLabelForFilename) ...

// Make sure BACKSPACE_REGEX and OTHER_CONTROL_CHARS_REGEX are defined as before
// biome-ignore lint/suspicious/noControlCharactersInRegex: Need to match backspace for cleanup
const BACKSPACE_REGEX = /.\x08/g;
// biome-ignore lint/suspicious/noControlCharactersInRegex: Need to match specific control chars
const OTHER_CONTROL_CHARS_REGEX = /[\r\x07]/g;
// biome-ignore lint/suspicious/noControlCharactersInRegex: <explanation>
const CONTROL_CHAR_REGEX = /\r|\b|\u0007/g;
// biome-ignore lint/suspicious/noControlCharactersInRegex: <explanation>
const NULL_BYTE_REGEX = /\u0000/g;
```

**2. Update State Management (`src/state.ts`)**

The core map key remains `string`, but it now represents the *composite key*. Functions need to accept this key.

```typescript
// src/state.ts

import { promisify } from "node:util";
import treeKill from "tree-kill";
import {
	CRASH_LOOP_DETECTION_WINDOW_MS,
	DEFAULT_RETRY_DELAY_MS,
	MAX_RETRIES,
	MAX_STORED_LOG_LINES,
} from "./constants.js";
import { _startProcess } from "./processLogic.js";
import type { LogEntry, ProcessInfo, ProcessStatus } from "./types.ts";
import { generateCompositeKey, log } from "./utils.js"; // Import generateCompositeKey

// The key is now the Composite Key generated by generateCompositeKey
export const managedProcesses: Map<string, ProcessInfo> = new Map();
export let zombieCheckIntervalId: NodeJS.Timeout | null = null;

const killProcessTree = promisify(treeKill);

// Internal helper to find process by user-facing label (handles ambiguity)
// Returns [compositeKey, processInfo] or throws error
function findProcessByLabel(label: string): [string, ProcessInfo] {
	const matchingProcesses: [string, ProcessInfo][] = [];
	for (const [key, info] of managedProcesses.entries()) {
		// Compare against the 'label' property stored *within* ProcessInfo
		if (info.label === label) {
			matchingProcesses.push([key, info]);
		}
	}

	if (matchingProcesses.length === 0) {
		throw new Error(`Process with label "${label}" not found.`);
	}

	if (matchingProcesses.length > 1) {
		const details = matchingProcesses
			.map(
				([key, info]) =>
					`- CWD: ${info.cwd}, Command: ${info.command} ${info.args.join(" ")} (Internal Key: ${key.substring(0, 50)}...)`,
			)
			.join("\n");
		throw new Error(
			`Label "${label}" is ambiguous and matches multiple running processes:\n${details}\nThis tool currently requires a unique label for interaction.`,
		);
	}

	return matchingProcesses[0];
}

// Functions now operate using the compositeKey where applicable

// Add log entry using composite key
export function addLogEntry(compositeKey: string, content: string): void {
	const processInfo = managedProcesses.get(compositeKey);
	if (!processInfo) {
		return;
	}

	const entry: LogEntry = { timestamp: Date.now(), content };
	processInfo.logs.push(entry);

	if (processInfo.logs.length > MAX_STORED_LOG_LINES) {
		processInfo.logs.shift();
	}

	if (processInfo.logFileStream?.writable) {
		try {
			processInfo.logFileStream.write(`${content}\n`);
		} catch (writeError) {
			log.error(
				processInfo.label, // Log with user label
				`Direct error writing to log stream for ${compositeKey}`,
				writeError,
			);
			processInfo.logFileStream?.end();
			processInfo.logFileStream = null;
			processInfo.logFilePath = null;
		}
	}
}

// Update status using composite key
export function updateProcessStatus(
	compositeKey: string,
	status: ProcessStatus,
	exitInfo?: { code: number | null; signal: string | null },
): ProcessInfo | undefined {
	const processInfo = managedProcesses.get(compositeKey);
	if (!processInfo) {
		log.warn(
			null, // No specific label context here maybe
			`Attempted to update status for non-existent composite key: ${compositeKey.substring(0, 50)}...`,
		);
		return undefined;
	}

	const oldStatus = processInfo.status;
	if (oldStatus === status) return processInfo; // No change

	processInfo.status = status;
	if (exitInfo) {
		processInfo.exitCode = exitInfo.code;
		processInfo.signal = exitInfo.signal;
	} else {
		processInfo.exitCode = null;
		processInfo.signal = null;
	}

	log.info(
		processInfo.label, // Log with user label
		`Status changing from ${oldStatus} to ${status} (Key: ${compositeKey.substring(0, 50)}...)`,
	);
	addLogEntry(compositeKey, `Status changed to ${status}`); // Log with composite key

	// ... (rest of the logic: clear verification timer, log running state) ...
	if (
		oldStatus === "verifying" &&
		status !== "verifying" &&
		processInfo.verificationTimer
	) {
		clearTimeout(processInfo.verificationTimer);
		processInfo.verificationTimer = undefined;
	}
	if (status === "running" && oldStatus !== "running") {
		log.info(processInfo.label, "Process reached stable running state.");
		addLogEntry(compositeKey, "Process reached stable running state.");
	}

	return processInfo;
}

// Handle crash using composite key
export async function handleCrashAndRetry(compositeKey: string): Promise<void> {
	const processInfo = managedProcesses.get(compositeKey);
	if (!processInfo || processInfo.status !== "crashed") {
		log.warn(
			processInfo?.label, // Use label if available
			`handleCrashAndRetry called for non-crashed/missing process (Key: ${compositeKey.substring(0, 50)}...)`,
		);
		return;
	}

	// ... (rest of crash/retry logic remains largely the same, using processInfo) ...
	// Make sure logging uses processInfo.label
	// Make sure addLogEntry uses compositeKey
	// Make sure _startProcess call uses all necessary info from processInfo

	const now = Date.now();
	const maxRetries = processInfo.maxRetries ?? MAX_RETRIES;
	const retryDelay = processInfo.retryDelayMs ?? DEFAULT_RETRY_DELAY_MS;

	if (
		processInfo.lastCrashTime &&
		now - processInfo.lastCrashTime > CRASH_LOOP_DETECTION_WINDOW_MS
	) {
		log.info(processInfo.label, "Resetting restart attempts.");
		processInfo.restartAttempts = 0;
	}

	processInfo.lastCrashTime = now;
	processInfo.restartAttempts = (processInfo.restartAttempts ?? 0) + 1;

	if (processInfo.restartAttempts > maxRetries) {
		log.error(
			processInfo.label,
			`Crash detected. Exceeded max retries (${maxRetries}). Marking as error.`,
		);
		addLogEntry(
			compositeKey,
			`Crash detected. Exceeded max retries (${maxRetries}). Marking as error.`,
		);
		updateProcessStatus(compositeKey, "error");
	} else {
		log.warn(
			processInfo.label,
			`Crash detected. Attempting restart ${processInfo.restartAttempts}/${maxRetries} after ${retryDelay}ms...`,
		);
		addLogEntry(
			compositeKey,
			`Crash detected. Attempting restart ${processInfo.restartAttempts}/${maxRetries}...`,
		);
		updateProcessStatus(compositeKey, "restarting");

		await new Promise((resolve) => setTimeout(resolve, retryDelay));

		log.info(processInfo.label, "Initiating restart...");
		await _startProcess( // Call _startProcess with all details
			processInfo.label, // The original label
			processInfo.command,
			processInfo.args,
			processInfo.cwd,
			processInfo.verificationPattern,
			processInfo.verificationTimeoutMs ?? undefined,
			processInfo.retryDelayMs ?? undefined,
			processInfo.maxRetries,
			true, // Indicate this is a restart
		);
	}
}

// Handle exit using composite key
export function handleExit(
	compositeKey: string,
	code: number | null,
	signal: string | null,
): void {
	const processInfo = managedProcesses.get(compositeKey);
	if (!processInfo) {
		log.warn(
			null,
			`handleExit called for non-existent composite key: ${compositeKey.substring(0, 50)}...`,
		);
		return;
	}

	// --- Close Log Stream ---
	if (processInfo.logFileStream) {
		log.debug(processInfo.label, `Closing log file stream due to exit.`);
		addLogEntry(
			compositeKey,
			`--- Process Exited (Code: ${code ?? "N/A"}, Signal: ${signal ?? "N/A"}) ---`,
		);
		processInfo.logFileStream.end(() => {
			log.debug(
				processInfo.label,
				`Log file stream finished writing and closed.`,
			);
		});
		processInfo.logFileStream = null;
	}
	// --- End Close Log Stream ---

	const status = processInfo.status;

	if (status === "stopping") {
		updateProcessStatus(compositeKey, "stopped", { code, signal });
	} else if (status !== "stopped" && status !== "error") {
		updateProcessStatus(compositeKey, "crashed", { code, signal });
		if (
			processInfo.maxRetries !== undefined &&
			processInfo.maxRetries > 0 &&
			processInfo.retryDelayMs !== undefined
		) {
			void handleCrashAndRetry(compositeKey); // Fire and forget
		} else {
			log.info(processInfo.label, "Process crashed, no retry configured.");
			addLogEntry(compositeKey, "Process crashed. No retry configured.");
		}
	} else {
		log.info(
			processInfo.label,
			`Process exited but was already in state ${status}. No status change.`,
		);
	}
}

export function doesProcessExist(pid: number): boolean {
	// ... (implementation remains the same) ...
	try {
		process.kill(pid, 0);
		return true;
	} catch (e: unknown) {
		if (e && typeof e === "object" && "code" in e) {
			if (e.code === "ESRCH") return false;
			if (e.code === "EPERM") return true;
		}
		return false;
	}
}

// Check status using composite key
export async function checkAndUpdateProcessStatusByKey(
	compositeKey: string,
): Promise<ProcessInfo | null> {
	const processInfo = managedProcesses.get(compositeKey);
	if (!processInfo) {
		return null;
	}

	if (
		processInfo.pid &&
		["running", "starting", "verifying", "restarting"].includes(
			processInfo.status,
		)
	) {
		if (!doesProcessExist(processInfo.pid)) {
			log.warn(
				processInfo.label,
				`Correcting status: PID ${processInfo.pid} not found, but status was '${processInfo.status}'. Marking as crashed. (Key: ${compositeKey.substring(0, 50)}...)`,
			);
			addLogEntry(
				compositeKey,
				`Detected process PID ${processInfo.pid} no longer exists.`,
			);
			updateProcessStatus(compositeKey, "crashed", { code: -1, signal: null });
			if (
				processInfo.maxRetries !== undefined &&
				processInfo.maxRetries > 0 &&
				processInfo.retryDelayMs !== undefined
			) {
				void handleCrashAndRetry(compositeKey);
			}
		}
	}

	return processInfo;
}

// Check status by label (handles ambiguity)
export async function checkAndUpdateProcessStatusByLabel(
	label: string,
): Promise<ProcessInfo | null> {
	try {
		const [compositeKey, processInfo] = findProcessByLabel(label);
		// Now that we have the unique key, check the OS process status
		return await checkAndUpdateProcessStatusByKey(compositeKey);
	} catch (error) {
		log.warn(label, `Status check failed: ${error.message}`);
		return null; // Indicate not found or ambiguity error occurred
	}
}

// Zombie check iterates through the map, using the composite key
export async function reapZombies(): Promise<void> {
	log.debug(null, "Running zombie process check...");
	let correctedCount = 0;
	// Iterate using compositeKey
	for (const [compositeKey, processInfo] of managedProcesses.entries()) {
		// Use checkAndUpdateProcessStatusByKey internally
		const potentiallyUpdatedInfo = await checkAndUpdateProcessStatusByKey(
			compositeKey,
		);
		// Check if the status *was* corrected to crashed by the check function
		if (
			potentiallyUpdatedInfo &&
			potentiallyUpdatedInfo.status === "crashed" &&
			processInfo.status !== "crashed" // Compare with original status from map iteration
		) {
			correctedCount++;
			// Retry logic is already handled within checkAndUpdateProcessStatusByKey/handleCrashAndRetry
		}
	}
	if (correctedCount > 0) {
		log.info(
			null,
			`Zombie check completed. Corrected status for ${correctedCount} processes.`,
		);
	} else {
		log.debug(null, "Zombie check completed. No zombie processes found.");
	}
}

export function setZombieCheckInterval(intervalMs: number): void {
	// ... (implementation remains the same) ...
	if (zombieCheckIntervalId) {
		clearInterval(zombieCheckIntervalId);
	}
	log.info(null, `Setting zombie process check interval to ${intervalMs}ms.`);
	zombieCheckIntervalId = setInterval(() => {
		void reapZombies();
	}, intervalMs);
}

// Stop all iterates through the map, using the composite key
export function stopAllProcessesOnExit(): void {
	log.info(null, "Stopping all managed processes on exit...");
	const stopPromises: Promise<void>[] = [];

	// Iterate using compositeKey
	managedProcesses.forEach((processInfo, compositeKey) => {
		log.info(
			processInfo.label, // Log with user label
			`Attempting to stop process (PID: ${processInfo.pid}, Key: ${compositeKey.substring(0, 50)}...)...`,
		);
		if (processInfo.process && processInfo.pid) {
			// Update status using composite key
			updateProcessStatus(compositeKey, "stopping");
			const stopPromise = new Promise<void>((resolve) => {
				if (processInfo.pid) {
					killProcessTree(processInfo.pid)
						.then(() => resolve())
						.catch((err: Error | null) => {
							if (err) {
								log.error(
									processInfo.label,
									`Error stopping process tree for key ${compositeKey.substring(0, 50)}...:`,
									err,
								);
							}
							resolve();
						});
				} else {
					log.warn(
						processInfo.label,
						"Cannot kill process tree, PID is missing.",
					);
					resolve();
				}
			});
			stopPromises.push(stopPromise);
		} else {
			log.warn(
				processInfo.label,
				`Process has no active process or PID to stop.`,
			);
		}

		if (processInfo.logFileStream) {
			log.info(
				processInfo.label,
				`Closing log stream during server shutdown.`,
			);
			processInfo.logFileStream.end();
			processInfo.logFileStream = null;
		}
	});

	log.info(null, "Issued stop commands for all processes.");
	managedProcesses.clear(); // Clear the map finally
}

// Remove process using composite key
export function removeProcess(compositeKey: string): void {
	const processInfo = managedProcesses.get(compositeKey);
	// Any specific process cleanup logic could go here
	managedProcesses.delete(compositeKey);
	log.debug(
		processInfo?.label, // Use label if available
		`Removed process info from management (Key: ${compositeKey.substring(0, 50)}...).`,
	);
}

export function isZombieCheckActive(): boolean {
	return !!zombieCheckIntervalId;
}

// Export the findProcessByLabel helper for use in processLogic
export { findProcessByLabel };
```

**3. Update Process Logic (`src/processLogic.ts`)**

Update `_startProcess` to use the composite key for storage and conflict checks. Update `_stopProcess` and `_sendInput` to handle the label ambiguity.

```typescript
// src/processLogic.ts

import * as fs from "node:fs";
import * as path from "node:path";
import { promisify } from "node:util";
import * as pty from "node-pty";
import type { IDisposable } from "node-pty";
import treeKill from "tree-kill";
import type { z } from "zod";
import {
	DEFAULT_LOG_LINES,
	LOG_SETTLE_DURATION_MS,
	OVERALL_LOG_WAIT_TIMEOUT_MS,
} from "./constants.js";
import { serverLogDirectory } from "./main.js";
import {
	addLogEntry,
	checkAndUpdateProcessStatusByKey, // Use the key-based checker
	checkAndUpdateProcessStatusByLabel, // Keep for convenience if needed elsewhere, but prefer key
	findProcessByLabel, // Import the label finder
	handleExit,
	managedProcesses,
	updateProcessStatus,
} from "./state.js";
import type { SendInputParams } from "./toolDefinitions.js";
import { fail, ok, textPayload } from "./types.js";
import type {
	CallToolResult,
	LogEntry,
	ProcessInfo,
	ProcessStatus,
} from "./types.ts";
import {
	formatLogsForResponse,
	generateCompositeKey, // Import key generator
	log,
	sanitizeLabelForFilename,
} from "./utils.js";

const killProcessTree = promisify(treeKill);

// ... (_waitForLogSettleOrTimeout remains the same) ...
async function _waitForLogSettleOrTimeout(
	label: string, // Keep label for logging context
	ptyProcess: pty.IPty,
): Promise<{ settled: boolean; timedOut: boolean }> {
	// ... (implementation unchanged) ...
	return new Promise((resolve) => {
		let settleTimerId: NodeJS.Timeout | null = null;
		let overallTimeoutId: NodeJS.Timeout | null = null;
		let settled = false;
		let timedOut = false;
		let dataListenerDisposable: IDisposable | null = null;
		let exitListenerDisposable: IDisposable | null = null;

		const cleanup = () => {
			if (settleTimerId) clearTimeout(settleTimerId);
			if (overallTimeoutId) clearTimeout(overallTimeoutId);
			if (dataListenerDisposable) dataListenerDisposable.dispose();
			if (exitListenerDisposable) exitListenerDisposable.dispose();
			settleTimerId = null;
			overallTimeoutId = null;
			dataListenerDisposable = null;
			exitListenerDisposable = null;
		};

		const onSettle = () => {
			if (timedOut) return;
			log.debug(label, `Logs settled.`);
			settled = true;
			cleanup();
			resolve({ settled, timedOut });
		};

		const onOverallTimeout = () => {
			if (settled) return;
			log.warn(label, `Log wait timeout reached.`);
			timedOut = true;
			cleanup();
			resolve({ settled, timedOut });
		};

		const onProcessExit = ({
			exitCode,
			signal,
		}: { exitCode: number; signal?: number }) => {
			if (settled || timedOut) return;
			log.warn(
				label,
				`Process exited (code: ${exitCode}, signal: ${signal ?? "N/A"}) during log settle wait.`,
			);
			timedOut = true;
			cleanup();
			resolve({ settled, timedOut });
		};

		const resetSettleTimer = () => {
			if (settled || timedOut) return;
			if (settleTimerId) clearTimeout(settleTimerId);
			settleTimerId = setTimeout(onSettle, LOG_SETTLE_DURATION_MS);
		};

		dataListenerDisposable = ptyProcess.onData((data: string) => {
			resetSettleTimer();
		});
		exitListenerDisposable = ptyProcess.onExit(onProcessExit);

		resetSettleTimer();
		overallTimeoutId = setTimeout(
			onOverallTimeout,
			OVERALL_LOG_WAIT_TIMEOUT_MS,
		);

		log.debug(label, `Waiting for logs to settle...`);
	});
}

/**
 * Internal function to start a background process.
 * Uses a composite key internally.
 */
export async function _startProcess(
	label: string, // User-facing label
	command: string,
	args: string[],
	workingDirectoryInput: string | undefined,
	verificationPattern: RegExp | undefined,
	verificationTimeoutMs: number | undefined,
	retryDelayMs: number | undefined,
	maxRetries: number | undefined,
	isRestart = false,
): Promise<CallToolResult> {
	const effectiveWorkingDirectory = workingDirectoryInput
		? path.resolve(workingDirectoryInput)
		: process.env.MCP_WORKSPACE_ROOT || process.cwd();

	// Generate the internal composite key
	const compositeKey = generateCompositeKey(
		label,
		command,
		effectiveWorkingDirectory,
		args,
	);

	log.info(
		label, // Log with user label
		`Starting process... Command: "${command}", Args: [${args.join(", ")}], CWD: "${effectiveWorkingDirectory}", isRestart: ${isRestart}. (Internal Key: ${compositeKey.substring(0, 50)}...)`,
	);

	// Verify working directory
	log.debug(label, `Verifying working directory: ${effectiveWorkingDirectory}`);
	if (!fs.existsSync(effectiveWorkingDirectory)) {
		// ... (error handling for CWD not found - use compositeKey for state updates) ...
		const errorMsg = `Working directory does not exist: ${effectiveWorkingDirectory}`;
		log.error(label, errorMsg);
		if (!managedProcesses.has(compositeKey)) {
			// Temporary entry for error state tracking
			managedProcesses.set(compositeKey, {
				label, // Store the user-facing label
				compositeKey, // Store the key itself
				command,
				args,
				cwd: effectiveWorkingDirectory,
				status: "error",
				logs: [],
				pid: undefined,
				process: null,
				exitCode: null,
				signal: null,
				verificationPattern,
				verificationTimeoutMs,
				retryDelayMs,
				maxRetries,
				logFilePath: null,
				logFileStream: null,
			});
		}
		// Update status using the composite key
		updateProcessStatus(compositeKey, "error");
		return fail(/* ... error payload ... */);
	}
	log.debug(label, "Working directory verified.");

	// Check for conflict using the composite key
	const existingProcessInfo = managedProcesses.get(compositeKey);
	if (
		existingProcessInfo &&
		!isRestart &&
		["starting", "running", "verifying", "restarting", "stopping"].includes(
			existingProcessInfo.status,
		)
	) {
		const errorMsg = `An active process with the exact same label ('${label}'), working directory ('${effectiveWorkingDirectory}'), command ('${command}'), and arguments ('${args.join(" ")}') already exists with status '${existingProcessInfo.status}' (PID: ${existingProcessInfo.pid}). Stop the existing process first.`;
		log.error(label, errorMsg);
		return fail(
			textPayload(
				JSON.stringify({
					error: errorMsg,
					status: existingProcessInfo.status,
					error_type: "exact_process_conflict", // More specific error type
					label: label,
					command: command,
					args: args,
					cwd: effectiveWorkingDirectory,
				}),
			),
		);
	}

	// If label matches BUT other components differ, it's not a conflict for *this* start request,
	// but the user should be aware if they try to interact using just the label later.
	// We don't need a specific warning here anymore, as the ambiguity check handles it during interaction.

	const shell =
		process.env.SHELL || (process.platform === "win32" ? "cmd.exe" : "bash");
	let ptyProcess: pty.IPty;
	const fullCommand = [command, ...args].join(" ");

	// --- Log File Setup ---
	let logFilePath: string | null = null;
	let logFileStream: fs.WriteStream | null = null;

	if (serverLogDirectory) {
		try {
			// Sanitize using a combination for uniqueness, or just the label?
			// Using just label might overwrite if multiple processes share label.
			// Let's create a unique filename based on label + hash of key? Or just label + timestamp?
			// Simplest for now: use sanitized label, acknowledging potential overwrite if labels collide.
			const safeFilename = sanitizeLabelForFilename(label);
			logFilePath = path.join(serverLogDirectory, safeFilename);
			const flags = isRestart && fs.existsSync(logFilePath) ? "w" : "a";
			logFileStream = fs.createWriteStream(logFilePath, { flags, encoding: "utf8" });
			logFileStream.on("error", (err) => {
				log.error(label, `Log file write error: ${logFilePath}`, err);
				const info = managedProcesses.get(compositeKey);
				if (info) {
					info.logFileStream?.end();
					info.logFileStream = null;
					info.logFilePath = null;
				}
			});
			log.info(label, `Logging output to: ${logFilePath} (mode: ${flags})`);
			// Use composite key for adding log entry
			addLogEntry(compositeKey, `--- Process Started (${new Date().toISOString()}) ---`);
		} catch (error) {
			log.error(label, "Failed to set up log file stream", error);
			logFilePath = null;
			logFileStream = null;
		}
	} else {
		log.warn(label, "Log directory not configured, file logging disabled.");
	}
	// --- End Log File Setup ---

	try {
		ptyProcess = pty.spawn(shell, [], {
			name: "xterm-color",
			cols: 80,
			rows: 30,
			cwd: effectiveWorkingDirectory,
			env: {
				...process.env,
				FORCE_COLOR: "1",
				MCP_PROCESS_LABEL: label, // Keep user label in env
				MCP_PROCESS_KEY_HASH: compositeKey.substring(0, 10), // Maybe add partial key hash? Optional.
			},
			encoding: "utf8",
		});
	} catch (error: unknown) {
		// ... (error handling for spawn failure - use compositeKey for state updates) ...
		const errorMsg = `Failed to spawn PTY: ${error instanceof Error ? error.message : String(error)}`;
		log.error(label, errorMsg);
		if (!managedProcesses.has(compositeKey)) {
			managedProcesses.set(compositeKey, { /* ... error process info ... */ });
		}
		updateProcessStatus(compositeKey, "error");
		logFileStream?.end();
		return fail(/* ... error payload ... */);
	}

	// Create/Update ProcessInfo using compositeKey as the map key
	const processInfo: ProcessInfo = {
		label, // Store user-facing label
		compositeKey, // Store key for reference within info object
		pid: ptyProcess.pid,
		process: ptyProcess,
		command,
		args,
		cwd: effectiveWorkingDirectory,
		logs: existingProcessInfo && isRestart ? existingProcessInfo.logs : [],
		status: "starting",
		exitCode: null,
		signal: null,
		lastCrashTime: existingProcessInfo?.lastCrashTime,
		restartAttempts: existingProcessInfo?.restartAttempts,
		verificationPattern,
		verificationTimeoutMs: verificationTimeoutMs ?? null,
		verificationTimer: undefined,
		retryDelayMs: retryDelayMs ?? null,
		maxRetries: maxRetries ?? 0,
		logFilePath: logFilePath,
		logFileStream: logFileStream,
	};
	// Use compositeKey to set in the map
	managedProcesses.set(compositeKey, processInfo);
	// Use compositeKey to update status and add logs
	updateProcessStatus(compositeKey, "starting");
	addLogEntry(
		compositeKey,
		`Process spawned (PID: ${ptyProcess.pid}) in ${effectiveWorkingDirectory}. Status: starting.`,
	);

	ptyProcess.write(`${fullCommand}\r`);

	// --- Verification Logic (uses processInfo, which is fine) ---
	// ... (verification logic remains the same, uses processInfo) ...
	// Make sure addLogEntry and updateProcessStatus calls use compositeKey

	// --- Standard Log Handling (uses processInfo, logs via addLogEntry with compositeKey) ---
	const mainDataDisposable = ptyProcess.onData((data: string) => {
		const lines = data.split(/\r?\n/);
		for (const line of lines) {
			if (line.trim()) {
				addLogEntry(compositeKey, line); // Use composite key
			}
		}
	});

	// --- Exit/Error Handling (uses processInfo, calls handleExit with compositeKey) ---
	const mainExitDisposable = ptyProcess.onExit(({ exitCode, signal }) => {
		log.debug(label, "Main onExit triggered.", { exitCode, signal });
		mainDataDisposable.dispose();
		// Get fresh info using composite key before calling handleExit
		const currentInfo = managedProcesses.get(compositeKey);
		if (currentInfo /* && currentInfo.status !== 'verifying' */) {
			// Call handleExit with compositeKey
			handleExit(
				compositeKey,
				exitCode ?? null,
				signal !== undefined ? String(signal) : null,
			);
		} else {
			log.warn(label, `Process info not found for key ${compositeKey.substring(0, 50)}... during onExit.`);
		}
		mainExitDisposable.dispose();
	});

	// --- Wait for Initial Logs to Settle ---
	const settleResult = await _waitForLogSettleOrTimeout(label, ptyProcess);
	// ... (wait for verification if needed) ...

	// --- Final Return ---
	// Use check function with composite key
	const currentInfoAfterWait = await checkAndUpdateProcessStatusByKey(
		compositeKey,
	);

	if (!currentInfoAfterWait) {
		const errorMsg = `Internal error: Process info for key "${compositeKey.substring(0, 50)}..." not found after startup wait.`;
		log.error(label, errorMsg);
		return fail(
			textPayload(JSON.stringify({ error: errorMsg, status: "not_found" })),
		);
	}

	// ... (rest of the return logic based on final status) ...
	// Ensure payload includes the user-facing 'label'
	const finalStatus = currentInfoAfterWait.status;
	let message = `Process "${label}" started (PID: ${currentInfoAfterWait.pid}). Status: ${finalStatus}.`;
	// ... (add settle/timeout info) ...
	message += " Use check_process_status for updates.";

	const logsToReturn = formatLogsForResponse(
		currentInfoAfterWait.logs.map((l: LogEntry) => l.content),
		DEFAULT_LOG_LINES,
	);

	log.info(
		label,
		`Returning result for start_process. Logs: ${logsToReturn.length}. Status: ${finalStatus}.`,
	);

	if (["starting", "running", "verifying"].includes(finalStatus)) {
		// ... (create success payload - include 'label', not compositeKey) ...
		const successPayload = {
			label: currentInfoAfterWait.label, // Return user label
			message: message,
			status: finalStatus,
			pid: currentInfoAfterWait.pid,
			cwd: currentInfoAfterWait.cwd,
			// Include args in response for clarity
			command: currentInfoAfterWait.command,
			args: currentInfoAfterWait.args,
			logs: logsToReturn,
			monitoring_hint: `Use check_process_status with label "${currentInfoAfterWait.label}" for updates.`,
			log_file_path: currentInfoAfterWait.logFilePath,
			tail_command: currentInfoAfterWait.logFilePath
				? `tail -f "${currentInfoAfterWait.logFilePath}"`
				: null,
			// Optionally include composite key for debugging?
			// _internal_key_debug: compositeKey,
		};
		return ok(textPayload(JSON.stringify(successPayload, null, 2)));
	} else {
		// ... (create error payload - include 'label') ...
		const errorMsg = `Process "${label}" failed to stabilize or exited. Final status: ${finalStatus}`;
		log.error(label, errorMsg, { exitCode: currentInfoAfterWait.exitCode, signal: currentInfoAfterWait.signal });
		logFileStream?.end();

		const errorPayload = {
			error: errorMsg,
			status: finalStatus,
			label: currentInfoAfterWait.label, // Include user label
			pid: currentInfoAfterWait.pid,
			exitCode: currentInfoAfterWait.exitCode,
			signal: currentInfoAfterWait.signal,
			command: currentInfoAfterWait.command,
			args: currentInfoAfterWait.args,
			cwd: currentInfoAfterWait.cwd,
			logs: logsToReturn,
			log_file_path: currentInfoAfterWait.logFilePath,
		};
		return fail(textPayload(JSON.stringify(errorPayload, null, 2)));
	}
}

/**
 * Internal function to stop a background process.
 * Finds the process by label and handles ambiguity.
 */
export async function _stopProcess(
	label: string, // User-provided label
	force = false,
): Promise<CallToolResult> {
	log.info(label, `Attempting to stop process "${label}" (force=${force})...`);

	let compositeKey: string;
	let processInfo: ProcessInfo | null;

	try {
		// Find the unique composite key and info using the label
		const [foundKey, initialInfo] = findProcessByLabel(label);
		compositeKey = foundKey;
		// Get potentially updated status using the found key
		processInfo = await checkAndUpdateProcessStatusByKey(compositeKey);
	} catch (error) {
		// Ambiguity or not found error from findProcessByLabel
		log.error(label, `Stop failed: ${error.message}`);
		return fail(
			textPayload(
				JSON.stringify({
					error: error.message,
					status: error.message.includes("ambiguous") ? "ambiguous_label" : "not_found",
					error_type: error.message.includes("ambiguous") ? "ambiguous_label" : "not_found",
				}),
			),
		);
	}

	// We should have processInfo if findProcessByLabel succeeded, but double-check
	if (!processInfo) {
		// This case should ideally be caught by findProcessByLabel or checkByKey
		const errorMsg = `Process with label "${label}" found initially but disappeared before stop.`;
		log.error(label, errorMsg);
		return fail(
			textPayload(
				JSON.stringify({ error: errorMsg, status: "not_found", error_type: "disappeared" }),
			),
		);
	}

	// Now proceed with stopping using processInfo and compositeKey
	if (
		["stopped", "crashed", "error"].includes(processInfo.status) &&
		!processInfo.pid // Check PID specifically
	) {
		log.warn(label, `Process is already terminal (${processInfo.status}).`);
		return ok(/* ... already stopped payload ... */);
	}

	if (!processInfo.process || !processInfo.pid) {
		// ... (handle missing handle/PID - use compositeKey for status update) ...
		const errorMsg = `Cannot stop: Handle/PID missing (Status: ${processInfo.status}).`;
		log.error(label, errorMsg);
		updateProcessStatus(compositeKey, "error"); // Use key
		return fail(/* ... missing handle payload ... */);
	}

	// Clear verification timer if stopping during verification
	if (processInfo.verificationTimer) {
		clearTimeout(processInfo.verificationTimer);
		processInfo.verificationTimer = undefined;
		log.info(label, "Cleared verification timer during stop.");
	}

	const signal: "SIGTERM" | "SIGKILL" = force ? "SIGKILL" : "SIGTERM";
	log.info(label, `Sending ${signal} to PID ${processInfo.pid}...`);
	// Use composite key for logging and status updates
	addLogEntry(compositeKey, `Sending ${signal} signal.`);
	updateProcessStatus(compositeKey, "stopping");

	try {
		processInfo.process.kill(signal);
	} catch (error: unknown) {
		// ... (handle signal send failure - use compositeKey for check/update) ...
		const errorMsg = `Failed to send ${signal}: ${error instanceof Error ? error.message : String(error)}`;
		log.error(label, errorMsg);
		addLogEntry(compositeKey, `Error sending signal: ${errorMsg}`);
		const postSignalCheck = await checkAndUpdateProcessStatusByKey(compositeKey); // Use key
		const currentStatus = postSignalCheck?.status ?? processInfo.status;
		if (currentStatus !== "stopped" && currentStatus !== "crashed") {
			updateProcessStatus(compositeKey, "error"); // Use key
		}
		return fail(/* ... signal send failed payload ... */);
	}

	// Stop initiated, let onExit handle final state via compositeKey
	const currentProcessInfo = managedProcesses.get(compositeKey); // Get fresh info
	return ok(
		textPayload(
			JSON.stringify(
				{
					message: `Stop signal (${signal}) sent to process "${label}" (PID: ${processInfo.pid}).`,
					status: currentProcessInfo?.status ?? "stopping", // Reflect current status
					label: label,
					pid: processInfo.pid,
					cwd: processInfo.cwd,
					logs: formatLogsForResponse(
						(currentProcessInfo?.logs ?? processInfo.logs).map((l) => l.content),
						DEFAULT_LOG_LINES,
					),
					monitoring_hint: "Use check_process_status for final status.",
				},
				null,
				2,
			),
		),
	);
}

/**
 * Internal function to send input to a running background process.
 * Finds the process by label and handles ambiguity.
 */
export async function _sendInput(
	params: z.infer<typeof SendInputParams>,
): Promise<CallToolResult> {
	const { label, input, append_newline } = params;
	log.info(label, `Attempting to send input to process "${label}"...`);

	let compositeKey: string;
	let processInfo: ProcessInfo | null;

	try {
		// Find the unique composite key and info using the label
		const [foundKey, initialInfo] = findProcessByLabel(label);
		compositeKey = foundKey;
		// Get potentially updated status using the found key
		processInfo = await checkAndUpdateProcessStatusByKey(compositeKey);
	} catch (error) {
		// Ambiguity or not found error
		log.error(label, `Send input failed: ${error.message}`);
		return fail(
			textPayload(
				JSON.stringify({
					error: error.message,
					status: error.message.includes("ambiguous") ? "ambiguous_label" : "not_found",
					error_type: error.message.includes("ambiguous") ? "ambiguous_label" : "not_found",
				}),
			),
		);
	}

	// Should have processInfo here
	if (!processInfo) {
		const errorMsg = `Process "${label}" disappeared before sending input.`;
		log.error(label, errorMsg);
		return fail(
			textPayload(
				JSON.stringify({ error: errorMsg, status: "not_found", error_type: "disappeared" }),
			),
		);
	}

	// Check state using processInfo
	const allowedStates: ProcessStatus[] = ["running", "verifying", "starting"];
	if (!allowedStates.includes(processInfo.status)) {
		const errorMsg = `Process "${label}" is not ready for input (Status: ${processInfo.status}).`;
		log.warn(label, errorMsg);
		return fail(/* ... invalid state payload ... */);
	}

	if (!processInfo.process) {
		const errorMsg = `Cannot send input: Process handle missing (Status: ${processInfo.status}).`;
		log.error(label, errorMsg);
		return fail(/* ... missing handle payload ... */);
	}

	try {
		const dataToSend = input + (append_newline ? "\r" : ""); // Use \r for PTY Enter
		log.debug(label, `Writing to PTY: "${dataToSend.replace("\r", "<CR>")}"`);

		processInfo.process.write(dataToSend);

		const logMessage = `Input sent: "${input}"${append_newline ? " (with newline)" : ""}`;
		// Use composite key for logging
		addLogEntry(compositeKey, logMessage);
		log.info(label, logMessage);

		return ok(
			textPayload(
				JSON.stringify(
					{
						message: `Input sent to process "${label}".`,
						input_sent: input,
						newline_appended: append_newline,
						status: processInfo.status,
						label: label,
						pid: processInfo.pid,
					},
					null,
					2,
				),
			),
		);
	} catch (error: unknown) {
		const errorMsg = `Failed to write input: ${error instanceof Error ? error.message : String(error)}`;
		log.error(label, errorMsg, error);
		// Use composite key for logging
		addLogEntry(compositeKey, `Error sending input: ${errorMsg}`);
		return fail(/* ... write failed payload ... */);
	}
}
```

**4. Update Tool Definitions (`src/toolDefinitions.ts`)**

Refine the auto-generated label and ensure the calls to process logic functions are correct. The internal functions (`_checkProcessStatus`, `_stopProcess`, etc.) now handle the label lookup.

```typescript
// src/toolDefinitions.ts

import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import {
	DEFAULT_LOG_LINES,
	DEFAULT_RETRY_DELAY_MS,
	DEFAULT_VERIFICATION_TIMEOUT_MS,
	MAX_RETRIES,
	MAX_STORED_LOG_LINES,
	SERVER_NAME,
	SERVER_VERSION,
} from "./constants.js";
import { _sendInput, _startProcess, _stopProcess } from "./processLogic.js";
import {
	// Import the by-label checker/finder used by tool logic
	checkAndUpdateProcessStatusByLabel,
	findProcessByLabel,
	isZombieCheckActive,
	managedProcesses,
	// No need for addLogEntry here directly
} from "./state.js";
import { handleToolCall } from "./toolHandler.js";
import { type CallToolResult, fail, ok, shape, textPayload } from "./types.js";
import type { LogEntry, ProcessInfo, ProcessStatus } from "./types.ts"; // Added ProcessInfo
import {
	formatLogsForResponse,
	log,
	stripAnsiAndControlChars,
	// No need for generateCompositeKey here directly
} from "./utils.js";

// ... (Schemas remain the same: labelSchema, StartProcessParams, CheckProcessStatusParams, etc.) ...
const labelSchema = z
	.string()
	.min(1, "Label cannot be empty.")
	.describe("A unique user-facing identifier for the process or group of processes."); // Updated description

const StartProcessParams = z.object(
	shape({
		label: labelSchema
			.optional()
			.describe(
				"Optional user-facing identifier for the process. If omitted, one will be generated based on the working directory, command and args (e.g., '/path/to/project:npm run dev --watch').",
			),
		// ... rest of StartProcessParams ...
		command: z.string().min(1).describe("The command to execute."),
		args: z.array(z.string()).optional().default([]).describe("Arguments."),
		workingDirectory: z.string().describe("Absolute working directory."),
		verification_pattern: z.string().optional().describe("Regex for verification."),
		verification_timeout_ms: z.number().int().positive().optional().describe("Verification timeout."),
		retry_delay_ms: z.number().int().positive().optional().describe("Crash retry delay."),
		max_retries: z.number().int().min(0).optional().describe("Max crash retries."),
	}),
);

const CheckProcessStatusParams = z.object(
	shape({
		label: labelSchema.describe("The user-facing label of the process to check."),
		// ... rest of CheckProcessStatusParams ...
		log_lines: z.number().int().min(0).optional().default(DEFAULT_LOG_LINES).describe("Log lines to return."),
	}),
);

const StopProcessParams = z.object(
	shape({
		label: labelSchema.describe("The user-facing label of the process to stop."),
		// ... rest of StopProcessParams ...
		force: z.boolean().optional().default(false).describe("Force kill."),
	}),
);

const ListProcessesParams = z.object(/* ... unchanged ... */);
const RestartProcessParams = z.object(
	shape({
		label: labelSchema.describe("The user-facing label of the process to restart."),
	}),
);
const WaitForProcessParams = z.object(
	shape({
		label: labelSchema.describe("The user-facing label of the process to wait for."),
		// ... rest of WaitForProcessParams ...
		target_status: z.enum(["running", "stopped", "crashed", "error"]).optional().default("running").describe("Target status."),
		timeout_seconds: z.number().positive().optional().default(60).describe("Wait timeout."),
		check_interval_seconds: z.number().positive().optional().default(2).describe("Check interval."),
	}),
);
const GetAllLoglinesParams = z.object(
	shape({
		label: labelSchema.describe("The user-facing label of the process to get all logs for."),
	}),
);
const SendInputParams = z.object(
	shape({
		label: labelSchema.describe("The user-facing label of the target process."),
		// ... rest of SendInputParams ...
		input: z.string().describe("Input text."),
		append_newline: z.boolean().optional().default(true).describe("Append newline."),
	}),
);
// --- End Schemas ---

// --- Response Types (ensure they use 'label' appropriately) ---
interface CheckStatusResponsePayload {
	label: string; // User-facing label
	status: ProcessStatus | "not_found" | "ambiguous_label"; // Add possible error statuses
	pid: number | undefined | null;
	command: string | null;
	args: string[] | null;
	cwd: string | null;
	exitCode: number | null;
	signal: string | null;
	logs: string[];
	log_file_path: string | null | undefined;
	tail_command: string | null | undefined;
	hint?: string;
	error?: string; // Add error field
}

interface ListProcessDetail {
	label: string; // User-facing label
	status: ProcessStatus;
	pid: number | undefined;
	command: string;
	args: string[];
	cwd: string;
	exitCode: number | null;
	signal: string | null;
	logs: string[];
	log_hint: string | null;
	log_file_path: string | null | undefined;
	tail_command: string | null | undefined;
	// Optionally include composite key hash for debugging?
	// _internal_key_hash_debug?: string;
}
// --- End Response Types ---

// Tool logic functions now use the label-based finders/checkers from state/processLogic

async function _checkProcessStatus(
	params: z.infer<typeof CheckProcessStatusParams>,
): Promise<CallToolResult> {
	const { label, log_lines } = params;
	let processInfo: ProcessInfo | null;
	let findError: Error | null = null;

	try {
		// Use the finder which handles ambiguity
		const [compositeKey, foundInfo] = findProcessByLabel(label);
		// Now get the latest status using the unique key
		processInfo = await checkAndUpdateProcessStatusByKey(compositeKey);
	} catch (error) {
		findError = error;
		processInfo = null; // Ensure processInfo is null on error
	}

	// Handle case where process was found but disappeared between find and check
	if (!findError && !processInfo && managedProcesses.size > 0) {
		// Check if it still exists in the map *at all* under any key with that label
		let stillExists = false;
		for(const info of managedProcesses.values()) {
			if (info.label === label) {
				stillExists = true;
				break;
			}
		}
		if (!stillExists) {
			findError = new Error(`Process with label "${label}" not found.`);
		} else {
			// This case is less likely now with checkByKey, but handle defensively
			findError = new Error(`Process "${label}" info became unavailable unexpectedly.`);
		}

	}


	if (findError) {
		const isAmbiguous = findError.message.includes("ambiguous");
		const status = isAmbiguous ? "ambiguous_label" : "not_found";
		log.error(label, `Check status failed: ${findError.message}`);
		return fail(
			textPayload(
				JSON.stringify({
					error: findError.message,
					label: label,
					status: status,
					pid: null, command: null, args: null, cwd: null, exitCode: null, signal: null, logs: [],
				} satisfies CheckStatusResponsePayload, null, 2),
			),
		);
	}

    // If we reach here, processInfo should be valid
    if (!processInfo) {
         // Fallback error if something went wrong
        const errorMsg = `Internal error: Process info unexpectedly null for label "${label}" after successful lookup.`;
        log.error(label, errorMsg);
		return fail(
			textPayload(
				JSON.stringify({
					error: errorMsg,
					label: label,
					status: "error", // Generic error status
					pid: null, command: null, args: null, cwd: null, exitCode: null, signal: null, logs: [],
				} satisfies CheckStatusResponsePayload, null, 2),
			),
		);
    }


	const formattedLogs = formatLogsForResponse(
		processInfo.logs.map((l: LogEntry) => l.content),
		log_lines ?? DEFAULT_LOG_LINES,
	);

	const responsePayload: CheckStatusResponsePayload = {
		label: processInfo.label, // User-facing label
		status: processInfo.status,
		pid: processInfo.pid,
		command: processInfo.command,
		args: processInfo.args,
		cwd: processInfo.cwd,
		exitCode: processInfo.exitCode,
		signal: processInfo.signal,
		logs: formattedLogs,
		log_file_path: processInfo.logFilePath,
		tail_command: processInfo.logFilePath
			? `tail -f "${processInfo.logFilePath}"`
			: null,
	};

	// Add hint based on logs
	const totalStoredLogs = processInfo.logs.length;
	const requestedLines = log_lines ?? DEFAULT_LOG_LINES;
	if (requestedLines > 0 && totalStoredLogs > formattedLogs.length) {
		// ... set hint ...
	} else if (requestedLines === 0 && totalStoredLogs > 0) {
		// ... set hint ...
	}


	return ok(textPayload(JSON.stringify(responsePayload, null, 2)));
}

async function _listProcesses(
	params: z.infer<typeof ListProcessesParams>,
): Promise<CallToolResult> {
	const { log_lines } = params;
	const processList: ListProcessDetail[] = [];

	// Iterate through the map using compositeKey
	for (const [compositeKey, processInfo] of managedProcesses.entries()) {
		// Get potentially updated status using the key
		const currentInfo = await checkAndUpdateProcessStatusByKey(compositeKey);
		// Use the result of the check, or fallback to map value if check failed (unlikely)
		const infoToUse = currentInfo ?? processInfo;

		const formattedLogs = formatLogsForResponse(
			infoToUse.logs.map((l: LogEntry) => l.content),
			log_lines ?? 0, // Default to 0 for list
		);
		let logHint: string | null = null;
		// ... (generate log hint logic) ...

		const processDetail: ListProcessDetail = {
			label: infoToUse.label, // User-facing label
			status: infoToUse.status,
			pid: infoToUse.pid,
			command: infoToUse.command,
			args: infoToUse.args,
			cwd: infoToUse.cwd,
			exitCode: infoToUse.exitCode,
			signal: infoToUse.signal,
			logs: formattedLogs,
			log_hint: logHint,
			log_file_path: infoToUse.logFilePath,
			tail_command: infoToUse.logFilePath
				? `tail -f "${infoToUse.logFilePath}"`
				: null,
			// _internal_key_hash_debug: compositeKey.substring(0,10) // Optional debug info
		};
		processList.push(processDetail);
	}

	return ok(textPayload(JSON.stringify(processList, null, 2)));
}

async function _stopAllProcesses(): Promise<CallToolResult> {
	log.info(null, "Attempting to stop all active processes...");
	const results: {
		label: string; // User label
		result: string;
		status?: ProcessStatus | "not_found" | "ambiguous_label"; // Include ambiguity
		pid?: number | null | undefined;
		error?: string;
	}[] = [];
	let stoppedCount = 0;
	let skippedCount = 0;
	let failedCount = 0;

	// Create a copy of keys to avoid issues if map is modified during iteration (by stop logic)
	const keysToStop = Array.from(managedProcesses.keys());

	for (const compositeKey of keysToStop) {
		const processInfo = await checkAndUpdateProcessStatusByKey(compositeKey);

		if (!processInfo) {
			// Already removed or error during check
			skippedCount++;
			// Try to get original label if possible for reporting
			const originalInfo = managedProcesses.get(compositeKey); // Check original map briefly
			results.push({
				label: originalInfo?.label ?? `unknown (key: ${compositeKey.substring(0, 10)}...)`,
				result: "Skipped",
				status: "not_found",
				pid: originalInfo?.pid,
				error: "Process info unavailable during stop all.",
			});
			continue;
		}

		// Use processInfo.label for logging and reporting
		if (
			["starting", "running", "verifying", "restarting"].includes(
				processInfo.status,
			)
		) {
			log.info(
				processInfo.label,
				`Stop All: Process active (${processInfo.status}), attempting stop.`,
			);
			// Call _stopProcess using the label (it will re-find the key internally)
			// This seems redundant, but keeps API consistent. Alternatively, call a key-based stop.
			// Let's call _stopProcess with label for consistency.
			const stopResult = await _stopProcess(processInfo.label, false); // Assuming label is unique here, which might not hold.
			// TODO: Need a key-based stop or handle ambiguity in stopAll if labels collide.
			// For now, assuming stopProcess works or fails based on the label provided.

			const resultText = getResultText(stopResult);
			let parsedResult: {
				status?: ProcessStatus | "ambiguous_label";
				error?: string;
				pid?: number | null;
			} = {};
			try {
				if(resultText) parsedResult = JSON.parse(resultText);
			} catch { /* ignore */ }

			if (stopResult.isError) {
				failedCount++;
				results.push({
					label: processInfo.label,
					result: "Failed",
					status: parsedResult.status ?? processInfo.status,
					pid: parsedResult.pid ?? processInfo.pid,
					error: parsedResult.error ?? "Unknown stop error",
				});
			} else {
				stoppedCount++;
				results.push({
					label: processInfo.label,
					result: "SignalSent",
					status: parsedResult.status ?? "stopping", // Assume stopping if signal sent
					pid: parsedResult.pid ?? processInfo.pid,
				});
			}
		} else {
			skippedCount++;
			results.push({
				label: processInfo.label,
				result: "Skipped",
				status: processInfo.status,
				pid: processInfo.pid,
			});
		}
	}

	const summary = `Processes processed: ${keysToStop.length}. Stop signals sent: ${stoppedCount}. Failed stops: ${failedCount}. Skipped (already terminal/missing): ${skippedCount}.`;
	log.info(null, summary);
	// Note: Ambiguity errors during individual stops within stopAll might be reported as failures.
	return ok(
		textPayload(JSON.stringify({ summary, details: results }, null, 2)),
	);
}


async function _restartProcess(
	params: z.infer<typeof RestartProcessParams>,
): Promise<CallToolResult> {
	const { label } = params;
	log.info(label, `Restart requested for process "${label}".`);

	let compositeKey: string;
	let processInfo: ProcessInfo | null;
	let originalPid: number | undefined | null = null;

	try {
		// Find the unique composite key and info using the label
		const [foundKey, initialInfo] = findProcessByLabel(label);
		compositeKey = foundKey;
		processInfo = await checkAndUpdateProcessStatusByKey(compositeKey);
		originalPid = processInfo?.pid; // Get PID after check
	} catch (error) {
		log.error(label, `Restart failed: ${error.message}`);
		return fail(
			textPayload(
				JSON.stringify({
					error: `Restart failed: ${error.message}`,
					status: error.message.includes("ambiguous") ? "ambiguous_label" : "not_found",
					pid: null,
				}),
			),
		);
	}

	if (!processInfo) {
		// Disappeared case
		const errorMsg = `Restart failed: Process "${label}" disappeared before restart.`;
		log.error(label, errorMsg);
		return fail(
			textPayload(
				JSON.stringify({ error: errorMsg, status: "not_found", pid: originalPid }),
			),
		);
	}

	// Add log entry using the found composite key
	addLogEntry(compositeKey, "Restart requested.");

	let stopStatus: ProcessStatus | "not_needed" = "not_needed";
	if (
		["starting", "running", "verifying", "restarting", "stopping"].includes(
			processInfo.status,
		)
	) {
		log.info(label, `Stopping process (${processInfo.status}) before restart...`);
		addLogEntry(compositeKey, "Stopping process before restart...");
		// Use _stopProcess with the label (it handles lookup and ambiguity)
		const stopResult = await _stopProcess(label, false); // Force=false for restart
		// ... (parse stopResult as before) ...
		const stopResultText = getResultText(stopResult);
		let stopResultJson: { status?: ProcessStatus | "ambiguous_label"; error?: string; pid?: number | null } = {};
		try { if(stopResultText) stopResultJson = JSON.parse(stopResultText); } catch {}

		stopStatus = stopResultJson.status === "ambiguous_label" ? "error" : (stopResultJson.status ?? "error"); // Treat ambiguity as error here

		if (stopResult.isError || stopStatus === "ambiguous_label") {
			const stopErrorMsg = stopResultJson.error ?? `Failed to stop process before restart (Status: ${stopStatus}).`;
			log.error(label, `Restart aborted: ${stopErrorMsg}`);
			addLogEntry(compositeKey, `Restart aborted: Stop failed: ${stopErrorMsg}`);
			return fail(/* ... stop failed payload ... */);
		}

		// Wait briefly for process to exit fully after SIGTERM
		await new Promise((resolve) => setTimeout(resolve, 500));
		const finalCheck = await checkAndUpdateProcessStatusByKey(compositeKey); // Check by key
		stopStatus = finalCheck?.status ?? stopStatus; // Update status after check
		log.info(label, `Stop phase completed, final status: ${stopStatus}.`);
		addLogEntry(compositeKey, `Stop phase completed, final status: ${stopStatus}.`);
	} else {
		log.info(label, `Process was ${processInfo.status}. Skipping stop phase.`);
		addLogEntry(compositeKey, `Process was ${processInfo.status}. Skipping stop phase.`);
		stopStatus = processInfo.status;
	}

	log.info(label, "Starting process after stop/check phase...");
	addLogEntry(compositeKey, "Starting process after stop/check phase...");

	// Call _startProcess with all original parameters from processInfo
	// It will generate the same compositeKey internally and handle the restart logic
	const startResult = await _startProcess(
		processInfo.label, // Original label
		processInfo.command,
		processInfo.args,
		processInfo.cwd,
		processInfo.verificationPattern,
		processInfo.verificationTimeoutMs ?? undefined,
		processInfo.retryDelayMs ?? undefined,
		processInfo.maxRetries,
		true, // Indicate restart=true
	);

	// ... (parse startResult and return success/failure as before) ...
	const startResultText = getResultText(startResult);
	let startResultJson: { status?: ProcessStatus; error?: string; pid?: number | null } = {};
	try { if(startResultText) startResultJson = JSON.parse(startResultText); } catch {}

	if (startResult.isError) {
		const startErrorMsg = startResultJson.error ?? "Failed to start process during restart.";
		log.error(label, `Restart failed: ${startErrorMsg}`);
		addLogEntry(compositeKey, `Restart failed: Start phase failed: ${startErrorMsg}`);
		return fail(/* ... start failed payload ... */);
	}

	log.info(label, "Restart sequence completed successfully.");
	addLogEntry(compositeKey, "Restart sequence completed successfully.");
	return startResult; // Return the result of the _startProcess call
}


async function _waitForProcess(
	params: z.infer<typeof WaitForProcessParams>,
): Promise<CallToolResult> {
	const { label, target_status, timeout_seconds, check_interval_seconds } =
		params;
	// ... (setup start time, timeouts etc) ...
	const startTime = Date.now();
	const timeoutMs = timeout_seconds * 1000;
	const intervalMs = check_interval_seconds * 1000;

	log.info(label, `Waiting for status '${target_status}'...`);
	// Add log entry using label initially, then key once found
	let compositeKey: string | null = null;

	while (Date.now() - startTime < timeoutMs) {
		let processInfo: ProcessInfo | null;
		let findError: Error | null = null;

		try {
			// Find the process by label on each iteration
			const [foundKey, foundInfo] = findProcessByLabel(label);
			compositeKey = foundKey; // Store key once found
			// Check status using the key
			processInfo = await checkAndUpdateProcessStatusByKey(compositeKey);
		} catch (error) {
			findError = error;
			processInfo = null;
		}

		if (findError) {
			// Not found or ambiguous
			const errorMsg = `Wait failed: ${findError.message}`;
			log.error(label, errorMsg);
			if (compositeKey) addLogEntry(compositeKey, errorMsg); // Log if key was found before error
			return fail(
				textPayload(
					JSON.stringify({
						error: errorMsg,
						status: findError.message.includes("ambiguous") ? "ambiguous_label" : "not_found",
						pid: null,
					}),
				),
			);
		}

        if (!processInfo) {
            // Disappeared case
            const errorMsg = `Wait failed: Process "${label}" disappeared.`;
            log.error(label, errorMsg);
            if (compositeKey) addLogEntry(compositeKey, errorMsg);
            return fail(/* ... disappeared payload ... */);
        }

		// Add initial log entry with key after first successful find
		if (Date.now() - startTime < intervalMs && compositeKey) { // Log only once
			addLogEntry(compositeKey, `Waiting for status '${target_status}'. Timeout: ${timeout_seconds}s.`);
		}

		log.debug(label, `Wait check: Current status is ${processInfo.status}`);

		if (processInfo.status === target_status) {
			// ... success logic ...
			const successMsg = `Reached target status '${target_status}'.`;
			log.info(label, successMsg);
			if(compositeKey) addLogEntry(compositeKey, successMsg);
			return ok(/* ... success payload ... */);
		}

		// Check for abort conditions (terminal state other than target)
		if (
			["stopped", "crashed", "error"].includes(processInfo.status) &&
			processInfo.status !== target_status
		) {
			// ... abort logic ...
			const abortMsg = `Wait aborted: Process entered terminal state '${processInfo.status}'.`;
			log.warn(label, abortMsg);
			if(compositeKey) addLogEntry(compositeKey, abortMsg);
			return fail(/* ... aborted payload ... */);
		}

		await new Promise((resolve) => setTimeout(resolve, intervalMs));
	}

	// Timeout occurred
	const finalInfo = compositeKey ? await checkAndUpdateProcessStatusByKey(compositeKey) : null;
	const timeoutMsg = `Timed out waiting for '${target_status}'. Final status: ${finalInfo?.status ?? 'unknown'}.`;
	log.error(label, timeoutMsg);
	if(compositeKey) addLogEntry(compositeKey, timeoutMsg);
	return fail(/* ... timeout payload ... */);
}

async function _getAllLoglines(
	params: z.infer<typeof GetAllLoglinesParams>,
): Promise<CallToolResult> {
	const { label } = params;
	let processInfo: ProcessInfo | null;
	let findError: Error | null = null;

	try {
		// Find by label, handles ambiguity
		const [compositeKey, foundInfo] = findProcessByLabel(label);
        // We don't strictly need checkAndUpdateStatus here, just retrieve the logs
		processInfo = managedProcesses.get(compositeKey); // Get directly from map
	} catch (error) {
		findError = error;
		processInfo = null;
	}

    if (findError || !processInfo) {
        const errorMsg = findError ? findError.message : `Process with label "${label}" not found.`;
        log.error(label, `Get all loglines failed: ${errorMsg}`);
		return fail(
			textPayload(
				JSON.stringify({
					error: errorMsg,
                    status: findError && findError.message.includes("ambiguous") ? "ambiguous_label" : "not_found",
				}),
			),
		);
    }


	// Proceed with found processInfo
	const allLogs = processInfo.logs.map((l: LogEntry) => l.content);
	const cleanedLogs = allLogs.map(stripAnsiAndControlChars);

	log.info(label, `getAllLoglines: Returning ${cleanedLogs.length} lines.`);

	const storedLimitReached = cleanedLogs.length >= MAX_STORED_LOG_LINES;
	const message = `Returned all ${cleanedLogs.length} stored log lines for "${label}"${storedLimitReached ? ` (limit: ${MAX_STORED_LOG_LINES})` : ""}.`;

	return ok(
		textPayload(
			JSON.stringify(
				{
					label: label,
					total_lines_returned: cleanedLogs.length,
					storage_limit: MAX_STORED_LOG_LINES,
					logs: cleanedLogs,
					message: message,
				},
				null,
				2,
			),
		),
	);
}


async function _healthCheck(): Promise<CallToolResult> {
	// Health check can iterate the map and report based on stored info
	// It doesn't need ambiguity checks, just report overall state
	const activeProcesses: { label: string; status: ProcessStatus; pid?: number }[] = [];
	let errorCount = 0;
	let crashedCount = 0;

	// Iterate using compositeKey, report using processInfo.label
	for (const [compositeKey, processInfo] of managedProcesses.entries()) {
		// Optional: Could run checkByKey here for most up-to-date status, but might slow down health check
		// const currentInfo = await checkAndUpdateProcessStatusByKey(compositeKey);
		// const infoToUse = currentInfo ?? processInfo;
		const infoToUse = processInfo; // Use stored info for faster health check

		activeProcesses.push({
			label: infoToUse.label, // Report user label
			status: infoToUse.status,
			pid: infoToUse.pid,
		});
		if (infoToUse.status === "error") errorCount++;
		if (infoToUse.status === "crashed") crashedCount++;
	}

	const payload = {
		server_name: SERVER_NAME,
		server_version: SERVER_VERSION,
		status: "healthy",
		managed_processes_count: managedProcesses.size,
		processes_in_error_state: errorCount,
		processes_in_crashed_state: crashedCount,
		zombie_check_active: isZombieCheckActive(),
		process_details: activeProcesses, // List includes user labels
	};
	if (errorCount > 0 || crashedCount > 0) {
		payload.status = "degraded";
	}

	log.info(null, `Health check performed. Status: ${payload.status}, Processes: ${payload.managed_processes_count}`);
	return ok(textPayload(JSON.stringify(payload, null, 2)));
}


// --- Tool Registration ---
export function registerToolDefinitions(server: McpServer): void {
	server.tool(
		"start_process",
		"Starts a background process, identified uniquely by label, command, working directory, and arguments.", // Updated description
		shape(StartProcessParams.shape),
		(params: z.infer<typeof StartProcessParams>) => {
			const cwdForLabel = params.workingDirectory;
			// Generate a more descriptive default label including args
			const argsString = params.args.join(" ");
			const commandPart = `${params.command}${argsString ? ` ${argsString}` : ""}`;
			const effectiveLabel = params.label || `${cwdForLabel}:${commandPart}`;

			log.info(
				effectiveLabel,
				`Determined label for start_process: ${effectiveLabel}`,
			);

			// Pass the effectiveLabel and other params to the handler
			return handleToolCall(
				effectiveLabel, // Use effectiveLabel for logging context within handleToolCall
				"start_process",
				params,
				async () => {
					const verificationPattern = params.verification_pattern
						? new RegExp(params.verification_pattern)
						: undefined;

					// Call _startProcess with the user-facing label
					// _startProcess will generate the composite key internally
					return await _startProcess(
						effectiveLabel,
						params.command,
						params.args,
						params.workingDirectory,
						verificationPattern,
						params.verification_timeout_ms,
						params.retry_delay_ms,
						params.max_retries,
						false, // isRestart = false
					);
				},
			);
		},
		// ... (keep examples) ...
	);

	server.tool(
		"check_process_status",
		"Checks status and logs. Fails if label is ambiguous.", // Updated description
		shape(CheckProcessStatusParams.shape),
		(params: z.infer<typeof CheckProcessStatusParams>) =>
			// _checkProcessStatus now handles the label lookup and ambiguity
			handleToolCall(params.label, "check_process_status", params, () =>
				_checkProcessStatus(params),
			),
	);

	server.tool(
		"stop_process",
		"Stops a process. Fails if label is ambiguous.", // Updated description
		shape(StopProcessParams.shape),
		(params: z.infer<typeof StopProcessParams>) =>
			// _stopProcess now handles lookup and ambiguity
			handleToolCall(params.label, "stop_process", params, async () => {
				return await _stopProcess(params.label, params.force);
			}),
	);

	server.tool(
		"list_processes",
		"Lists all managed processes with their user-facing labels and statuses.", // Updated description
		shape(ListProcessesParams.shape),
		(params: z.infer<typeof ListProcessesParams>) =>
			// _listProcesses iterates the map internally
			handleToolCall(null, "list_processes", params, () =>
				_listProcesses(params),
			),
	);

	server.tool(
		"stop_all_processes",
		"Attempts to stop all active processes. May report errors for ambiguous labels if encountered.", // Updated description
		{},
		(params: Record<string, never>) =>
			// _stopAllProcesses iterates internally
			handleToolCall(null, "stop_all_processes", params, _stopAllProcesses),
	);

	server.tool(
		"restart_process",
		"Restarts a process. Fails if label is ambiguous.", // Updated description
		shape(RestartProcessParams.shape),
		(params: z.infer<typeof RestartProcessParams>) =>
			// _restartProcess handles lookup and ambiguity
			handleToolCall(params.label, "restart_process", params, () =>
				_restartProcess(params),
			),
	);

	server.tool(
		"wait_for_process",
		"Waits for a process status. Fails if label is ambiguous.", // Updated description
		shape(WaitForProcessParams.shape),
		(params: z.infer<typeof WaitForProcessParams>) =>
			// _waitForProcess handles lookup and ambiguity
			handleToolCall(params.label, "wait_for_process", params, () =>
				_waitForProcess(params),
			),
	);

	server.tool(
		"get_all_loglines",
		"Retrieves full log history. Fails if label is ambiguous.", // Updated description
		shape(GetAllLoglinesParams.shape),
		(params: z.infer<typeof GetAllLoglinesParams>) =>
			// _getAllLoglines handles lookup and ambiguity
			handleToolCall(params.label, "get_all_loglines", params, () =>
				_getAllLoglines(params),
			),
	);

	server.tool(
		"health_check",
		"Provides a health status summary.", // Unchanged
		{},
		(params: Record<string, never>) =>
			// _healthCheck iterates internally
			handleToolCall(null, "health_check", params, _healthCheck),
	);

	server.tool(
		"send_input",
		"Sends input to a process. Fails if label is ambiguous.", // Updated description
		shape(SendInputParams.shape),
		(params: z.infer<typeof SendInputParams>) =>
			// _sendInput handles lookup and ambiguity
			handleToolCall(params.label, "send_input", params, () =>
				_sendInput(params),
			),
	);

	log.info(null, "Tool definitions registered.");
}

// Utility to extract text from result payload (remains the same)
function getResultText(result: CallToolResult): string | null {
	if (result.content && result.content.length > 0) {
		const firstContent = result.content[0];
		if (firstContent?.type === "text") { // Optional chaining for safety
			return firstContent.text;
		}
	}
	return null;
}

// Export SendInputParams if needed externally (remains the same)
export { SendInputParams };

// Also need to update ProcessInfo type definition
// Add compositeKey to ProcessInfo in src/types.ts
```

**5. Update Type Definition (`src/types.ts`)**

Add the `compositeKey` field to the `ProcessInfo` interface.

```typescript
// src/types.ts
// ... (keep existing imports and MCP types/helpers) ...
import type * as fs from "node:fs";
import type { IPty } from "node-pty";
import type { ZodRawShape } from "zod";

// ... (MCP types: TextContent, ImageContent, AudioContent, ResourceContent, ToolContent, CallToolResult, textPayload, ok, fail, shape, safeSubstring, isRunning, getResultText) ...

export interface LogEntry {
	timestamp: number;
	content: string;
}

/**
 * Contains information about a managed background process.
 */
export interface ProcessInfo {
	label: string; // User-defined or generated identifier (user-facing)
	compositeKey: string; // The internal unique key based on label, cmd, cwd, args
	process: IPty | null;
	command: string;
	args: string[];
	cwd: string;
	pid: number | undefined;
	logs: LogEntry[];
	status: ProcessStatus;
	exitCode: number | null;
	signal: string | null;
	logFilePath: string | null;
	logFileStream: fs.WriteStream | null;
	lastCrashTime?: number;
	restartAttempts?: number;
	verificationPattern?: RegExp;
	verificationTimeoutMs?: number | null;
	verificationTimer?: NodeJS.Timeout;
	retryDelayMs?: number | null;
	maxRetries?: number;
}

/**
 * Represents the possible states of a managed background process.
 */
export type ProcessStatus =
	| "starting"
	| "running"
	| "stopping"
	| "stopped"
	| "crashed"
	| "error"
	| "verifying"
	| "restarting";

// --- Add new possible status values for responses ---
export type ProcessStatusWithError = ProcessStatus | "not_found" | "ambiguous_label";

```

These changes introduce the composite key for internal tracking, ensuring uniqueness based on label, command, cwd, and args. Interaction tools still use the user-facing `label`, but the internal logic now includes checks for ambiguity when multiple processes share the same label. Remember to rebuild the project (`npm run build`) after applying these changes.

Break into tiny steps and after each step, run `npm run build && npm run lint:fix` to verify changes

---

_**Assistant**_



---

I'll implement the composite key approach for process uniqueness. Let's start by breaking this down into steps.

---

<details>
            <summary>Listed directory src  **9** results</summary>
        
| Name |
|-------|
|  `processLogic.ts` |
|  `toolDefinitions.ts` |
|  `utils.ts` |
|  `state.ts` |
|  `types.ts` |
|  `main.ts` |
|  `constants.ts` |
|  `toolHandler.ts` |
|  `index.ts` |

</details>

---

Let's start by examining each file we need to modify:

---

Read file: src/utils.ts

---

Read file: src/types.ts

---

Read file: src/state.ts

---

Now, let's start implementing the changes. I'll begin with updating the utility function to generate a composite key:

## Step 1: Add generateCompositeKey to utils.ts

---

Cancelled

---

## Step 2: Update the ProcessInfo type in types.ts to include the composite key

---

Cancelled

---

## Step 3: Update state.ts to use composite keys and handle ambiguity

---

```diff
  import { _startProcess } from "./processLogic.js"; // Corrected import path
  import type { LogEntry, ProcessInfo, ProcessStatus } from "./types.ts"; // Import LogEntry from types.ts
- import { log } from "./utils.js";
+ import { generateCompositeKey, log } from "./utils.js";
  
- // Renamed Map
+ // The key is now the Composite Key generated by generateCompositeKey
  export const managedProcesses: Map<string, ProcessInfo> = new Map();
  export let zombieCheckIntervalId: NodeJS.Timeout | null = null; // Export directly
  
  const killProcessTree = promisify(treeKill); // Define killProcessTree here
  
- export function addLogEntry(label: string, content: string): void {
- 	const processInfo = managedProcesses.get(label);
+ // Internal helper to find process by user-facing label (handles ambiguity)
+ // Returns [compositeKey, processInfo] or throws error
+ function findProcessByLabel(label: string): [string, ProcessInfo] {
+ 	const matchingProcesses: [string, ProcessInfo][] = [];
+ 	for (const [key, info] of managedProcesses.entries()) {
+ 		// Compare against the 'label' property stored *within* ProcessInfo
+ 		if (info.label === label) {
+ 			matchingProcesses.push([key, info]);
+ 		}
+ 	}
+ 
+ 	if (matchingProcesses.length === 0) {
+ 		throw new Error(`Process with label "${label}" not found.`);
+ 	}
+ 
+ 	if (matchingProcesses.length > 1) {
+ 		const details = matchingProcesses
+ 			.map(
+ 				([key, info]) =>
+ 					`- CWD: ${info.cwd}, Command: ${info.command} ${info.args.join(" ")} (Internal Key: ${key.substring(0, 50)}...)`,
+ 			)
+ 			.join("\n");
+ 		throw new Error(
+ 			`Label "${label}" is ambiguous and matches multiple running processes:\n${details}\nThis tool currently requires a unique label for interaction.`,
+ 		);
+ 	}
+ 
+ 	return matchingProcesses[0];
+ }
+ 
+ // Functions now operate using the compositeKey where applicable
+ 
+ // Add log entry using composite key
+ export function addLogEntry(compositeKey: string, content: string): void {
+ 	const processInfo = managedProcesses.get(compositeKey);
  	if (!processInfo) {
- 		// Log warning removed for brevity, handled elsewhere if needed
  		return;
  	}
```

```diff
  	processInfo.logs.push(entry);
  
- 	// Enforce the maximum in-memory log line limit
  	if (processInfo.logs.length > MAX_STORED_LOG_LINES) {
  		processInfo.logs.shift();
  	}
  
- 	// --- Write to file stream ---
- 	// Use optional chaining where appropriate, but keep explicit check for write logic
  	if (processInfo.logFileStream?.writable) {
  		try {
- 			// Write the raw content + newline. Error handled by stream 'error' listener.
- 			processInfo.logFileStream.write(`${content}\n`); // Use template literal
+ 			processInfo.logFileStream.write(`${content}\n`);
  		} catch (writeError) {
- 			// This catch might not be strictly necessary due to the async nature
- 			// and the 'error' listener, but added for robustness.
  			log.error(
- 				label,
- 				`Direct error writing to log stream for ${label}`,
+ 				processInfo.label, // Log with user label
+ 				`Direct error writing to log stream for ${compositeKey}`,
  				writeError,
  			);
- 			processInfo.logFileStream?.end(); // Attempt to close on direct error (optional chain)
+ 			processInfo.logFileStream?.end();
  			processInfo.logFileStream = null;
- 			processInfo.logFilePath = null; // Mark as unusable
+ 			processInfo.logFilePath = null;
  		}
  	}
- 	// --- End write to file stream ---
  }
  
- // Renamed function
+ // Update status using composite key
  export function updateProcessStatus(
- 	label: string,
+ 	compositeKey: string,
  	status: ProcessStatus,
  	exitInfo?: { code: number | null; signal: string | null },
  ): ProcessInfo | undefined {
- 	const processInfo = managedProcesses.get(label);
+ 	const processInfo = managedProcesses.get(compositeKey);
  	if (!processInfo) {
- 		log.warn(label, "Attempted to update status but process info missing.");
+ 		log.warn(
+ 			null, // No specific label context here maybe
+ 			`Attempted to update status for non-existent composite key: ${compositeKey.substring(0, 50)}...`,
+ 		);
  		return undefined;
  	}
```

```diff
  		processInfo.signal = exitInfo.signal;
  	} else {
- 		// Reset exit info if moving to a non-terminal state
  		processInfo.exitCode = null;
  		processInfo.signal = null;
  	}
  
- 	log.info(label, `Status changing from ${oldStatus} to ${status}`);
- 	addLogEntry(label, `Status changed to ${status}`);
+ 	log.info(
+ 		processInfo.label, // Log with user label
+ 		`Status changing from ${oldStatus} to ${status} (Key: ${compositeKey.substring(0, 50)}...)`,
+ 	);
+ 	addLogEntry(compositeKey, `Status changed to ${status}`); // Log with composite key
  
  	// Clear verification timer if process moves out of 'verifying' state
```

```diff
  	// Log when reaching stable running state
  	if (status === "running" && oldStatus !== "running") {
- 		log.info(label, "Process reached stable running state.");
- 		addLogEntry(label, "Process reached stable running state.");
+ 		log.info(processInfo.label, "Process reached stable running state.");
+ 		addLogEntry(compositeKey, "Process reached stable running state.");
  	}
  
  	return processInfo;
  }
  
- // Rename _startServer call later
- export async function handleCrashAndRetry(label: string): Promise<void> {
- 	const processInfo = managedProcesses.get(label);
+ // Handle crash using composite key
+ export async function handleCrashAndRetry(compositeKey: string): Promise<void> {
+ 	const processInfo = managedProcesses.get(compositeKey);
  	if (!processInfo || processInfo.status !== "crashed") {
  		log.warn(
- 			label,
- 			"handleCrashAndRetry called but process not found or not in crashed state.",
+ 			processInfo?.label, // Use label if available
+ 			`handleCrashAndRetry called for non-crashed/missing process (Key: ${compositeKey.substring(0, 50)}...)`,
  		);
  		return;
```

```diff
  	const retryDelay = processInfo.retryDelayMs ?? DEFAULT_RETRY_DELAY_MS;
  
- 	// Reset restart attempts if outside the crash loop window
  	if (
  		processInfo.lastCrashTime &&
  		now - processInfo.lastCrashTime > CRASH_LOOP_DETECTION_WINDOW_MS
  	) {
- 		log.info(label, "Resetting restart attempts, outside crash loop window.");
+ 		log.info(processInfo.label, "Resetting restart attempts.");
  		processInfo.restartAttempts = 0;
  	}
```

```diff
  	if (processInfo.restartAttempts > maxRetries) {
  		log.error(
- 			label,
- 			`Crash detected. Process exceeded max retries (${maxRetries}). Marking as error.`,
+ 			processInfo.label,
+ 			`Crash detected. Exceeded max retries (${maxRetries}). Marking as error.`,
  		);
  		addLogEntry(
- 			label,
+ 			compositeKey,
  			`Crash detected. Exceeded max retries (${maxRetries}). Marking as error.`,
  		);
- 		updateProcessStatus(label, "error");
- 		// Consider cleanup or final notification here
+ 		updateProcessStatus(compositeKey, "error");
  	} else {
  		log.warn(
- 			label,
+ 			processInfo.label,
  			`Crash detected. Attempting restart ${processInfo.restartAttempts}/${maxRetries} after ${retryDelay}ms...`,
  		);
  		addLogEntry(
- 			label,
+ 			compositeKey,
  			`Crash detected. Attempting restart ${processInfo.restartAttempts}/${maxRetries}...`,
  		);
- 		updateProcessStatus(label, "restarting");
+ 		updateProcessStatus(compositeKey, "restarting");
  
- 		// Use await with setTimeout for delay
  		await new Promise((resolve) => setTimeout(resolve, retryDelay));
  
- 		log.info(label, "Initiating restart...");
- 		// Re-use original start parameters, including verification settings
- 		await _startProcess(
- 			label,
+ 		log.info(processInfo.label, "Initiating restart...");
+ 		await _startProcess( // Call _startProcess with all details
+ 			processInfo.label, // The original label
  			processInfo.command,
- 			processInfo.args, // Pass args
+ 			processInfo.args,
  			processInfo.cwd,
  			processInfo.verificationPattern,
- 			processInfo.verificationTimeoutMs ?? undefined, // Convert null to undefined
- 			processInfo.retryDelayMs ?? undefined, // Convert null to undefined
- 			processInfo.maxRetries, // Pass retry settings
+ 			processInfo.verificationTimeoutMs ?? undefined,
+ 			processInfo.retryDelayMs ?? undefined,
+ 			processInfo.maxRetries,
  			true, // Indicate this is a restart
  		);
  	}
  }
  
+ // Handle exit using composite key
  export function handleExit(
- 	label: string,
+ 	compositeKey: string,
  	code: number | null,
  	signal: string | null,
  ): void {
- 	const processInfo = managedProcesses.get(label);
+ 	const processInfo = managedProcesses.get(compositeKey);
  	if (!processInfo) {
- 		log.warn(label, "handleExit called but process info not found.");
+ 		log.warn(
+ 			null,
+ 			`handleExit called for non-existent composite key: ${compositeKey.substring(0, 50)}...`,
+ 		);
  		return;
  	}
  
  	// --- Close Log Stream ---
  	if (processInfo.logFileStream) {
- 		log.debug(label, `Closing log file stream for ${label} due to exit.`);
+ 		log.debug(processInfo.label, `Closing log file stream due to exit.`);
  		addLogEntry(
- 			label,
+ 			compositeKey,
  			`--- Process Exited (Code: ${code ?? "N/A"}, Signal: ${signal ?? "N/A"}) ---`,
- 		); // Log exit marker before closing
+ 		);
  		processInfo.logFileStream.end(() => {
  			log.debug(
- 				label,
- 				`Log file stream for ${label} finished writing and closed.`,
+ 				processInfo.label,
+ 				`Log file stream finished writing and closed.`,
  			);
  		});
- 		processInfo.logFileStream = null; // Nullify immediately
- 		// Keep logFilePath even after closing for reference in check_status
+ 		processInfo.logFileStream = null;
  	}
  	// --- End Close Log Stream ---
  
  	const status = processInfo.status;
  
- 	// If the process was explicitly stopped, don't treat it as a crash
  	if (status === "stopping") {
- 		updateProcessStatus(label, "stopped", { code, signal });
+ 		updateProcessStatus(compositeKey, "stopped", { code, signal });
  	} else if (status !== "stopped" && status !== "error") {
- 		// Any other unexpected exit is treated as a crash
- 		updateProcessStatus(label, "crashed", { code, signal });
- 		// Don't retry immediately here, let checkAndUpdateProcessStatus or explicit restart handle it
- 		// Check if retry is configured and appropriate
+ 		updateProcessStatus(compositeKey, "crashed", { code, signal });
  		if (
  			processInfo.maxRetries !== undefined &&
  			processInfo.maxRetries > 0 &&
  			processInfo.retryDelayMs !== undefined
  		) {
- 			// Use void to explicitly ignore the promise for fire-and-forget
- 			void handleCrashAndRetry(label);
+ 			void handleCrashAndRetry(compositeKey); // Fire and forget
  		} else {
- 			log.info(label, "Process crashed, but no retry configured.");
- 			addLogEntry(label, "Process crashed. No retry configured.");
+ 			log.info(processInfo.label, "Process crashed, no retry configured.");
+ 			addLogEntry(compositeKey, "Process crashed. No retry configured.");
  		}
  	} else {
  		log.info(
- 			label,
+ 			processInfo.label,
  			`Process exited but was already in state ${status}. No status change.`,
  		);
```

---

Now let's continue updating the other functions in state.ts that use the label but need to be modified to use the composite key:

---

Cancelled

---

Now let's update the processLogic.ts file to use the composite key and handle ambiguity:

---

Read file: src/processLogic.ts

---

Let's update _startProcess in processLogic.ts:

---

```diff
  import {
  	addLogEntry,
- 	checkAndUpdateProcessStatus, // Renamed function
- 	handleExit, // Corrected type in state.ts handleExit
- 	managedProcesses, // Renamed map
- 	updateProcessStatus, // Renamed function
+ 	checkAndUpdateProcessStatusByKey,
+ 	findProcessByLabel,
+ 	handleExit,
+ 	managedProcesses,
+ 	updateProcessStatus,
  } from "./state.js";
  import type { SendInputParams } from "./toolDefinitions.js"; // Import the schema type
```

```diff
  	ProcessStatus,
  } from "./types.ts"; // Renamed types
- import { formatLogsForResponse, log } from "./utils.js";
- import { sanitizeLabelForFilename } from "./utils.js"; // Import sanitizer
+ import {
+ 	formatLogsForResponse,
+ 	generateCompositeKey,
+ 	log,
+ 	sanitizeLabelForFilename
+ } from "./utils.js";
  
  const killProcessTree = promisify(treeKill);
```

```diff
  /**
   * Internal function to start a background process.
-  * Handles process spawning, logging, status updates, verification, and retries.
+  * Uses a composite key internally.
   */
  export async function _startProcess(
- 	label: string,
+ 	label: string, // User-facing label
  	command: string,
- 	args: string[], // Added args
+ 	args: string[],
  	workingDirectoryInput: string | undefined,
- 	verificationPattern: RegExp | undefined, // Added verification pattern
- 	verificationTimeoutMs: number | undefined, // Added verification timeout
- 	retryDelayMs: number | undefined, // Added retry delay
- 	maxRetries: number | undefined, // Added max retries
- 	isRestart = false, // Flag to indicate if this is a restart
+ 	verificationPattern: RegExp | undefined,
+ 	verificationTimeoutMs: number | undefined,
+ 	retryDelayMs: number | undefined,
+ 	maxRetries: number | undefined,
+ 	isRestart = false,
  ): Promise<CallToolResult> {
  	const effectiveWorkingDirectory = workingDirectoryInput
  		? path.resolve(workingDirectoryInput)
  		: process.env.MCP_WORKSPACE_ROOT || process.cwd();
  
- 	log.info(
+ 	// Generate the internal composite key
+ 	const compositeKey = generateCompositeKey(
  		label,
- 		`Starting process... Command: "${command}", Args: [${args.join(", ")}], CWD: "${effectiveWorkingDirectory}", isRestart: ${isRestart}`,
+ 		command,
+ 		effectiveWorkingDirectory,
+ 		args,
+ 	);
+ 
+ 	log.info(
+ 		label, // Log with user label
+ 		`Starting process... Command: "${command}", Args: [${args.join(", ")}], CWD: "${effectiveWorkingDirectory}", isRestart: ${isRestart}. (Internal Key: ${compositeKey.substring(0, 50)}...)`,
  	);
  
```

```diff
  		const errorMsg = `Working directory does not exist: ${effectiveWorkingDirectory}`;
  		log.error(label, errorMsg);
- 		// Ensure an entry exists if this is the first attempt
- 		if (!managedProcesses.has(label)) {
- 			managedProcesses.set(label, {
- 				label,
+ 		if (!managedProcesses.has(compositeKey)) {
+ 			// Temporary entry for error state tracking
+ 			managedProcesses.set(compositeKey, {
+ 				label, // Store the user-facing label
+ 				compositeKey, // Store the key itself
  				command,
  				args,
```

```diff
  			});
  		}
- 		updateProcessStatus(label, "error"); // Simplified update
+ 		// Update status using the composite key
+ 		updateProcessStatus(compositeKey, "error");
  		return fail(
  			textPayload(
```

```diff
  	log.debug(label, "Working directory verified.");
  
- 	const existingProcess = managedProcesses.get(label);
- 
- 	// Check for active conflict based on label, cwd, and command
- 	if (!isRestart) {
- 		for (const existing of managedProcesses.values()) {
- 			if (
- 				existing.label === label &&
- 				existing.cwd === effectiveWorkingDirectory &&
- 				existing.command === command &&
+ 	// Check for conflict using the composite key
+ 	const existingProcessInfo = managedProcesses.get(compositeKey);
+ 	if (
+ 		existingProcessInfo &&
+ 		!isRestart &&
  		["starting", "running", "verifying", "restarting", "stopping"].includes(
- 					existing.status,
+ 			existingProcessInfo.status,
  		)
  	) {
- 				const errorMsg = `An active process with the same label ('${label}'), working directory ('${effectiveWorkingDirectory}'), and command ('${command}') already exists with status '${existing.status}' (PID: ${existing.pid}). Stop the existing process or use a different label.`;
+ 		const errorMsg = `An active process with the exact same label ('${label}'), working directory ('${effectiveWorkingDirectory}'), command ('${command}'), and arguments ('${args.join(" ")}') already exists with status '${existingProcessInfo.status}' (PID: ${existingProcessInfo.pid}). Stop the existing process first.`;
  		log.error(label, errorMsg);
  		return fail(
  			textPayload(
  				JSON.stringify({
  					error: errorMsg,
- 							status: existing.status,
- 							error_type: "composite_label_conflict",
+ 					status: existingProcessInfo.status,
+ 					error_type: "exact_process_conflict", // More specific error type
+ 					label: label,
+ 					command: command,
+ 					args: args,
+ 					cwd: effectiveWorkingDirectory,
  				}),
  			),
  		);
  	}
- 		}
- 	}
- 
- 	// If only label matches and not restarting, warn about reusing label but allow it if cwd/command differ
- 	if (
- 		!isRestart &&
- 		existingProcess &&
- 		existingProcess.label === label && // Check label again
- 		(existingProcess.cwd !== effectiveWorkingDirectory ||
- 			existingProcess.command !== command) &&
- 		["starting", "running", "verifying", "restarting", "stopping"].includes(
- 			existingProcess.status,
- 		)
- 	) {
- 		log.warn(
- 			label,
- 			`Reusing label "${label}" but with a different command/cwd. Previous instance (status: ${existingProcess.status}, cwd: ${existingProcess.cwd}, cmd: ${existingProcess.command}) will remain active. Ensure labels are distinct if managing truly different processes.`,
- 		);
- 		// No longer clearing old state here, as we allow multiple processes with same label if cwd/cmd differ
- 	} else if (isRestart) {
- 		log.info(label, `Restarting process "${label}".`);
- 	}
+ 
+ 	// If label matches BUT other components differ, it's not a conflict for *this* start request,
+ 	// but the user should be aware if they try to interact using just the label later.
+ 	// We don't need a specific warning here anymore, as the ambiguity check handles it during interaction.
  
  	const shell =
  		process.env.SHELL || (process.platform === "win32" ? "cmd.exe" : "bash");
  	let ptyProcess: pty.IPty;
- 	const fullCommand = [command, ...args].join(" "); // Combine command and args for PTY
+ 	const fullCommand = [command, ...args].join(" ");
  
  	// --- Log File Setup ---
```

```diff
  	if (serverLogDirectory) {
  		try {
+ 			// Sanitize using a combination for uniqueness, or just the label?
+ 			// Using just label might overwrite if multiple processes share label.
+ 			// Let's create a unique filename based on label + hash of key? Or just label + timestamp?
+ 			// Simplest for now: use sanitized label, acknowledging potential overwrite if labels collide.
  			const safeFilename = sanitizeLabelForFilename(label);
  			logFilePath = path.join(serverLogDirectory, safeFilename);
+ 			const flags = isRestart && fs.existsSync(logFilePath) ? "w" : "a";
+ 			logFileStream = fs.createWriteStream(logFilePath, { flags, encoding: "utf8" });
+ 			logFileStream.on("error", (err) => {
+ 				log.error(label, `Log file write error: ${logFilePath}`, err);
+ 				const info = managedProcesses.get(compositeKey);
+ 				if (info) {
+ 					info.logFileStream?.end();
+ 					info.logFileStream = null;
+ 					info.logFilePath = null;
+ 				}
+ 			});
+ 			log.info(label, `Logging output to: ${logFilePath} (mode: ${flags})`);
+ 			// Use composite key for adding log entry
  
  			// Create/Open the stream in append mode. Truncate if restarting.
```

---

It looks like there was an issue with applying our changes fully. Let's continue updating processLogic.ts with the remaining parts of _startProcess and also update _stopProcess and _sendInput:

---

Cancelled

---

Finally, let's update the toolDefinitions.ts file to handle finding processes by label and handling ambiguity:

---

Read file: src/toolDefinitions.ts

---

Let's update the toolDefinitions.ts file with the changes needed for ambiguity handling:

---

Cancelled

---

Now, let's update the remaining functions in the toolDefinitions.ts file to handle label ambiguity:

---

Cancelled

---

