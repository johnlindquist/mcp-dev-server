<!-- Generated by SpecStory -->

# Composite Key Implementation for Process Management (2025-04-29 08:27:27)

_**User**_



---

_**Assistant**_



---

Okay, I understand the plan. Let's apply these changes step by step.

Applying the changes to `src/utils.ts` to add the `generateCompositeKey` function.

---

```diff
  	return `${sanitized}.log`; // Use template literal
  }
+ 
+ // NEW: Function to generate a canonical composite key
+ /**
+  * Generates a canonical string key for a process based on its defining attributes.
+  * Sorts arguments to ensure order doesn't affect the key.
+  * @param label User-provided or generated label
+  * @param command The command executed
+  * @param cwd The working directory
+  * @param args Command arguments
+  * @returns A unique string key
+  */
+ export function generateCompositeKey(
+ 	label: string,
+ 	command: string,
+ 	cwd: string,
+ 	args: string[],
+ ): string {
+ 	// Sort args for canonical representation
+ 	const sortedArgs = [...args].sort();
+ 	// Use a separator that's unlikely to appear in paths/commands/labels
+ 	const separator = ":::";
+ 	return [label, cwd, command, JSON.stringify(sortedArgs)].join(separator);
+ }
  
```

---

Updating `src/state.ts` to use the composite key and handle label ambiguity.

---

```diff
  import { _startProcess } from "./processLogic.js"; // Corrected import path
  import type { LogEntry, ProcessInfo, ProcessStatus } from "./types.ts"; // Import LogEntry from types.ts
- import { log } from "./utils.js";
+ import { generateCompositeKey, log } from "./utils.js"; // Import generateCompositeKey
  
- // Renamed Map
+ // The key is now the Composite Key generated by generateCompositeKey
  export const managedProcesses: Map<string, ProcessInfo> = new Map();
  export let zombieCheckIntervalId: NodeJS.Timeout | null = null; // Export directly
  
  const killProcessTree = promisify(treeKill); // Define killProcessTree here
  
- export function addLogEntry(label: string, content: string): void {
- 	const processInfo = managedProcesses.get(label);
+ // Internal helper to find process by user-facing label (handles ambiguity)
+ // Returns [compositeKey, processInfo] or throws error
+ function findProcessByLabel(label: string): [string, ProcessInfo] {
+ 	const matchingProcesses: [string, ProcessInfo][] = [];
+ 	for (const [key, info] of managedProcesses.entries()) {
+ 		// Compare against the 'label' property stored *within* ProcessInfo
+ 		if (info.label === label) {
+ 			matchingProcesses.push([key, info]);
+ 		}
+ 	}
+ 
+ 	if (matchingProcesses.length === 0) {
+ 		throw new Error(`Process with label "${label}" not found.`);
+ 	}
+ 
+ 	if (matchingProcesses.length > 1) {
+ 		const details = matchingProcesses
+ 			.map(
+ 				([key, info]) =>
+ 					`- CWD: ${info.cwd}, Command: ${info.command} ${info.args.join(" ")} (Internal Key: ${key.substring(0, 50)}...)`,
+ 			)
+ 			.join("\n");
+ 		throw new Error(
+ 			`Label "${label}" is ambiguous and matches multiple running processes:\n${details}\nThis tool currently requires a unique label for interaction.`,
+ 		);
+ 	}
+ 
+ 	return matchingProcesses[0];
+ }
+ 
+ // Functions now operate using the compositeKey where applicable
+ 
+ // Add log entry using composite key
+ export function addLogEntry(compositeKey: string, content: string): void {
+ 	const processInfo = managedProcesses.get(compositeKey);
  	if (!processInfo) {
  		// Log warning removed for brevity, handled elsewhere if needed
```

```diff
  			// and the 'error' listener, but added for robustness.
  			log.error(
- 				label,
- 				`Direct error writing to log stream for ${label}`,
+ 				processInfo.label, // Log with user label
+ 				`Direct error writing to log stream for ${compositeKey}`,
  				writeError,
  			);
```

```diff
  }
  
- // Renamed function
+ // Update status using composite key
  export function updateProcessStatus(
- 	label: string,
+ 	compositeKey: string,
  	status: ProcessStatus,
  	exitInfo?: { code: number | null; signal: string | null },
  ): ProcessInfo | undefined {
- 	const processInfo = managedProcesses.get(label);
+ 	const processInfo = managedProcesses.get(compositeKey);
  	if (!processInfo) {
- 		log.warn(label, "Attempted to update status but process info missing.");
+ 		log.warn(
+ 			null, // No specific label context here maybe
+ 			`Attempted to update status for non-existent composite key: ${compositeKey.substring(0, 50)}...`,
+ 		);
  		return undefined;
  	}
```

```diff
  	}
  
- 	log.info(label, `Status changing from ${oldStatus} to ${status}`);
- 	addLogEntry(label, `Status changed to ${status}`);
+ 	log.info(
+ 		processInfo.label, // Log with user label
+ 		`Status changing from ${oldStatus} to ${status} (Key: ${compositeKey.substring(0, 50)}...)`,
+ 	);
+ 	addLogEntry(compositeKey, `Status changed to ${status}`); // Log with composite key
  
  	// Clear verification timer if process moves out of 'verifying' state
```

```diff
  	// Log when reaching stable running state
  	if (status === "running" && oldStatus !== "running") {
- 		log.info(label, "Process reached stable running state.");
- 		addLogEntry(label, "Process reached stable running state.");
+ 		log.info(processInfo.label, "Process reached stable running state.");
+ 		addLogEntry(compositeKey, "Process reached stable running state.");
  	}
  
  	return processInfo;
  }
  
- // Rename _startServer call later
- export async function handleCrashAndRetry(label: string): Promise<void> {
- 	const processInfo = managedProcesses.get(label);
+ // Handle crash using composite key
+ export async function handleCrashAndRetry(compositeKey: string): Promise<void> {
+ 	const processInfo = managedProcesses.get(compositeKey);
  	if (!processInfo || processInfo.status !== "crashed") {
  		log.warn(
- 			label,
- 			"handleCrashAndRetry called but process not found or not in crashed state.",
+ 			processInfo?.label, // Use label if available
+ 			`handleCrashAndRetry called for non-crashed/missing process (Key: ${compositeKey.substring(0, 50)}...)`,
  		);
  		return;
```

```diff
  		now - processInfo.lastCrashTime > CRASH_LOOP_DETECTION_WINDOW_MS
  	) {
- 		log.info(label, "Resetting restart attempts, outside crash loop window.");
+ 		log.info(processInfo.label, "Resetting restart attempts.");
  		processInfo.restartAttempts = 0;
  	}
```

```diff
  	if (processInfo.restartAttempts > maxRetries) {
  		log.error(
- 			label,
- 			`Crash detected. Process exceeded max retries (${maxRetries}). Marking as error.`,
+ 			processInfo.label,
+ 			`Crash detected. Exceeded max retries (${maxRetries}). Marking as error.`,
  		);
  		addLogEntry(
- 			label,
+ 			compositeKey,
  			`Crash detected. Exceeded max retries (${maxRetries}). Marking as error.`,
  		);
- 		updateProcessStatus(label, "error");
+ 		updateProcessStatus(compositeKey, "error");
  		// Consider cleanup or final notification here
  	} else {
  		log.warn(
- 			label,
+ 			processInfo.label,
  			`Crash detected. Attempting restart ${processInfo.restartAttempts}/${maxRetries} after ${retryDelay}ms...`,
  		);
  		addLogEntry(
- 			label,
+ 			compositeKey,
  			`Crash detected. Attempting restart ${processInfo.restartAttempts}/${maxRetries}...`,
  		);
- 		updateProcessStatus(label, "restarting");
+ 		updateProcessStatus(compositeKey, "restarting");
  
  		// Use await with setTimeout for delay
  		await new Promise((resolve) => setTimeout(resolve, retryDelay));
  
- 		log.info(label, "Initiating restart...");
+ 		log.info(processInfo.label, "Initiating restart...");
  		// Re-use original start parameters, including verification settings
  		await _startProcess(
- 			label,
+ 			processInfo.label,
  			processInfo.command,
  			processInfo.args, // Pass args
```

```diff
  }
  
+ // Handle exit using composite key
  export function handleExit(
- 	label: string,
+ 	compositeKey: string,
  	code: number | null,
  	signal: string | null,
  ): void {
- 	const processInfo = managedProcesses.get(label);
+ 	const processInfo = managedProcesses.get(compositeKey);
  	if (!processInfo) {
- 		log.warn(label, "handleExit called but process info not found.");
+ 		log.warn(
+ 			null,
+ 			`handleExit called for non-existent composite key: ${compositeKey.substring(0, 50)}...`,
+ 		);
  		return;
  	}
  
  	// --- Close Log Stream ---
  	if (processInfo.logFileStream) {
- 		log.debug(label, `Closing log file stream for ${label} due to exit.`);
+ 		log.debug(processInfo.label, `Closing log file stream due to exit.`);
  		addLogEntry(
- 			label,
+ 			compositeKey,
  			`--- Process Exited (Code: ${code ?? "N/A"}, Signal: ${signal ?? "N/A"}) ---`,
  		); // Log exit marker before closing
  		processInfo.logFileStream.end(() => {
  			log.debug(
- 				label,
- 				`Log file stream for ${label} finished writing and closed.`,
+ 				processInfo.label,
+ 				`Log file stream finished writing and closed.`,
  			);
  		});
```

```diff
  	// If the process was explicitly stopped, don't treat it as a crash
  	if (status === "stopping") {
- 		updateProcessStatus(label, "stopped", { code, signal });
+ 		updateProcessStatus(compositeKey, "stopped", { code, signal });
  	} else if (status !== "stopped" && status !== "error") {
  		// Any other unexpected exit is treated as a crash
- 		updateProcessStatus(label, "crashed", { code, signal });
+ 		updateProcessStatus(compositeKey, "crashed", { code, signal });
  		// Don't retry immediately here, let checkAndUpdateProcessStatus or explicit restart handle it
  		// Check if retry is configured and appropriate
```

```diff
  		) {
  			// Use void to explicitly ignore the promise for fire-and-forget
- 			void handleCrashAndRetry(label);
+ 			void handleCrashAndRetry(compositeKey);
  		} else {
- 			log.info(label, "Process crashed, but no retry configured.");
- 			addLogEntry(label, "Process crashed. No retry configured.");
+ 			log.info(processInfo.label, "Process crashed, but no retry configured.");
+ 			addLogEntry(compositeKey, "Process crashed. No retry configured.");
  		}
  	} else {
  		log.info(
- 			label,
+ 			processInfo.label,
  			`Process exited but was already in state ${status}. No status change.`,
  		);
```

```diff
  }
  
- // Renamed function
- export async function checkAndUpdateProcessStatus(
- 	label: string,
+ // Check status using composite key
+ export async function checkAndUpdateProcessStatusByKey(
+ 	compositeKey: string,
  ): Promise<ProcessInfo | null> {
- 	const processInfo = managedProcesses.get(label);
+ 	const processInfo = managedProcesses.get(compositeKey);
  	if (!processInfo) {
  		return null;
```

```diff
  		if (!doesProcessExist(processInfo.pid)) {
  			log.warn(
- 				label,
- 				`Correcting status: Process PID ${processInfo.pid} not found, but status was '${processInfo.status}'. Marking as crashed.`,
+ 				processInfo.label,
+ 				`Correcting status: PID ${processInfo.pid} not found, but status was '${processInfo.status}'. Marking as crashed. (Key: ${compositeKey.substring(0, 50)}...)`,
  			);
  			addLogEntry(
- 				label,
+ 				compositeKey,
  				`Detected process PID ${processInfo.pid} no longer exists.`,
  			);
  			// Treat as a crash if it disappeared unexpectedly
- 			updateProcessStatus(label, "crashed", { code: -1, signal: null }); // Use a conventional code for "disappeared"
+ 			updateProcessStatus(compositeKey, "crashed", { code: -1, signal: null }); // Use a conventional code for "disappeared"
  			// Trigger retry if configured
  			if (
```

```diff
  				processInfo.retryDelayMs !== undefined
  			) {
- 				void handleCrashAndRetry(label); // Fire and forget retry
+ 				void handleCrashAndRetry(compositeKey); // Fire and forget retry
  			}
  		}
```

```diff
  }
  
- // --- Zombie Process Handling ---
- 
+ // Check status by label (handles ambiguity)
+ export async function checkAndUpdateProcessStatusByLabel(
+ 	label: string,
+ ): Promise<ProcessInfo | null> {
+ 	try {
+ 		const [compositeKey, processInfo] = findProcessByLabel(label);
+ 		// Now that we have the unique key, check the OS process status
+ 		return await checkAndUpdateProcessStatusByKey(compositeKey);
+ 	} catch (error) {
+ 		log.warn(label, `Status check failed: ${error.message}`);
+ 		return null; // Indicate not found or ambiguity error occurred
+ 	}
+ }
+ 
+ // Zombie check iterates through the map, using the composite key
  export async function reapZombies(): Promise<void> {
  	log.debug(null, "Running zombie process check...");
  	let correctedCount = 0;
- 	for (const [label, processInfo] of managedProcesses.entries()) {
- 		if (
- 			processInfo.pid &&
- 			(processInfo.status === "running" ||
- 				processInfo.status === "starting" ||
- 				processInfo.status === "verifying" ||
- 				processInfo.status === "restarting")
- 		) {
- 			if (!doesProcessExist(processInfo.pid)) {
- 				log.warn(
- 					label,
- 					`Correcting status via zombie check: Process PID ${processInfo.pid} not found, but status was '${processInfo.status}'. Marking as crashed.`,
- 				);
- 				addLogEntry(
- 					label,
- 					`Zombie check detected process PID ${processInfo.pid} no longer exists.`,
- 				);
- 				updateProcessStatus(label, "crashed", { code: -1, signal: null });
- 				correctedCount++;
- 				// Trigger retry if configured
- 				if (
- 					processInfo.maxRetries !== undefined &&
- 					processInfo.maxRetries > 0 &&
- 					processInfo.retryDelayMs !== undefined
- 				) {
- 					void handleCrashAndRetry(label); // Fire and forget retry
- 				}
- 			}
+ 	// Iterate using compositeKey
+ 	for (const [compositeKey, processInfo] of managedProcesses.entries()) {
+ 		// Use checkAndUpdateProcessStatusByKey internally
+ 		const potentiallyUpdatedInfo = await checkAndUpdateProcessStatusByKey(
+ 			compositeKey,
+ 		);
+ 		// Check if the status *was* corrected to crashed by the check function
+ 		if (
+ 			potentiallyUpdatedInfo &&
+ 			potentiallyUpdatedInfo.status === "crashed" &&
+ 			processInfo.status !== "crashed" // Compare with original status from map iteration
+ 		) {
+ 			correctedCount++;
+ 			// Retry logic is already handled within checkAndUpdateProcessStatusByKey/handleCrashAndRetry
  		}
  	}
```

```diff
  }
  
- // --- Graceful Shutdown ---
- 
+ // Stop all iterates through the map, using the composite key
  export function stopAllProcessesOnExit(): void {
  	log.info(null, "Stopping all managed processes on exit...");
  	const stopPromises: Promise<void>[] = [];
  
- 	managedProcesses.forEach((processInfo, label) => {
+ 	// Iterate using compositeKey
+ 	managedProcesses.forEach((processInfo, compositeKey) => {
  		log.info(
- 			label,
- 			`Attempting to stop process ${label} (PID: ${processInfo.pid})...`,
+ 			processInfo.label, // Log with user label
+ 			`Attempting to stop process (PID: ${processInfo.pid}, Key: ${compositeKey.substring(0, 50)}...)...`,
  		);
  		if (processInfo.process && processInfo.pid) {
- 			updateProcessStatus(label, "stopping");
- 			// Create a promise for each stop operation
+ 			// Update status using composite key
+ 			updateProcessStatus(compositeKey, "stopping");
  			const stopPromise = new Promise<void>((resolve) => {
- 				// Add null check for pid
  				if (processInfo.pid) {
- 					// promisify(treeKill) expects only pid
  					killProcessTree(processInfo.pid)
- 						.then(() => {
- 							// Resolve after successful kill
- 							resolve();
- 						})
+ 						.then(() => resolve())
  						.catch((err: Error | null) => {
  							if (err) {
  								log.error(
- 									label,
- 									`Error stopping process tree for ${label}:`,
+ 									processInfo.label,
+ 									`Error stopping process tree for key ${compositeKey.substring(0, 50)}...:`,
  									err,
  								);
  							}
- 							// Resolve regardless of error to not block shutdown
  							resolve();
  						});
  				} else {
- 					log.warn(label, "Cannot kill process tree, PID is missing.");
- 					resolve(); // Resolve anyway
+ 					log.warn(
+ 						processInfo.label,
+ 						"Cannot kill process tree, PID is missing.",
+ 					);
+ 					resolve();
  				}
  			});
  			stopPromises.push(stopPromise);
  		} else {
- 			log.warn(label, `Process ${label} has no active process or PID to stop.`);
+ 			log.warn(
+ 				processInfo.label,
+ 				`Process has no active process or PID to stop.`,
+ 			);
  		}
  
  		// --- Close Log Stream on Shutdown ---
  		if (processInfo.logFileStream) {
  			log.info(
- 				label,
- 				`Closing log stream for ${label} during server shutdown.`,
+ 				processInfo.label,
+ 				`Closing log stream during server shutdown.`,
  			);
  			processInfo.logFileStream.end();
```

```diff
  }
  
- export function removeProcess(label: string): void {
- 	const processInfo = managedProcesses.get(label);
+ // Remove process using composite key
+ export function removeProcess(compositeKey: string): void {
+ 	const processInfo = managedProcesses.get(compositeKey);
  	// The try...catch block was here, but the try was empty.
  	// If cleanup logic is needed for processInfo.process, it should go here.
- 	managedProcesses.delete(label);
- 	log.debug(label, "Removed process info from management.");
+ 	managedProcesses.delete(compositeKey);
+ 	log.debug(
+ 		processInfo?.label, // Use label if available
+ 		`Removed process info from management (Key: ${compositeKey.substring(0, 50)}...).`,
+ 	);
  }
  
  export function isZombieCheckActive(): boolean {
  	return !!zombieCheckIntervalId;
  }
+ 
+ // Export the findProcessByLabel helper for use in processLogic
+ export { findProcessByLabel };
  
```

---

Updating `src/processLogic.ts` to use composite keys internally and handle label lookups.

---

```diff
  import {
  	addLogEntry,
- 	checkAndUpdateProcessStatus, // Renamed function
+ 	checkAndUpdateProcessStatusByKey, // Use the key-based checker
+ 	checkAndUpdateProcessStatusByLabel, // Keep for convenience if needed elsewhere, but prefer key
+ 	findProcessByLabel, // Import the label finder
  	handleExit, // Corrected type in state.ts handleExit
  	managedProcesses, // Renamed map
```

```diff
  import { formatLogsForResponse, log } from "./utils.js";
  import { sanitizeLabelForFilename } from "./utils.js"; // Import sanitizer
+ import { generateCompositeKey } from "./utils.js"; // Import key generator
  
  const killProcessTree = promisify(treeKill);
```

```diff
  /**
   * Internal function to start a background process.
-  * Handles process spawning, logging, status updates, verification, and retries.
+  * Uses a composite key internally.
   */
  export async function _startProcess(
- 	label: string,
+ 	label: string, // User-facing label
  	command: string,
- 	args: string[], // Added args
+ 	args: string[],
  	workingDirectoryInput: string | undefined,
- 	verificationPattern: RegExp | undefined, // Added verification pattern
- 	verificationTimeoutMs: number | undefined, // Added verification timeout
- 	retryDelayMs: number | undefined, // Added retry delay
- 	maxRetries: number | undefined, // Added max retries
- 	isRestart = false, // Flag to indicate if this is a restart
+ 	verificationPattern: RegExp | undefined,
+ 	verificationTimeoutMs: number | undefined,
+ 	retryDelayMs: number | undefined,
+ 	maxRetries: number | undefined,
+ 	isRestart = false,
  ): Promise<CallToolResult> {
  	const effectiveWorkingDirectory = workingDirectoryInput
  		? path.resolve(workingDirectoryInput)
  		: process.env.MCP_WORKSPACE_ROOT || process.cwd();
  
- 	log.info(
+ 	// Generate the internal composite key
+ 	const compositeKey = generateCompositeKey(
  		label,
- 		`Starting process... Command: "${command}", Args: [${args.join(", ")}], CWD: "${effectiveWorkingDirectory}", isRestart: ${isRestart}`,
+ 		command,
+ 		effectiveWorkingDirectory,
+ 		args,
+ 	);
+ 
+ 	log.info(
+ 		label, // Log with user label
+ 		`Starting process... Command: "${command}", Args: [${args.join(", ")}], CWD: "${effectiveWorkingDirectory}", isRestart: ${isRestart}. (Internal Key: ${compositeKey.substring(0, 50)}...)`,
  	);
  
```

```diff
  		const errorMsg = `Working directory does not exist: ${effectiveWorkingDirectory}`;
  		log.error(label, errorMsg);
- 		// Ensure an entry exists if this is the first attempt
- 		if (!managedProcesses.has(label)) {
- 			managedProcesses.set(label, {
- 				label,
+ 		if (!managedProcesses.has(compositeKey)) {
+ 			// Temporary entry for error state tracking
+ 			managedProcesses.set(compositeKey, {
+ 				label, // Store the user-facing label
+ 				compositeKey, // Store the key itself
  				command,
  				args,
```

```diff
  				signal: null,
  				verificationPattern,
- 				verificationTimeoutMs,
- 				retryDelayMs,
- 				maxRetries,
+ 				verificationTimeoutMs: verificationTimeoutMs ?? null,
+ 				retryDelayMs: retryDelayMs ?? null,
+ 				maxRetries: maxRetries ?? 0,
  				logFilePath: null,
  				logFileStream: null,
  			});
  		}
- 		updateProcessStatus(label, "error"); // Simplified update
+ 		updateProcessStatus(compositeKey, "error");
  		return fail(
  			textPayload(
  				JSON.stringify({
  					error: errorMsg,
  					status: "error",
+ 					error_type: "cwd_not_found",
+ 					label: label,
  					cwd: effectiveWorkingDirectory,
- 					error_type: "working_directory_not_found",
  				}),
  			),
```

```diff
  	log.debug(label, "Working directory verified.");
  
- 	const existingProcess = managedProcesses.get(label);
- 
- 	// Check for active conflict based on label, cwd, and command
- 	if (!isRestart) {
- 		for (const existing of managedProcesses.values()) {
- 			if (
- 				existing.label === label &&
- 				existing.cwd === effectiveWorkingDirectory &&
- 				existing.command === command &&
- 				["starting", "running", "verifying", "restarting", "stopping"].includes(
- 					existing.status,
- 				)
- 			) {
- 				const errorMsg = `An active process with the same label ('${label}'), working directory ('${effectiveWorkingDirectory}'), and command ('${command}') already exists with status '${existing.status}' (PID: ${existing.pid}). Stop the existing process or use a different label.`;
- 				log.error(label, errorMsg);
- 				return fail(
- 					textPayload(
- 						JSON.stringify({
- 							error: errorMsg,
- 							status: existing.status,
- 							error_type: "composite_label_conflict",
- 						}),
- 					),
- 				);
- 			}
- 		}
+ 	// Check for conflict using the composite key
+ 	const existingProcessInfo = managedProcesses.get(compositeKey);
+ 	if (
+ 		existingProcessInfo &&
+ 		!isRestart &&
+ 		["starting", "running", "verifying", "restarting", "stopping"].includes(
+ 			existingProcessInfo.status,
+ 		)
+ 	) {
+ 		const errorMsg = `An active process with the exact same label ('${label}'), working directory ('${effectiveWorkingDirectory}'), command ('${command}'), and arguments ('${args.join(" ")}') already exists with status '${existingProcessInfo.status}' (PID: ${existingProcessInfo.pid}). Stop the existing process first.`;
+ 		log.error(label, errorMsg);
+ 		return fail(
+ 			textPayload(
+ 				JSON.stringify({
+ 					error: errorMsg,
+ 					status: existingProcessInfo.status,
+ 					error_type: "exact_process_conflict", // More specific error type
+ 					label: label,
+ 					command: command,
+ 					args: args,
+ 					cwd: effectiveWorkingDirectory,
+ 				}),
+ 			),
+ 		);
  	}
  
- 	// If only label matches and not restarting, warn about reusing label but allow it if cwd/command differ
- 	if (
- 		!isRestart &&
- 		existingProcess &&
- 		existingProcess.label === label && // Check label again
- 		(existingProcess.cwd !== effectiveWorkingDirectory ||
- 			existingProcess.command !== command) &&
- 		["starting", "running", "verifying", "restarting", "stopping"].includes(
- 			existingProcess.status,
- 		)
- 	) {
- 		log.warn(
- 			label,
- 			`Reusing label "${label}" but with a different command/cwd. Previous instance (status: ${existingProcess.status}, cwd: ${existingProcess.cwd}, cmd: ${existingProcess.command}) will remain active. Ensure labels are distinct if managing truly different processes.`,
- 		);
- 		// No longer clearing old state here, as we allow multiple processes with same label if cwd/cmd differ
- 	} else if (isRestart) {
- 		log.info(label, `Restarting process "${label}".`);
- 	}
+ 	// If label matches BUT other components differ, it's not a conflict for *this* start request,
+ 	// but the user should be aware if they try to interact using just the label later.
+ 	// We don't need a specific warning here anymore, as the ambiguity check handles it during interaction.
  
  	const shell =
  		process.env.SHELL || (process.platform === "win32" ? "cmd.exe" : "bash");
  	let ptyProcess: pty.IPty;
- 	const fullCommand = [command, ...args].join(" "); // Combine command and args for PTY
+ 	const fullCommand = [command, ...args].join(" ");
  
  	// --- Log File Setup ---
```

```diff
  				log.error(label, `Error writing to log file ${logFilePath}:`, err);
  				// Optionally try to close/nullify the stream here?
- 				if (managedProcesses.has(label)) {
- 					const info = managedProcesses.get(label);
+ 				if (managedProcesses.has(compositeKey)) {
+ 					const info = managedProcesses.get(compositeKey);
  					if (info) {
  						info.logFileStream?.end(); // Attempt to close
```

```diff
  			);
  			addLogEntry(
- 				label,
+ 				compositeKey,
  				`--- Process Started (${new Date().toISOString()}) ---`,
  			); // Add start marker to file too
```

```diff
  				FORCE_COLOR: "1",
  				MCP_PROCESS_LABEL: label, // Updated Env Var Name
+ 				MCP_PROCESS_KEY_HASH: compositeKey.substring(0, 10), // Maybe add partial key hash? Optional.
  			},
  			encoding: "utf8",
```

```diff
  		const errorMsg = `Failed to spawn PTY process: ${error instanceof Error ? error.message : String(error)}`;
  		log.error(label, errorMsg);
- 		if (!managedProcesses.has(label)) {
- 			managedProcesses.set(label, {
+ 		if (!managedProcesses.has(compositeKey)) {
+ 			managedProcesses.set(compositeKey, {
  				label,
+ 				compositeKey,
  				command,
  				args,
```

```diff
  				signal: null,
  				verificationPattern,
- 				verificationTimeoutMs,
- 				retryDelayMs,
- 				maxRetries,
+ 				verificationTimeoutMs: verificationTimeoutMs ?? null,
+ 				retryDelayMs: retryDelayMs ?? null,
+ 				maxRetries: maxRetries ?? 0,
  				logFilePath: null,
  				logFileStream: null,
  			});
  		}
- 		updateProcessStatus(label, "error");
+ 		updateProcessStatus(compositeKey, "error");
  		logFileStream?.end(); // Close stream if spawn fails
  		return fail(
```

```diff
  					error: errorMsg,
  					status: "error",
- 					cwd: effectiveWorkingDirectory,
  					error_type: "pty_spawn_failed",
+ 					label: label,
  				}),
  			),
```

```diff
  	const processInfo: ProcessInfo = {
  		label,
+ 		compositeKey,
  		pid: ptyProcess.pid,
  		process: ptyProcess,
  		command,
  		args,
  		cwd: effectiveWorkingDirectory,
- 		logs: existingProcess && isRestart ? existingProcess.logs : [], // Preserve logs on restart
+ 		logs: existingProcessInfo && isRestart ? existingProcessInfo.logs : [], // Preserve logs on restart
  		status: "starting",
  		exitCode: null,
  		signal: null,
- 		lastCrashTime: existingProcess?.lastCrashTime, // Preserve crash time on restart
- 		restartAttempts: existingProcess?.restartAttempts, // Preserve attempts on restart
+ 		lastCrashTime: existingProcessInfo?.lastCrashTime, // Preserve crash time on restart
+ 		restartAttempts: existingProcessInfo?.restartAttempts, // Preserve attempts on restart
  		verificationPattern,
  		verificationTimeoutMs: verificationTimeoutMs ?? null, // Default to null (disabled)
```

```diff
  		logFileStream: logFileStream, // <-- STORED
  	};
- 	managedProcesses.set(label, processInfo);
- 	updateProcessStatus(label, "starting"); // Ensure status is set via the function
+ 	managedProcesses.set(compositeKey, processInfo);
+ 	updateProcessStatus(compositeKey, "starting"); // Ensure status is set via the function
  	addLogEntry(
- 		label,
+ 		compositeKey,
  		`Process spawned successfully (PID: ${ptyProcess.pid}) in ${effectiveWorkingDirectory}. Status: starting.`,
  	);
```

```diff
  			`Verification required: Pattern /${verificationPattern.source}/, ${timeoutMessage}`,
  		);
- 		addLogEntry(label, "Status: verifying. Waiting for pattern or timeout.");
- 		updateProcessStatus(label, "verifying");
+ 		addLogEntry(compositeKey, "Status: verifying. Waiting for pattern or timeout.");
+ 		updateProcessStatus(compositeKey, "verifying");
  
  		const dataListener = (data: string): void => {
```

```diff
  		// For simplicity, let's mark as running immediately if no pattern
  		log.info(label, "No verification pattern provided. Marking as running.");
- 		addLogEntry(label, "Status: running (no verification specified).");
- 		updateProcessStatus(label, "running");
+ 		addLogEntry(compositeKey, "Status: running (no verification specified).");
+ 		updateProcessStatus(compositeKey, "running");
  		isVerified = true;
  	}
```

```diff
  		for (const line of lines) {
  			if (line.trim()) {
- 				addLogEntry(label, line); // Store raw log line
+ 				addLogEntry(compositeKey, line); // Store raw log line
  			}
  		}
```

```diff
  
  		// Get fresh info before calling handleExit
- 		const currentInfo = managedProcesses.get(label);
+ 		const currentInfo = managedProcesses.get(compositeKey);
  		if (currentInfo && currentInfo.status !== "verifying") {
  			// Avoid double handling if verification exit listener ran
  			handleExit(
- 				label,
+ 				compositeKey,
  				exitCode ?? null,
  				signal !== undefined ? String(signal) : null,
```

```diff
  
  	// --- Final Return ---
- 	const currentInfoAfterWait = await checkAndUpdateProcessStatus(label); // Use check function
+ 	const currentInfoAfterWait = await checkAndUpdateProcessStatusByKey(compositeKey); // Use check function
  
  	if (!currentInfoAfterWait) {
  		// Process might have exited very quickly and been removed, or internal error
- 		const errorMsg = `Internal error: Process info for "${label}" not found after startup wait.`;
+ 		const errorMsg = `Internal error: Process info for key "${compositeKey.substring(0, 50)}..." not found after startup wait.`;
  		log.error(label, errorMsg);
  		return fail(
```

```diff
  /**
   * Internal function to stop a background process.
-  * Handles both graceful termination (SIGTERM) and forceful kill (SIGKILL).
+  * Finds the process by label and handles ambiguity.
   */
  export async function _stopProcess(
- 	label: string,
+ 	label: string, // User-provided label
  	force = false,
  ): Promise<CallToolResult> {
  	log.info(label, `Attempting to stop process "${label}" (force=${force})...`);
- 	const processInfo = await checkAndUpdateProcessStatus(label);
- 
- 	if (!processInfo) {
+ 
+ 	let compositeKey: string;
+ 	let processInfo: ProcessInfo | null;
+ 
+ 	try {
+ 		// Find the unique composite key and info using the label
+ 		const [foundKey, initialInfo] = findProcessByLabel(label);
+ 		compositeKey = foundKey;
+ 		// Get potentially updated status using the found key
+ 		processInfo = await checkAndUpdateProcessStatusByKey(compositeKey);
+ 	} catch (error) {
+ 		// Ambiguity or not found error from findProcessByLabel
+ 		log.error(label, `Stop failed: ${error.message}`);
  		return fail(
  			textPayload(
  				JSON.stringify({
- 					error: `Process with label "${label}" not found.`,
- 					status: "not_found",
- 					error_type: "not_found",
+ 					error: error.message,
+ 					status: error.message.includes("ambiguous") ? "ambiguous_label" : "not_found",
+ 					error_type: error.message.includes("ambiguous") ? "ambiguous_label" : "not_found",
  				}),
  			),
  		);
  	}
  
+ 	// We should have processInfo if findProcessByLabel succeeded, but double-check
+ 	if (!processInfo) {
+ 		// This case should ideally be caught by findProcessByLabel or checkByKey
+ 		const errorMsg = `Process with label "${label}" found initially but disappeared before stop.`;
+ 		log.error(label, errorMsg);
+ 		return fail(
+ 			textPayload(
+ 				JSON.stringify({ error: errorMsg, status: "not_found", error_type: "disappeared" }),
+ 			),
+ 		);
+ 	}
+ 
+ 	// Now proceed with stopping using processInfo and compositeKey
  	if (
  		["stopped", "crashed", "error"].includes(processInfo.status) &&
- 		!processInfo.pid
+ 		!processInfo.pid // Check PID specifically
  	) {
- 		log.warn(
- 			label,
- 			`Process is already terminal (${processInfo.status}) with no active PID.`,
- 		);
+ 		log.warn(label, `Process is already terminal (${processInfo.status}).`);
  		return ok(
  			textPayload(
  				JSON.stringify({
- 					message: `Process "${label}" was already ${processInfo.status}.`,
+ 					message: `Process "${label}" was already in terminal state (${processInfo.status}).`,
  					status: processInfo.status,
- 					pid: processInfo.pid, // null or undefined
- 					cwd: processInfo.cwd,
- 					exitCode: processInfo.exitCode,
- 					signal: processInfo.signal,
- 					// Map LogEntry[] to string[]
- 					logs: formatLogsForResponse(
- 						processInfo.logs.map((l: LogEntry) => l.content),
- 						DEFAULT_LOG_LINES,
- 					),
+ 					label: label,
  				}),
  			),
```

```diff
  
  	if (!processInfo.process || !processInfo.pid) {
- 		const errorMsg = `Cannot stop process: handle or PID is missing despite status being ${processInfo.status}. Attempting to mark as error.`;
+ 		// ... (handle missing handle/PID - use compositeKey for status update) ...
+ 		const errorMsg = `Cannot stop: Handle/PID missing (Status: ${processInfo.status}).`;
  		log.error(label, errorMsg);
- 		updateProcessStatus(label, "error"); // Mark as error
+ 		updateProcessStatus(compositeKey, "error"); // Use key
  		return fail(
  			textPayload(
  				JSON.stringify({
  					error: errorMsg,
  					status: "error",
- 					error_type: "missing_handle_on_stop",
- 					pid: processInfo.pid,
- 					cwd: processInfo.cwd,
- 					// Map LogEntry[] to string[]
- 					logs: formatLogsForResponse(
- 						processInfo.logs.map((l: LogEntry) => l.content),
- 						DEFAULT_LOG_LINES,
- 					),
+ 					error_type: "missing_handle_or_pid",
+ 					label: label,
  				}),
  			),
```

```diff
  		clearTimeout(processInfo.verificationTimer);
  		processInfo.verificationTimer = undefined;
- 		log.info(label, "Cleared verification timer during stop request.");
+ 		log.info(label, "Cleared verification timer during stop.");
  	}
  
  	const signal: "SIGTERM" | "SIGKILL" = force ? "SIGKILL" : "SIGTERM";
- 	log.info(label, `Sending ${signal} to process PID ${processInfo.pid}...`);
- 	addLogEntry(label, `Sending ${signal} signal.`);
- 	updateProcessStatus(label, "stopping");
+ 	log.info(label, `Sending ${signal} to PID ${processInfo.pid}...`);
+ 	// Use composite key for logging and status updates
+ 	addLogEntry(compositeKey, `Sending ${signal} signal.`);
+ 	updateProcessStatus(compositeKey, "stopping");
  
  	try {
- 		// Use the node-pty kill method
  		processInfo.process.kill(signal);
  	} catch (error: unknown) {
- 		const errorMsg = `Failed to send ${signal} to PID ${processInfo.pid}: ${error instanceof Error ? error.message : String(error)}`;
+ 		// ... (handle signal send failure - use compositeKey for check/update) ...
+ 		const errorMsg = `Failed to send ${signal}: ${error instanceof Error ? error.message : String(error)}`;
  		log.error(label, errorMsg);
- 		addLogEntry(label, `Error sending signal: ${errorMsg}`);
- 
- 		// Check status again after failed signal
- 		const postSignalCheck = await checkAndUpdateProcessStatus(label);
+ 		addLogEntry(compositeKey, `Error sending signal: ${errorMsg}`);
+ 		const postSignalCheck = await checkAndUpdateProcessStatusByKey(compositeKey); // Use key
  		const currentStatus = postSignalCheck?.status ?? processInfo.status;
- 		const finalError = `Failed to send ${signal}. Status: ${currentStatus}. Error: ${errorMsg}`;
- 
  		if (currentStatus !== "stopped" && currentStatus !== "crashed") {
- 			updateProcessStatus(label, "error"); // Mark as error if signal failed and not already terminal
+ 			updateProcessStatus(compositeKey, "error"); // Use key
  		}
- 
  		return fail(
  			textPayload(
  				JSON.stringify({
- 					error: finalError,
- 					status: postSignalCheck?.status ?? "error", // Reflect updated status
+ 					error: errorMsg,
+ 					status: currentStatus,
  					error_type: "signal_send_failed",
- 					pid: processInfo.pid,
- 					cwd: processInfo.cwd,
- 					// Map LogEntry[] to string[]
- 					logs: formatLogsForResponse(
- 						(postSignalCheck?.logs ?? processInfo.logs).map(
- 							(l: LogEntry) => l.content,
- 						),
- 						DEFAULT_LOG_LINES,
- 					),
+ 					label: label,
  				}),
  			),
  		);
  	}
  
- 	// Stop initiated, let onExit handler manage the final state transition.
- 	// Return an intermediate success indicating the stop command was sent.
- 
- 	const currentProcessInfo = managedProcesses.get(label) as ProcessInfo; // Should exist
+ 	// Stop initiated, let onExit handle final state via compositeKey
+ 	const currentProcessInfo = managedProcesses.get(compositeKey); // Get fresh info
  	return ok(
  		textPayload(
  			JSON.stringify(
  				{
- 					message: `Stop signal (${signal}) sent to process "${label}" (PID: ${currentProcessInfo.pid}).`,
- 					status: currentProcessInfo.status, // Should be 'stopping'
- 					pid: currentProcessInfo.pid,
- 					cwd: currentProcessInfo.cwd,
- 					// Map LogEntry[] to string[]
+ 					message: `Stop signal (${signal}) sent to process "${label}" (PID: ${processInfo.pid}).`,
+ 					status: currentProcessInfo?.status ?? "stopping", // Reflect current status
+ 					label: label,
+ 					pid: processInfo.pid,
+ 					cwd: processInfo.cwd,
  					logs: formatLogsForResponse(
- 						currentProcessInfo.logs.map((l) => l.content),
+ 						(currentProcessInfo?.logs ?? processInfo.logs).map((l) => l.content),
  						DEFAULT_LOG_LINES,
  					),
- 					monitoring_hint:
- 						"Process is stopping. Use check_process_status for final status.",
+ 					monitoring_hint: "Use check_process_status for final status.",
  				},
  				null,
```

```diff
  /**
   * Internal function to send input to a running background process.
+  * Finds the process by label and handles ambiguity.
   */
  export async function _sendInput(
- 	params: z.infer<typeof SendInputParams>, // Use inferred type from Zod schema
+ 	params: z.infer<typeof SendInputParams>,
  ): Promise<CallToolResult> {
  	const { label, input, append_newline } = params;
  	log.info(label, `Attempting to send input to process "${label}"...`);
  
- 	// Use checkAndUpdateProcessStatus to get potentially updated info
- 	const processInfo = await checkAndUpdateProcessStatus(label);
- 
- 	if (!processInfo) {
+ 	let compositeKey: string;
+ 	let processInfo: ProcessInfo | null;
+ 
+ 	try {
+ 		// Find the unique composite key and info using the label
+ 		const [foundKey, initialInfo] = findProcessByLabel(label);
+ 		compositeKey = foundKey;
+ 		// Get potentially updated status using the found key
+ 		processInfo = await checkAndUpdateProcessStatusByKey(compositeKey);
+ 	} catch (error) {
+ 		// Ambiguity or not found error
+ 		log.error(label, `Send input failed: ${error.message}`);
  		return fail(
  			textPayload(
  				JSON.stringify({
- 					error: `Process with label "${label}" not found.`,
- 					status: "not_found",
- 					error_type: "not_found",
+ 					error: error.message,
+ 					status: error.message.includes("ambiguous") ? "ambiguous_label" : "not_found",
+ 					error_type: error.message.includes("ambiguous") ? "ambiguous_label" : "not_found",
  				}),
  			),
  		);
  	}
  
- 	// Check if the process is in a state that can receive input
+ 	// Should have processInfo here
+ 	if (!processInfo) {
+ 		const errorMsg = `Process "${label}" disappeared before sending input.`;
+ 		log.error(label, errorMsg);
+ 		return fail(
+ 			textPayload(
+ 				JSON.stringify({ error: errorMsg, status: "not_found", error_type: "disappeared" }),
+ 			),
+ 		);
+ 	}
+ 
+ 	// Check state using processInfo
  	const allowedStates: ProcessStatus[] = ["running", "verifying", "starting"];
  	if (!allowedStates.includes(processInfo.status)) {
- 		const errorMsg = `Process "${label}" is not in a state to receive input. Current status: ${processInfo.status}. Required status: ${allowedStates.join(" or ")}.`;
+ 		const errorMsg = `Process "${label}" is not ready for input (Status: ${processInfo.status}).`;
  		log.warn(label, errorMsg);
  		return fail(
```

```diff
  					status: processInfo.status,
  					error_type: "invalid_state_for_input",
- 					pid: processInfo.pid,
- 					cwd: processInfo.cwd,
+ 					label: label,
  				}),
  			),
```

```diff
  
  	if (!processInfo.process) {
- 		const errorMsg = `Cannot send input: Process handle is missing for "${label}" despite status being ${processInfo.status}.`;
+ 		const errorMsg = `Cannot send input: Process handle missing (Status: ${processInfo.status}).`;
  		log.error(label, errorMsg);
- 		// Consider updating status to 'error' here? Might be too aggressive.
  		return fail(
  			textPayload(
  				JSON.stringify({
  					error: errorMsg,
- 					status: processInfo.status, // Report current status
- 					error_type: "missing_handle_on_input",
- 					pid: processInfo.pid,
- 					cwd: processInfo.cwd,
+ 					status: processInfo.status,
+ 					error_type: "missing_handle",
+ 					label: label,
  				}),
  			),
```

```diff
  
  	try {
- 		const dataToSend = input + (append_newline ? "\\r" : "");
- 		log.debug(label, `Writing to PTY: "${dataToSend.replace("\\r", "\r")}"`); // Log escaped newline
+ 		const dataToSend = input + (append_newline ? "\r" : ""); // Use \r for PTY Enter
+ 		log.debug(label, `Writing to PTY: "${dataToSend.replace("\r", "<CR>")}"`);
  
- 		// Send the input via the node-pty process handle
  		processInfo.process.write(dataToSend);
  
- 		// Log the action internally for the process
  		const logMessage = `Input sent: "${input}"${append_newline ? " (with newline)" : ""}`;
- 		addLogEntry(label, logMessage);
+ 		// Use composite key for logging
+ 		addLogEntry(compositeKey, logMessage);
  		log.info(label, logMessage);
  
```

```diff
  				JSON.stringify(
  					{
- 						message: `Input successfully sent to process "${label}".`,
+ 						message: `Input sent to process "${label}".`,
  						input_sent: input,
  						newline_appended: append_newline,
- 						status: processInfo.status, // Return current status after sending
+ 						status: processInfo.status,
+ 						label: label,
  						pid: processInfo.pid,
  					},
```

```diff
  		);
  	} catch (error: unknown) {
- 		const errorMsg = `Failed to write input to process "${label}": ${error instanceof Error ? error.message : String(error)}`;
+ 		const errorMsg = `Failed to write input: ${error instanceof Error ? error.message : String(error)}`;
  		log.error(label, errorMsg, error);
- 		addLogEntry(label, `Error sending input: ${errorMsg}`);
- 		// Don't change process status here, as the process itself might still be running
+ 		// Use composite key for logging
+ 		addLogEntry(compositeKey, `Error sending input: ${errorMsg}`);
  		return fail(
  			textPayload(
- 				JSON.stringify(
- 					{
- 						error: errorMsg,
- 						status: processInfo.status, // Report status at time of error
- 						error_type: "write_failed",
- 						pid: processInfo.pid,
- 					},
- 					null,
- 					2,
- 				),
+ 				JSON.stringify({
+ 					error: errorMsg,
+ 					status: processInfo.status,
+ 					error_type: "write_failed",
+ 					label: label,
+ 				}),
  			),
  		);
```

---

Updating `src/toolDefinitions.ts` to refine auto-generated labels and use the new state/logic functions.

---

Cancelled

---



---

_**User**_

Please continue. 
Your task it to follow these instructions to completion without asking for my input.
Try, fail, learn, iterate, all without asking for my help (unless it's a destructive action.)

Please run `npm run build && npm run lint:fix` before each step to verify your previous work hasn't broken anything

---

_**Assistant**_



---

Okay, I will continue applying the changes. First, I'll run the build and lint commands to ensure the previous changes haven't introduced issues.

---

```bash
pnpm run build && pnpm run lint:fix
```

```

> mcp-pm@0.0.0-placeholder build /Users/johnlindquist/dev/mcp-dev-server
> tsc && node -e "require('fs').chmodSync('build/index.js', '755')"

src/processLogic.ts:172:5 - error TS2353: Object literal may only specify known
properties, and 'compositeKe
y' does not exist in type 'ProcessInfo'.
                            
172     compositeKey, // Store the key itself
        ~~~~~~~~~~~~

src/processLogic.ts:311:5 - error TS2353: Object literal may only specify known
properties, and 'compositeKe
y' does not exist in type 'ProcessInfo'.
                            
311     compositeKey,
        ~~~~~~~~~~~~

src/processLogic.ts:346:3 - error TS2353: Object literal may only specify known
properties, and 'compositeKe
y' does not exist in type 'ProcessInfo'.
                            
346   compositeKey,
      ~~~~~~~~~~~~

src/processLogic.ts:643:36 - error TS18046: 'error' is of type 'unknown'.

643   log.error(label, `Stop failed: ${error.message}`);
                                       ~~~~~

src/processLogic.ts:647:13 - error TS18046: 'error' is of type 'unknown'.

647      error: error.message,
                ~~~~~

src/processLogic.ts:648:14 - error TS18046: 'error' is of type 'unknown'.

648      status: error.message.includes("ambiguous") ? "ambiguous_label" : "not_
found",
                 ~~~~~

src/processLogic.ts:649:18 - error TS18046: 'error' is of type 'unknown'.

649      error_type: error.message.includes("ambiguous") ? "ambiguous_label" : "
not_found",
                     ~~~~~

src/processLogic.ts:783:42 - error TS18046: 'error' is of type 'unknown'.

783   log.error(label, `Send input failed: ${error.message}`);
                                             ~~~~~

src/processLogic.ts:787:13 - error TS18046: 'error' is of type 'unknown'.

787      error: error.message,
                ~~~~~

src/processLogic.ts:788:14 - error TS18046: 'error' is of type 'unknown'.

788      status: error.message.includes("ambiguous") ? "ambiguous_label" : "not_
found",
                 ~~~~~

src/processLogic.ts:789:18 - error TS18046: 'error' is of type 'unknown'.

789      error_type: error.message.includes("ambiguous") ? "ambiguous_label" : "
not_found",
                     ~~~~~

src/state.ts:147:4 - error TS2345: Argument of type 'string | undefined' is not
assignable to parameter of t
ype 'string | null'.
                              Type 'undefined' is not assignable to type 'string
 | null'.

147    processInfo?.label, // Use label if available
       ~~~~~~~~~~~~~~~~~~

src/state.ts:339:43 - error TS18046: 'error' is of type 'unknown'.

339   log.warn(label, `Status check failed: ${error.message}`);
                                              ~~~~~

src/state.ts:458:3 - error TS2345: Argument of type 'string | undefined' is not
assignable to parameter of t
ype 'string | null'.
                              Type 'undefined' is not assignable to type 'string
 | null'.

458   processInfo?.label, // Use label if available
      ~~~~~~~~~~~~~~~~~~

src/toolDefinitions.ts:215:28 - error TS2552: Cannot find name 'checkAndUpdatePr
ocessStatus'. Did you mean '
checkAndUpdateProcessStatusByKey'?
                            
215  const processInfo = await checkAndUpdateProcessStatus(label);
                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~

src/toolDefinitions.ts:266:29 - error TS2552: Cannot find name 'checkAndUpdatePr
ocessStatus'. Did you mean '
checkAndUpdateProcessStatusByKey'?
                            
266   const processInfo = await checkAndUpdateProcessStatus(label);
                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~

src/toolDefinitions.ts:320:29 - error TS2552: Cannot find name 'checkAndUpdatePr
ocessStatus'. Did you mean '
checkAndUpdateProcessStatusByKey'?
                            
320   const processInfo = await checkAndUpdateProcessStatus(label);
                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~

src/toolDefinitions.ts:375:28 - error TS2552: Cannot find name 'checkAndUpdatePr
ocessStatus'. Did you mean '
checkAndUpdateProcessStatusByKey'?
                            
375  const processInfo = await checkAndUpdateProcessStatus(label);
                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~

src/toolDefinitions.ts:455:28 - error TS2552: Cannot find name 'checkAndUpdatePr
ocessStatus'. Did you mean '
checkAndUpdateProcessStatusByKey'?
                            
455   const finalCheck = await checkAndUpdateProcessStatus(label);
                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~

src/toolDefinitions.ts:538:29 - error TS2552: Cannot find name 'checkAndUpdatePr
ocessStatus'. Did you mean '
checkAndUpdateProcessStatusByKey'?
                            
538   const processInfo = await checkAndUpdateProcessStatus(label);
                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~

src/toolDefinitions.ts:594:26 - error TS2552: Cannot find name 'checkAndUpdatePr
ocessStatus'. Did you mean '
checkAndUpdateProcessStatusByKey'?
                            
594  const finalInfo = await checkAndUpdateProcessStatus(label);
                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~

src/toolDefinitions.ts:663:29 - error TS2552: Cannot find name 'checkAndUpdatePr
ocessStatus'. Did you mean '
checkAndUpdateProcessStatusByKey'?
                            
663   const processInfo = await checkAndUpdateProcessStatus(label);
                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~


Found 22 errors in 3 files.

Errors  Files
    11  src/processLogic.ts:172
     3  src/state.ts:147
     8  src/toolDefinitions.ts:215
 ELIFECYCLE  Command failed with exit code 2.

```

---

Okay, the build failed with several TypeScript errors.

Most errors (`TS2353`) relate to the `compositeKey` not being defined in the `ProcessInfo` type yet. I need to apply the change to `src/types.ts` first.

Other errors (`TS18046`) are because caught `error` variables are of type `unknown` and need type checking before accessing properties like `.message`.

Errors (`TS2345`) indicate that `processInfo?.label` can be `undefined`, but the `log` function expects `string | null`. I need to handle the `undefined` case, likely by providing a default value or `null`.

Errors (`TS2552`) in `src/toolDefinitions.ts` are due to using the old function name `checkAndUpdateProcessStatus` instead of the new `checkAndUpdateProcessStatusByKey` or `checkAndUpdateProcessStatusByLabel`.

Let's fix these:
1.  Apply the change to `src/types.ts` to add `compositeKey`.
2.  Fix the type errors in `src/state.ts` and `src/processLogic.ts`.
3.  Fix the incorrect function calls in `src/toolDefinitions.ts`.
4.  Run `npm run build && npm run lint:fix` again.

Applying the change to `src/types.ts`.

---

```diff
   */
  export interface ProcessInfo {
- 	label: string; // User-defined identifier
- 	process: IPty | null; // The node-pty process instance
- 	command: string; // The command used to start the process
- 	args: string[]; // Arguments for the command
- 	cwd: string; // Working directory
- 	pid: number | undefined; // Process ID
- 	logs: LogEntry[]; // Ring buffer of recent log entries
+ 	label: string; // User-defined or generated identifier (user-facing)
+ 	compositeKey: string; // The internal unique key based on label, cmd, cwd, args
+ 	process: IPty | null;
+ 	command: string;
+ 	args: string[];
+ 	cwd: string;
+ 	pid: number | undefined;
+ 	logs: LogEntry[];
  	status: ProcessStatus;
  	exitCode: number | null;
  	signal: string | null;
- 	logFilePath: string | null; // Path to the persistent log file
- 	logFileStream: fs.WriteStream | null; // Writable stream for the log file
- 	lastCrashTime?: number; // Timestamp of the last crash
- 	restartAttempts?: number; // Number of restart attempts in the current crash loop window
- 	verificationPattern?: RegExp; // Optional pattern to verify successful startup
- 	verificationTimeoutMs?: number | null; // Timeout for verification (null means disabled)
- 	verificationTimer?: NodeJS.Timeout; // Timer for verification timeout
- 	retryDelayMs?: number | null; // Delay before restarting after a crash (null means disabled)
- 	maxRetries?: number; // Maximum restart attempts before marking as 'error'
+ 	logFilePath: string | null;
+ 	logFileStream: fs.WriteStream | null;
+ 	lastCrashTime?: number;
+ 	restartAttempts?: number;
+ 	verificationPattern?: RegExp;
+ 	verificationTimeoutMs?: number | null;
+ 	verificationTimer?: NodeJS.Timeout;
+ 	retryDelayMs?: number | null;
+ 	maxRetries?: number;
  }
  
```

```diff
  export type ProcessStatus =
  	| "starting"
- 	| "running" // Stable state, optionally after verification
+ 	| "running"
  	| "stopping"
- 	| "stopped" // Clean exit
- 	| "crashed" // Unexpected exit, potentially restarting
- 	| "error" // Unrecoverable error during start or operation
- 	| "verifying" // Optional state after process starts, before confirming 'running'
- 	| "restarting"; // Actively attempting to restart after a crash
+ 	| "stopped"
+ 	| "crashed"
+ 	| "error"
+ 	| "verifying"
+ 	| "restarting";
+ 
+ // --- Add new possible status values for responses ---
+ export type ProcessStatusWithError = ProcessStatus | "not_found" | "ambiguous_label";
  
```

---

Now, fixing the TypeScript errors in `src/state.ts` and `src/processLogic.ts`.

---

```diff
  	if (!processInfo || processInfo.status !== "crashed") {
  		log.warn(
- 			processInfo?.label, // Use label if available
+ 			processInfo?.label ?? null, // Use null if label is undefined
  			`handleCrashAndRetry called for non-crashed/missing process (Key: ${compositeKey.substring(0, 50)}...)`,
  		);
```

```diff
  	// --- Close Log Stream ---
  	if (processInfo.logFileStream) {
- 		log.debug(processInfo.label, `Closing log file stream due to exit.`);
+ 		log.debug(processInfo.label, "Closing log file stream due to exit.");
  		addLogEntry(
  			compositeKey,
  			`--- Process Exited (Code: ${code ?? "N/A"}, Signal: ${signal ?? "N/A"}) ---`,
- 		); // Log exit marker before closing
+ 		);
  		processInfo.logFileStream.end(() => {
  			log.debug(
  				processInfo.label,
- 				`Log file stream finished writing and closed.`,
+ 				"Log file stream finished writing and closed.",
  			);
  		});
  		processInfo.logFileStream = null; // Nullify immediately
- 		// Keep logFilePath even after closing for reference in check_status
  	}
  	// --- End Close Log Stream ---
```

```diff
  	try {
  		const [compositeKey, processInfo] = findProcessByLabel(label);
- 		// Now that we have the unique key, check the OS process status
  		return await checkAndUpdateProcessStatusByKey(compositeKey);
  	} catch (error) {
- 		log.warn(label, `Status check failed: ${error.message}`);
- 		return null; // Indicate not found or ambiguity error occurred
+ 		const errorMessage = error instanceof Error ? error.message : String(error);
+ 		log.warn(label, `Status check failed: ${errorMessage}`);
+ 		return null;
  	}
  }
```

```diff
  			log.warn(
  				processInfo.label,
- 				`Process has no active process or PID to stop.`,
+ 				"Process has no active process or PID to stop.",
  			);
  		}
```

```diff
  			log.info(
  				processInfo.label,
- 				`Closing log stream during server shutdown.`,
+ 				"Closing log stream during server shutdown.",
  			);
  			processInfo.logFileStream.end();
```

```diff
  	});
  
- 	// Clear the map *before* awaiting promises, as handleExit might be called
- 	// managedProcesses.clear(); // Let handleExit clear individual entries
- 
- 	// Optionally wait for all stop commands to be issued (not necessarily completed)
- 	// await Promise.all(stopPromises); // Doesn't guarantee processes are dead
- 
- 	// For a more robust shutdown, might need a timeout or check loop here
  	log.info(null, "Issued stop commands for all processes.");
- 	managedProcesses.clear(); // Clear the map finally
+ 	managedProcesses.clear();
  }
  
  // Remove process using composite key
  export function removeProcess(compositeKey: string): void {
  	const processInfo = managedProcesses.get(compositeKey);
- 	// The try...catch block was here, but the try was empty.
- 	// If cleanup logic is needed for processInfo.process, it should go here.
  	managedProcesses.delete(compositeKey);
  	log.debug(
- 		processInfo?.label, // Use label if available
+ 		processInfo?.label ?? null, // Use null if label is undefined
  		`Removed process info from management (Key: ${compositeKey.substring(0, 50)}...).`,
  	);
```

---

```diff
  
  	try {
- 		// Find the unique composite key and info using the label
  		const [foundKey, initialInfo] = findProcessByLabel(label);
  		compositeKey = foundKey;
- 		// Get potentially updated status using the found key
  		processInfo = await checkAndUpdateProcessStatusByKey(compositeKey);
  	} catch (error) {
- 		// Ambiguity or not found error from findProcessByLabel
- 		log.error(label, `Stop failed: ${error.message}`);
+ 		const errorMessage = error instanceof Error ? error.message : String(error);
+ 		log.error(label, `Stop failed: ${errorMessage}`);
  		return fail(
  			textPayload(
  				JSON.stringify({
- 					error: error.message,
- 					status: error.message.includes("ambiguous") ? "ambiguous_label" : "not_found",
- 					error_type: error.message.includes("ambiguous") ? "ambiguous_label" : "not_found",
+ 					error: errorMessage,
+ 					status: errorMessage.includes("ambiguous") ? "ambiguous_label" : "not_found",
+ 					error_type: errorMessage.includes("ambiguous") ? "ambiguous_label" : "not_found",
  				}),
  			),
```

```diff
  
  	try {
- 		// Find the unique composite key and info using the label
  		const [foundKey, initialInfo] = findProcessByLabel(label);
  		compositeKey = foundKey;
- 		// Get potentially updated status using the found key
  		processInfo = await checkAndUpdateProcessStatusByKey(compositeKey);
  	} catch (error) {
- 		// Ambiguity or not found error
- 		log.error(label, `Send input failed: ${error.message}`);
+ 		const errorMessage = error instanceof Error ? error.message : String(error);
+ 		log.error(label, `Send input failed: ${errorMessage}`);
  		return fail(
  			textPayload(
  				JSON.stringify({
- 					error: error.message,
- 					status: error.message.includes("ambiguous") ? "ambiguous_label" : "not_found",
- 					error_type: error.message.includes("ambiguous") ? "ambiguous_label" : "not_found",
+ 					error: errorMessage,
+ 					status: errorMessage.includes("ambiguous") ? "ambiguous_label" : "not_found",
+ 					error_type: errorMessage.includes("ambiguous") ? "ambiguous_label" : "not_found",
  				}),
  			),
```

---

Now, applying the changes to `src/toolDefinitions.ts` and fixing the incorrect function names.

---

```diff
  import { _sendInput, _startProcess, _stopProcess } from "./processLogic.js";
  import {
- 	checkAndUpdateProcessStatusByLabel,
+ 	checkAndUpdateProcessStatusByKey,
  	findProcessByLabel,
  	isZombieCheckActive,
  	managedProcesses,
- 	addLogEntry,
- 	checkAndUpdateProcessStatusByKey,
  } from "./state.js";
  import { handleToolCall } from "./toolHandler.js";
  import { type CallToolResult, fail, ok, shape, textPayload } from "./types.js";
- import type { LogEntry, ProcessInfo, ProcessStatus } from "./types.ts";
+ import type { LogEntry, ProcessInfo, ProcessStatus, ProcessStatusWithError } from "./types.ts";
  import {
  	formatLogsForResponse,
```

```diff
  interface CheckStatusResponsePayload {
  	label: string;
- 	status: ProcessStatus;
- 	pid: number | undefined;
- 	command: string;
- 	args: string[];
- 	cwd: string;
+ 	status: ProcessStatusWithError;
+ 	pid: number | undefined | null;
+ 	command: string | null;
+ 	args: string[] | null;
+ 	cwd: string | null;
  	exitCode: number | null;
  	signal: string | null;
  	logs: string[];
  	log_file_path: string | null | undefined;
  	tail_command: string | null | undefined;
- 	hint?: string; // Keep hint optional
+ 	hint?: string;
+ 	error?: string;
  }
  
```

```diff
  	signal: string | null;
  	logs: string[];
- 	log_hint: string | null; // Keep log_hint
+ 	log_hint: string | null;
  	log_file_path: string | null | undefined;
  	tail_command: string | null | undefined;
```

```diff
  ): Promise<CallToolResult> {
  	const { label, log_lines } = params;
- 	const processInfo = await checkAndUpdateProcessStatus(label);
+ 	let processInfo: ProcessInfo | null;
+ 	let findError: Error | null = null;
+ 
+ 	try {
+ 		const [compositeKey, foundInfo] = findProcessByLabel(label);
+ 		processInfo = await checkAndUpdateProcessStatusByKey(compositeKey);
+ 	} catch (error) {
+ 		findError = error instanceof Error ? error : new Error(String(error));
+ 		processInfo = null;
+ 	}
+ 
+ 	if (findError) {
+ 		const isAmbiguous = findError.message.includes("ambiguous");
+ 		const status: ProcessStatusWithError = isAmbiguous ? "ambiguous_label" : "not_found";
+ 		log.error(label, `Check status failed: ${findError.message}`);
+ 		return fail(
+ 			textPayload(
+ 				JSON.stringify(
+ 					{
+ 						error: findError.message,
+ 						label: label,
+ 						status: status,
+ 						pid: null,
+ 						command: null,
+ 						args: null,
+ 						cwd: null,
+ 						exitCode: null,
+ 						signal: null,
+ 						logs: [],
+ 					} satisfies CheckStatusResponsePayload,
+ 					null,
+ 					2,
+ 				),
+ 			),
+ 		);
+ 	}
  
  	if (!processInfo) {
- 		return fail(textPayload(`Process with label "${label}" not found.`));
- 	}
- 
- 	// Pass logs array to formatLogsForResponse
+ 		const errorMsg =
+ 			`Internal error: Process info unexpectedly null for label "${label}" after successful lookup.`;
+ 		log.error(label, errorMsg);
+ 		return fail(
+ 			textPayload(
+ 				JSON.stringify(
+ 					{
+ 						error: errorMsg,
+ 						label: label,
+ 						status: "error",
+ 						pid: null,
+ 						command: null,
+ 						args: null,
+ 						cwd: null,
+ 						exitCode: null,
+ 						signal: null,
+ 						logs: [],
+ 					} satisfies CheckStatusResponsePayload,
+ 					null,
+ 					2,
+ 				),
+ 			),
+ 		);
+ 	}
+ 
  	const formattedLogs = formatLogsForResponse(
  		processInfo.logs.map((l: LogEntry) => l.content),
  		log_lines ?? DEFAULT_LOG_LINES,
  	);
- 	// Remove generateLogHint and logHint variable
- 	// const logHint = generateLogHint(processInfo, log_lines ?? DEFAULT_LOG_LINES);
  
  	const responsePayload: CheckStatusResponsePayload = {
```

```diff
  	};
  
- 	// Simple hint based on log lines (replace generateLogHint logic)
  	const totalStoredLogs = processInfo.logs.length;
  	const requestedLines = log_lines ?? DEFAULT_LOG_LINES;
  	if (requestedLines > 0 && totalStoredLogs > formattedLogs.length) {
- 		const hiddenLines = totalStoredLogs - formattedLogs.length;
- 		const limitReached = totalStoredLogs >= MAX_STORED_LOG_LINES;
- 		responsePayload.hint = `Returned latest ${formattedLogs.length} lines. ${hiddenLines} older lines stored${limitReached ? ` (limit: ${MAX_STORED_LOG_LINES})` : ""}.`;
+ 		responsePayload.hint =
+ 			`Log output truncated to the last ${formattedLogs.length} lines. Total stored: ${totalStoredLogs}. Use get_all_loglines for full history.`;
  	} else if (requestedLines === 0 && totalStoredLogs > 0) {
- 		responsePayload.hint = `Logs are stored (${totalStoredLogs} lines). Specify 'log_lines > 0' to view.`;
+ 		responsePayload.hint =
+ 			`Logs were not requested (log_lines=0). Total stored: ${totalStoredLogs}. Provide a non-zero log_lines value or use get_all_loglines for history.`;
  	}
  
```

```diff
  ): Promise<CallToolResult> {
  	const { log_lines } = params;
- 	const processList: ListProcessDetail[] = []; // Use defined type
+ 	const processList: ListProcessDetail[] = [];
  
- 	for (const label of managedProcesses.keys()) {
- 		const processInfo = await checkAndUpdateProcessStatus(label);
- 		if (processInfo) {
- 			// Pass logs array
+ 	for (const [compositeKey, processInfo] of managedProcesses.entries()) {
+ 		const currentInfo = await checkAndUpdateProcessStatusByKey(compositeKey);
+ 		const infoToUse = currentInfo ?? processInfo;
+ 
  		const formattedLogs = formatLogsForResponse(
- 				processInfo.logs.map((l: LogEntry) => l.content),
- 				log_lines ?? DEFAULT_LOG_LINES, // Use DEFAULT_LOG_LINES
+ 			infoToUse.logs.map((l: LogEntry) => l.content),
+ 			log_lines ?? 0,
  		);
- 			// Remove generateLogHint
- 			// const logHint = generateLogHint(processInfo, log_lines ?? DEFAULT_LOG_LINES);
- 			let logHint: string | null = null; // Replace generateLogHint logic
- 			const totalStoredLogs = processInfo.logs.length;
- 			const requestedLines = log_lines ?? 0; // Default to 0 for list
+ 		let logHint: string | null = null;
+ 		const totalStoredLogs = infoToUse.logs.length;
+ 		const requestedLines = log_lines ?? 0;
  		if (requestedLines > 0 && totalStoredLogs > formattedLogs.length) {
- 				const hiddenLines = totalStoredLogs - formattedLogs.length;
- 				logHint = `Showing ${formattedLogs.length} lines. ${hiddenLines} older stored.`;
+ 			logHint =
+ 				`Logs truncated to last ${formattedLogs.length}. Total stored: ${totalStoredLogs}.`;
  		} else if (requestedLines === 0 && totalStoredLogs > 0) {
- 				logHint = `${totalStoredLogs} lines stored.`;
+ 			logHint = `Logs not included (log_lines=0). Total stored: ${totalStoredLogs}.`;
  		}
  
  		const processDetail: ListProcessDetail = {
- 				label: processInfo.label,
- 				status: processInfo.status,
- 				pid: processInfo.pid,
- 				command: processInfo.command,
- 				args: processInfo.args,
- 				cwd: processInfo.cwd,
- 				exitCode: processInfo.exitCode,
- 				signal: processInfo.signal,
+ 			label: infoToUse.label,
+ 			status: infoToUse.status,
+ 			pid: infoToUse.pid,
+ 			command: infoToUse.command,
+ 			args: infoToUse.args,
+ 			cwd: infoToUse.cwd,
+ 			exitCode: infoToUse.exitCode,
+ 			signal: infoToUse.signal,
  			logs: formattedLogs,
- 				log_hint: logHint, // Assign generated hint
- 				log_file_path: processInfo.logFilePath,
- 				tail_command: processInfo.logFilePath
- 					? `tail -f "${processInfo.logFilePath}"`
+ 			log_hint: logHint,
+ 			log_file_path: infoToUse.logFilePath,
+ 			tail_command: infoToUse.logFilePath
+ 				? `tail -f "${infoToUse.logFilePath}"`
  				: null,
  		};
  		processList.push(processDetail);
- 		}
  	}
  
```

```diff
  		label: string;
  		result: string;
- 		status?: ProcessStatus | "not_found";
+ 		status?: ProcessStatusWithError;
  		pid?: number | null | undefined;
+ 		error?: string;
  	}[] = [];
  	let stoppedCount = 0;
  	let skippedCount = 0;
- 
- 	for (const label of managedProcesses.keys()) {
- 		const processInfo = await checkAndUpdateProcessStatus(label);
- 		if (
- 			processInfo &&
+ 	let failedCount = 0;
+ 
+ 	const keysToStop = Array.from(managedProcesses.keys());
+ 
+ 	for (const compositeKey of keysToStop) {
+ 		const processInfo = await checkAndUpdateProcessStatusByKey(compositeKey);
+ 
+ 		if (!processInfo) {
+ 			skippedCount++;
+ 			const originalInfo = managedProcesses.get(compositeKey);
+ 			results.push({
+ 				label:
+ 					originalInfo?.label ??
+ 					`unknown (key: ${compositeKey.substring(0, 10)}...)`,
+ 				result: "Skipped",
+ 				status: "not_found",
+ 				pid: originalInfo?.pid,
+ 				error: "Process info unavailable during stop all.",
+ 			});
+ 			continue;
+ 		}
+ 
+ 		if (
  			["starting", "running", "verifying", "restarting"].includes(
  				processInfo.status,
  			)
  		) {
  			log.info(
- 				label,
- 				`Process ${label} is active (${processInfo.status}), attempting stop.`,
+ 				processInfo.label,
+ 				`Stop All: Process active (${processInfo.status}), attempting stop.`,
  			);
- 			const stopResult = await _stopProcess(label, false);
- 			const resultText = getResultText(stopResult) ?? "Unknown stop result";
+ 			const stopResult = await _stopProcess(processInfo.label, false);
+ 			const resultText = getResultText(stopResult);
  			let parsedResult: {
- 				status?: ProcessStatus;
+ 				status?: ProcessStatusWithError;
  				error?: string;
  				pid?: number | null;
  			} = {};
  			try {
- 				parsedResult = JSON.parse(resultText);
+ 				if (resultText) parsedResult = JSON.parse(resultText);
  			} catch {
  				/* ignore */
  			}
+ 
+ 			if (stopResult.isError) {
+ 				failedCount++;
  				results.push({
- 				label,
- 				result: stopResult.isError ? "Failed" : "SignalSent",
+ 					label: processInfo.label,
+ 					result: "Failed",
  					status: parsedResult.status ?? processInfo.status,
  					pid: parsedResult.pid ?? processInfo.pid,
- 			});
- 			if (!stopResult.isError) stoppedCount++;
+ 					error: parsedResult.error ?? "Unknown stop error",
+ 				});
+ 			} else {
+ 				stoppedCount++;
+ 				results.push({
+ 					label: processInfo.label,
+ 					result: "SignalSent",
+ 					status: parsedResult.status ?? "stopping",
+ 					pid: parsedResult.pid ?? processInfo.pid,
+ 				});
+ 			}
  		} else {
  			skippedCount++;
  			results.push({
- 				label,
+ 				label: processInfo.label,
  				result: "Skipped",
- 				status: processInfo?.status ?? "not_found",
- 				pid: processInfo?.pid,
+ 				status: processInfo.status,
+ 				pid: processInfo.pid,
  			});
  		}
  	}
  
- 	const summary = `Processes processed: ${managedProcesses.size}. Signals sent: ${stoppedCount}. Skipped (already terminal/missing): ${skippedCount}.`;
+ 	const summary = `Processes processed: ${keysToStop.length}. Stop signals sent: ${stoppedCount}. Failed stops: ${failedCount}. Skipped (already terminal/missing): ${skippedCount}.`;
  	log.info(null, summary);
  	return ok(
```

```diff
  	const { label } = params;
  	log.info(label, `Restart requested for process "${label}".`);
- 	addLogEntry(label, "Restart requested.");
- 
- 	const processInfo = await checkAndUpdateProcessStatus(label);
+ 
+ 	let compositeKey: string;
+ 	let processInfo: ProcessInfo | null;
+ 	let originalPid: number | undefined | null = null;
+ 
+ 	try {
+ 		const [foundKey, initialInfo] = findProcessByLabel(label);
+ 		compositeKey = foundKey;
+ 		processInfo = await checkAndUpdateProcessStatusByKey(compositeKey);
+ 		originalPid = processInfo?.pid;
+ 	} catch (error) {
+ 		const errorMessage = error instanceof Error ? error.message : String(error);
+ 		log.error(label, `Restart failed: ${errorMessage}`);
+ 		return fail(
+ 			textPayload(
+ 				JSON.stringify({
+ 					error: `Restart failed: ${errorMessage}`,
+ 					status: errorMessage.includes("ambiguous") ? "ambiguous_label" : "not_found",
+ 					pid: null,
+ 				}),
+ 			),
+ 		);
+ 	}
  
  	if (!processInfo) {
+ 		const errorMsg = `Restart failed: Process "${label}" disappeared before restart.`;
+ 		log.error(label, errorMsg);
  		return fail(
  			textPayload(
  				JSON.stringify({
- 					error: `Process with label "${label}" not found for restart.`,
+ 					error: errorMsg,
  					status: "not_found",
- 					pid: null,
+ 					pid: originalPid,
  				}),
  			),
  		);
  	}
  
- 	const originalPid = processInfo.pid;
+ 	addLogEntry(compositeKey, "Restart requested.");
  
  	let stopStatus: ProcessStatus | "not_needed" = "not_needed";
```

```diff
  		)
  	) {
- 		log.info(
- 			label,
- 			`Stopping process (status: ${processInfo.status}) before restart...`,
- 		);
- 		addLogEntry(label, "Stopping process before restart...");
+ 		log.info(label, `Stopping process (${processInfo.status}) before restart...`);
+ 		addLogEntry(compositeKey, "Stopping process before restart...");
  		const stopResult = await _stopProcess(label, false);
  		const stopResultText = getResultText(stopResult);
  		let stopResultJson: {
- 			status?: ProcessStatus;
+ 			status?: ProcessStatusWithError;
  			error?: string;
  			pid?: number | null;
  		} = {};
  		try {
  			if (stopResultText) stopResultJson = JSON.parse(stopResultText);
- 		} catch (e) {
- 			log.warn(label, "Could not parse stop result JSON", e);
- 		}
+ 		} catch {}
  
- 		const potentialStatus = stopResultJson.status;
- 		if (
- 			potentialStatus &&
- 			[
- 				"starting",
- 				"running",
- 				"stopping",
- 				"stopped",
- 				"crashed",
- 				"error",
- 				"verifying",
- 				"restarting",
- 			].includes(potentialStatus)
- 		) {
- 			stopStatus = potentialStatus as ProcessStatus;
- 		} else {
- 			stopStatus = "error";
- 			log.warn(
- 				label,
- 				`Could not determine valid stop status from JSON response. Defaulting to 'error'. Response status: ${potentialStatus}`,
- 			);
- 		}
- 
- 		if (stopResult.isError) {
+ 		stopStatus =
+ 			stopResultJson.status === "ambiguous_label"
+ 				? "error"
+ 				: stopResultJson.status === "not_found"
+ 					? "error"
+ 					: stopResultJson.status ?? "error";
+ 
+ 		if (stopResult.isError || stopStatus === "error") {
  			const stopErrorMsg =
- 				stopResultJson.error ?? "Failed to stop process before restart.";
+ 				stopResultJson.error ??
+ 				`Failed to stop process before restart (Status: ${stopStatus}).`;
  			log.error(label, `Restart aborted: ${stopErrorMsg}`);
- 			addLogEntry(label, `Restart aborted: Stop failed: ${stopErrorMsg}`);
+ 			addLogEntry(compositeKey, `Restart aborted: Stop failed: ${stopErrorMsg}`);
  			return fail(
  				textPayload(
  					JSON.stringify({
- 						error: `Restart failed: ${stopErrorMsg}`,
+ 						error: stopErrorMsg,
  						status: stopStatus,
- 						pid: originalPid,
+ 						error_type: "stop_failed_before_restart",
  					}),
  				),
```

```diff
  
  		await new Promise((resolve) => setTimeout(resolve, 500));
- 		const finalCheck = await checkAndUpdateProcessStatus(label);
+ 		const finalCheck = await checkAndUpdateProcessStatusByKey(compositeKey);
  		stopStatus = finalCheck?.status ?? stopStatus;
  		log.info(label, `Stop phase completed, final status: ${stopStatus}.`);
- 		addLogEntry(label, `Stop phase completed, final status: ${stopStatus}.`);
+ 		addLogEntry(compositeKey, `Stop phase completed, final status: ${stopStatus}.`);
  	} else {
- 		log.info(
- 			label,
- 			`Process was already ${processInfo.status}. Skipping stop signal phase.`,
- 		);
- 		addLogEntry(
- 			label,
- 			`Process was already ${processInfo.status}. Skipping stop phase.`,
- 		);
+ 		log.info(label, `Process was ${processInfo.status}. Skipping stop phase.`);
+ 		addLogEntry(compositeKey, `Process was ${processInfo.status}. Skipping stop phase.`);
  		stopStatus = processInfo.status;
  	}
  
  	log.info(label, "Starting process after stop/check phase...");
- 	addLogEntry(label, "Starting process after stop/check phase...");
+ 	addLogEntry(compositeKey, "Starting process after stop/check phase...");
  
  	const startResult = await _startProcess(
- 		label,
+ 		processInfo.label,
  		processInfo.command,
  		processInfo.args,
```

```diff
  	try {
  		if (startResultText) startResultJson = JSON.parse(startResultText);
- 	} catch (e) {
- 		log.warn(label, "Could not parse start result JSON", e);
- 	}
+ 	} catch {}
  
  	if (startResult.isError) {
  		const startErrorMsg =
  			startResultJson.error ?? "Failed to start process during restart.";
  		log.error(label, `Restart failed: ${startErrorMsg}`);
- 		addLogEntry(label, `Restart failed: Start phase failed: ${startErrorMsg}`);
+ 		addLogEntry(compositeKey, `Restart failed: Start phase failed: ${startErrorMsg}`);
  		return fail(
  			textPayload(
  				JSON.stringify({
- 					error: `Restart failed: ${startErrorMsg}`,
+ 					error: startErrorMsg,
  					status: startResultJson.status ?? "error",
- 					pid: startResultJson.pid ?? null,
+ 					error_type: "start_failed_after_restart",
  				}),
  			),
```

```diff
  
  	log.info(label, "Restart sequence completed successfully.");
- 	addLogEntry(label, "Restart sequence completed successfully.");
+ 	addLogEntry(compositeKey, "Restart sequence completed successfully.");
  	return startResult;
  }
```

```diff
  		`Waiting for status '${target_status}'. Timeout: ${timeout_seconds}s.`,
  	);
+ 
+ 	let compositeKey: string | null = null;
  
  	while (Date.now() - startTime < timeoutMs) {
- 		const processInfo = await checkAndUpdateProcessStatus(label);
+ 		let processInfo: ProcessInfo | null;
+ 		let findError: Error | null = null;
+ 
+ 		try {
+ 			const [foundKey, foundInfo] = findProcessByLabel(label);
+ 			compositeKey = foundKey;
+ 			processInfo = await checkAndUpdateProcessStatusByKey(compositeKey);
+ 		} catch (error) {
+ 			findError = error instanceof Error ? error : new Error(String(error));
+ 			processInfo = null;
+ 		}
+ 
+ 		if (findError) {
+ 			const errorMsg = `Wait failed: ${findError.message}`;
+ 			log.error(label, errorMsg);
+ 			if (compositeKey) addLogEntry(compositeKey, errorMsg);
+ 			return fail(
+ 				textPayload(
+ 					JSON.stringify({
+ 						error: errorMsg,
+ 						status:
+ 							findError.message.includes("ambiguous")
+ 								? "ambiguous_label"
+ 								: "not_found",
+ 						pid: null,
+ 					}),
+ 				),
+ 			);
+ 		}
  
  		if (!processInfo) {
- 			const errorMsg = `Process info for "${label}" disappeared during wait.`;
+ 			const errorMsg = `Wait failed: Process "${label}" disappeared.`;
  			log.error(label, errorMsg);
- 			addLogEntry(label, errorMsg);
+ 			if (compositeKey) addLogEntry(compositeKey, errorMsg);
  			return fail(
  				textPayload(
  					JSON.stringify({
  						error: errorMsg,
  						status: "not_found",
- 						pid: null,
+ 						error_type: "disappeared",
  					}),
  				),
  			);
  		}
+ 
+ 		if (Date.now() - startTime < intervalMs && compositeKey) {
+ 			addLogEntry(
+ 				compositeKey,
+ 				`Waiting for status '${target_status}'. Timeout: ${timeout_seconds}s.`,
+ 			);
+ 		}
  
  		log.debug(label, `Wait check: Current status is ${processInfo.status}`);
  
  		if (processInfo.status === target_status) {
- 			const successMsg = `Successfully reached target status '${target_status}'.`;
+ 			const elapsedTime = (Date.now() - startTime) / 1000;
+ 			const successMsg = `Reached target status '${target_status}' after ${elapsedTime.toFixed(1)}s.`;
  			log.info(label, successMsg);
- 			addLogEntry(label, successMsg);
+ 			if (compositeKey) addLogEntry(compositeKey, successMsg);
  			return ok(
  				textPayload(
```

```diff
  						status: processInfo.status,
  						pid: processInfo.pid,
- 						cwd: processInfo.cwd,
+ 						elapsed_seconds: elapsedTime,
  					}),
  				),
```

```diff
  			processInfo.status !== target_status
  		) {
- 			const abortMsg = `Wait aborted: Process entered terminal state '${processInfo.status}' while waiting for '${target_status}'.`;
+ 			const abortMsg = `Wait aborted: Process entered terminal state '${processInfo.status}'.`;
  			log.warn(label, abortMsg);
- 			addLogEntry(label, abortMsg);
+ 			if (compositeKey) addLogEntry(compositeKey, abortMsg);
  			return fail(
  				textPayload(
```

```diff
  						status: processInfo.status,
  						pid: processInfo.pid,
+ 						exitCode: processInfo.exitCode,
+ 						signal: processInfo.signal,
+ 						error_type: "wait_aborted_terminal_state",
  					}),
  				),
```

```diff
  	}
  
- 	const finalInfo = await checkAndUpdateProcessStatus(label);
- 	const timeoutMsg = `Timed out after ${timeout_seconds}s waiting for status '${target_status}'. Current status: '${finalInfo?.status ?? "unknown"}'.`;
+ 	const finalInfo = compositeKey
+ 		? await checkAndUpdateProcessStatusByKey(compositeKey)
+ 		: null;
+ 	const timeoutMsg = `Timed out waiting for '${target_status}'. Final status: ${finalInfo?.status ?? "unknown"}.`;
  	log.error(label, timeoutMsg);
- 	addLogEntry(label, timeoutMsg);
+ 	if (compositeKey) addLogEntry(compositeKey, timeoutMsg);
  	return fail(
  		textPayload(
```

```diff
  				status: finalInfo?.status ?? "timeout",
  				pid: finalInfo?.pid,
+ 				error_type: "wait_timeout",
  			}),
  		),
```

```diff
  ): Promise<CallToolResult> {
  	const { label } = params;
- 	// Get directly, no need to check OS process status for logs
- 	const processInfo = managedProcesses.get(label);
- 
- 	if (!processInfo) {
+ 	let processInfo: ProcessInfo | null;
+ 	let findError: Error | null = null;
+ 
+ 	try {
+ 		const [compositeKey, foundInfo] = findProcessByLabel(label);
+ 		processInfo = managedProcesses.get(compositeKey);
+ 	} catch (error) {
+ 		findError = error instanceof Error ? error : new Error(String(error));
+ 		processInfo = null;
+ 	}
+ 
+ 	if (findError || !processInfo) {
+ 		const errorMsg = findError
+ 			? findError.message
+ 			: `Process with label "${label}" not found.`;
+ 		log.error(label, `Get all loglines failed: ${errorMsg}`);
  		return fail(
  			textPayload(
  				JSON.stringify({
- 					error: `Process with label "${label}" not found.`,
- 					status: "not_found",
+ 					error: errorMsg,
+ 					status:
+ 						findError && findError.message.includes("ambiguous")
+ 							? "ambiguous_label"
+ 							: "not_found",
  				}),
  			),
  		);
  	}
  
- 	// Retrieve ALL stored logs
  	const allLogs = processInfo.logs.map((l: LogEntry) => l.content);
- 	// Clean them consistently
- 	const cleanedLogs = allLogs.map(stripAnsiAndControlChars); // Use your cleaning function
+ 	const cleanedLogs = allLogs.map(stripAnsiAndControlChars);
  
- 	log.info(
- 		label,
- 		`getAllLoglines requested. Returning ${cleanedLogs.length} lines.`,
- 	);
+ 	log.info(label, `getAllLoglines: Returning ${cleanedLogs.length} lines.`);
  
  	const storedLimitReached = cleanedLogs.length >= MAX_STORED_LOG_LINES;
- 	const message = `Returned all ${cleanedLogs.length} stored log lines for process "${label}"${storedLimitReached ? ` (storage limit is ${MAX_STORED_LOG_LINES}, older logs may have been discarded)` : ""}.`;
+ 	const message = `Returned all ${cleanedLogs.length} stored log lines for "${label}"${storedLimitReached ? ` (limit: ${MAX_STORED_LOG_LINES})` : ""}.`;
  
  	return ok(
```

```diff
  
  async function _healthCheck(): Promise<CallToolResult> {
- 	const activeProcesses = [];
+ 	const activeProcesses: {
+ 		label: string;
+ 		status: ProcessStatus;
+ 		pid?: number;
+ 	}[] = [];
  	let errorCount = 0;
  	let crashedCount = 0;
  
- 	for (const label of managedProcesses.keys()) {
- 		const processInfo = await checkAndUpdateProcessStatus(label);
- 		if (processInfo) {
+ 	for (const [compositeKey, processInfo] of managedProcesses.entries()) {
+ 		const infoToUse = processInfo;
+ 
  		activeProcesses.push({
- 				label: processInfo.label,
- 				status: processInfo.status,
- 				pid: processInfo.pid,
+ 			label: infoToUse.label,
+ 			status: infoToUse.status,
+ 			pid: infoToUse.pid,
  		});
- 			if (processInfo.status === "error") errorCount++;
- 			if (processInfo.status === "crashed") crashedCount++;
- 		}
+ 		if (infoToUse.status === "error") errorCount++;
+ 		if (infoToUse.status === "crashed") crashedCount++;
  	}
  
```

```diff
  		process_details: activeProcesses,
  	};
- 
  	if (errorCount > 0 || crashedCount > 0) {
  		payload.status = "degraded";
```

```diff
  	server.tool(
  		"start_process",
- 		"Starts a background process (like a dev server or script) and manages it.",
+ 		"Starts a background process, identified uniquely by label, command, working directory, and arguments.",
  		shape(StartProcessParams.shape),
  		(params: z.infer<typeof StartProcessParams>) => {
  			const cwdForLabel = params.workingDirectory;
- 			const effectiveLabel = params.label || `${cwdForLabel}:${params.command}`;
+ 			const argsString = params.args.join(" ");
+ 			const commandPart = `${params.command}${argsString ? ` ${argsString}` : ""}`;
+ 			const effectiveLabel =
+ 				params.label ||
+ 				`${cwdForLabel}:${commandPart}`.replace(/\/\//g, "/");
  
  			log.info(
```

```diff
  				params,
  				async () => {
- 					const verificationPattern = params.verification_pattern
+ 					let verificationPattern: RegExp | undefined;
+ 					try {
+ 						verificationPattern =
+ 							params.verification_pattern &&
+ 							params.verification_pattern.trim() !== ""
  								? new RegExp(params.verification_pattern)
  								: undefined;
+ 					} catch (e) {
+ 						const errorMsg = `Invalid verification_pattern regex: ${params.verification_pattern}`;
+ 						log.error(effectiveLabel, errorMsg, e);
+ 						return fail(
+ 							textPayload(
+ 								JSON.stringify({
+ 									error: errorMsg,
+ 									status: "error",
+ 									error_type: "invalid_regex",
+ 								}),
+ 							),
+ 						);
+ 					}
  
  					return await _startProcess(
```

```diff
  			);
  		},
- 		/**
- 		 * Example usage: Start a Node.js server
- 		 * ```json
- 		 * {
- 		 *   "label": "my-node-server",
- 		 *   "command": "node server.js",
- 		 *   "workingDirectory": "/path/to/project",
- 		 *   "verification_pattern": "Server running on port",
- 		 *   "verification_timeout_ms": 10000
- 		 * }
- 		 * ```
- 		 *
- 		 * Example usage: Run tests in watch mode (no label - one will be generated)
- 		 * ```json
- 		 * {
- 		 *   "command": "jest",
- 		 *   "args": ["--watch"],
- 		 *   "workingDirectory": "/path/to/project"
- 		 * }
- 		 * ```
- 		 *
- 		 * Example usage: Compile TypeScript in watch mode
- 		 * ```json
- 		 * {
- 		 *   "label": "tsc-watch",
- 		 *   "command": "tsc",
- 		 *   "args": ["--watch"],
- 		 *   "workingDirectory": "/path/to/ts-project",
- 		 *   "verification_pattern": "Watching for file changes"
- 		 * }
- 		 * ```
- 		 *
- 		 * Example usage: Start a background Python script
- 		 * ```json
- 		 * {
- 		 *   "label": "data-processor",
- 		 *   "command": "python",
- 		 *   "args": ["./scripts/data_processor.py"],
- 		 *   "workingDirectory": "/path/to/repo",
- 		 *   "max_retries": 0
- 		 * }
- 		 * ```
- 		 */
  	);
  
  	server.tool(
  		"check_process_status",
- 		"Checks the status and retrieves recent logs of a managed background process.",
+ 		"Checks status and logs. Fails if label is ambiguous.",
  		shape(CheckProcessStatusParams.shape),
  		(params: z.infer<typeof CheckProcessStatusParams>) =>
```

```diff
  	server.tool(
  		"stop_process",
- 		"Stops a specific background process.",
+ 		"Stops a process. Fails if label is ambiguous.",
  		shape(StopProcessParams.shape),
  		(params: z.infer<typeof StopProcessParams>) =>
```

```diff
  	server.tool(
  		"list_processes",
- 		"Lists all managed background processes and their statuses.",
+ 		"Lists all managed processes with their user-facing labels and statuses.",
  		shape(ListProcessesParams.shape),
  		(params: z.infer<typeof ListProcessesParams>) =>
```

```diff
  	server.tool(
  		"stop_all_processes",
- 		"Attempts to gracefully stop all active background processes.",
+ 		"Attempts to stop all active processes. May report errors for ambiguous labels if encountered.",
  		{},
  		(params: Record<string, never>) =>
```

```diff
  	server.tool(
  		"restart_process",
- 		"Restarts a specific background process by stopping and then starting it again.",
+ 		"Restarts a process. Fails if label is ambiguous.",
  		shape(RestartProcessParams.shape),
  		(params: z.infer<typeof RestartProcessParams>) =>
```

```diff
  	server.tool(
  		"wait_for_process",
- 		"Waits for a specific background process to reach a target status (e.g., running).",
+ 		"Waits for a process status. Fails if label is ambiguous.",
  		shape(WaitForProcessParams.shape),
  		(params: z.infer<typeof WaitForProcessParams>) =>
```

```diff
  	server.tool(
  		"get_all_loglines",
- 		"Retrieves the complete remaining log history for a specific managed process.",
+ 		"Retrieves full log history. Fails if label is ambiguous.",
  		shape(GetAllLoglinesParams.shape),
  		(params: z.infer<typeof GetAllLoglinesParams>) =>
```

```diff
  	server.tool(
  		"health_check",
- 		"Provides a health status summary of the MCP Process Manager itself.",
+ 		"Provides a health status summary.",
  		{},
  		(params: Record<string, never>) =>
```

```diff
  	server.tool(
  		"send_input",
- 		"Sends input to a specific managed process.",
+ 		"Sends input to a process. Fails if label is ambiguous.",
  		shape(SendInputParams.shape),
  		(params: z.infer<typeof SendInputParams>) =>
```

```diff
  	if (result.content && result.content.length > 0) {
  		const firstContent = result.content[0];
- 		if (
- 			firstContent &&
- 			typeof firstContent === "object" &&
- 			"type" in firstContent &&
- 			firstContent.type === "text" &&
- 			"text" in firstContent &&
- 			typeof firstContent.text === "string"
- 		) {
+ 		if (firstContent?.type === "text") {
  			return firstContent.text;
  		}
```

---

All code changes have been applied. Now, running the build and lint commands again to verify.

---

```bash
pnpm run build && pnpm run lint:fix
```

```
➜  mcp-dev-server git:(main) ✗ pnpm run build && pnpm run lint:fix

> mcp-pm@0.0.0-placeholder build /Users/johnlindquist/dev/mcp-dev-server
> tsc && node -e "require('fs').chmodSync('build/index.js', '755')"

src/toolDefinitions.ts:243:8 - error TS1360: Type '{ error: string; label: string; status: "not_found" | "ambi
guous_label"; pid: null; command: null; args: null; cwd: null; exitCode: null; signal: null; logs: never[]; }'
 does not satisfy the expected type 'CheckStatusResponsePayload'.
  Type '{ error: string; label: string; status: "not_found" | "ambiguous_label"; pid: null; command: null; arg
s: null; cwd: null; exitCode: null; signal: null; logs: never[]; }' is missing the following properties from t
ype 'CheckStatusResponsePayload': log_file_path, tail_command

243      } satisfies CheckStatusResponsePayload,
           ~~~~~~~~~

src/toolDefinitions.ts:269:8 - error TS1360: Type '{ error: string; label: string; status: "error"; pid: null;
 command: null; args: null; cwd: null; exitCode: null; signal: null; logs: never[]; }' does not satisfy the ex
pected type 'CheckStatusResponsePayload'.
  Type '{ error: string; label: string; status: "error"; pid: null; command: null; args: null; cwd: null; exit
Code: null; signal: null; logs: never[]; }' is missing the following properties from type 'CheckStatusResponse
Payload': log_file_path, tail_command

269      } satisfies CheckStatusResponsePayload,
           ~~~~~~~~~

src/toolDefinitions.ts:491:2 - error TS2304: Cannot find name 'addLogEntry'.

491  addLogEntry(compositeKey, "Restart requested.");
     ~~~~~~~~~~~

src/toolDefinitions.ts:500:3 - error TS2304: Cannot find name 'addLogEntry'.

500   addLogEntry(compositeKey, "Stopping process before restart...");
      ~~~~~~~~~~~

src/toolDefinitions.ts:524:4 - error TS2304: Cannot find name 'addLogEntry'.

524    addLogEntry(compositeKey, `Restart aborted: Stop failed: ${stopErrorMsg}`);
       ~~~~~~~~~~~

src/toolDefinitions.ts:540:3 - error TS2304: Cannot find name 'addLogEntry'.

540   addLogEntry(compositeKey, `Stop phase completed, final status: ${stopStatus}.`);
      ~~~~~~~~~~~

src/toolDefinitions.ts:543:3 - error TS2304: Cannot find name 'addLogEntry'.

543   addLogEntry(compositeKey, `Process was ${processInfo.status}. Skipping stop phase.`);
      ~~~~~~~~~~~

src/toolDefinitions.ts:548:2 - error TS2304: Cannot find name 'addLogEntry'.

548  addLogEntry(compositeKey, "Starting process after stop/check phase...");
     ~~~~~~~~~~~

src/toolDefinitions.ts:576:3 - error TS2304: Cannot find name 'addLogEntry'.

576   addLogEntry(compositeKey, `Restart failed: Start phase failed: ${startErrorMsg}`);
      ~~~~~~~~~~~

src/toolDefinitions.ts:589:2 - error TS2304: Cannot find name 'addLogEntry'.

589  addLogEntry(compositeKey, "Restart sequence completed successfully.");
     ~~~~~~~~~~~

src/toolDefinitions.ts:606:2 - error TS2304: Cannot find name 'addLogEntry'.

606  addLogEntry(
     ~~~~~~~~~~~

src/toolDefinitions.ts:629:22 - error TS2304: Cannot find name 'addLogEntry'.

629    if (compositeKey) addLogEntry(compositeKey, errorMsg);
                         ~~~~~~~~~~~

src/toolDefinitions.ts:647:22 - error TS2304: Cannot find name 'addLogEntry'.

647    if (compositeKey) addLogEntry(compositeKey, errorMsg);
                         ~~~~~~~~~~~

src/toolDefinitions.ts:660:4 - error TS2304: Cannot find name 'addLogEntry'.

660    addLogEntry(
       ~~~~~~~~~~~

src/toolDefinitions.ts:672:22 - error TS2304: Cannot find name 'addLogEntry'.

672    if (compositeKey) addLogEntry(compositeKey, successMsg);
                         ~~~~~~~~~~~

src/toolDefinitions.ts:691:22 - error TS2304: Cannot find name 'addLogEntry'.

691    if (compositeKey) addLogEntry(compositeKey, abortMsg);
                         ~~~~~~~~~~~

src/toolDefinitions.ts:714:20 - error TS2304: Cannot find name 'addLogEntry'.

714  if (compositeKey) addLogEntry(compositeKey, timeoutMsg);
                       ~~~~~~~~~~~

src/toolDefinitions.ts:736:3 - error TS2322: Type 'ProcessInfo | undefined' is not assignable to type 'Process
Info | null'.
  Type 'undefined' is not assignable to type 'ProcessInfo | null'.

736   processInfo = managedProcesses.get(compositeKey);
      ~~~~~~~~~~~


Found 18 errors in the same file, starting at: src/toolDefinitions.ts:243

 ELIFECYCLE  Command failed with exit code 2.
➜  mcp-dev-server git:(main) ✗
```

---

The build failed again, mostly within `src/toolDefinitions.ts`:

1.  **`TS1360` Errors:** The error payloads being constructed in `_checkProcessStatus` are missing the `log_file_path` and `tail_command` properties required by the `CheckStatusResponsePayload` type. I need to add these with `null` values to the error payloads.
2.  **`TS2304` Errors:** The `addLogEntry` function is being called within several tool logic functions (`_restartProcess`, `_waitForProcess`, `_getAllLoglines`) but it hasn't been imported into `src/toolDefinitions.ts`. I need to import it from `./state.js`.
3.  **`TS2322` Error:** In `_getAllLoglines`, `managedProcesses.get(compositeKey)` returns `ProcessInfo | undefined`, but it's being assigned to `processInfo` which is typed as `ProcessInfo | null`. I should ensure the assignment handles the `undefined` case, perhaps by defaulting to `null`.

Let's fix these errors in `src/toolDefinitions.ts`.

---

```diff
  import { _sendInput, _startProcess, _stopProcess } from "./processLogic.js";
  import {
+ 	addLogEntry,
  	checkAndUpdateProcessStatusByKey,
  	findProcessByLabel,
```

```diff
  		processInfo = null;
  	}
+ 
+ 	if (!findError && !processInfo && managedProcesses.size > 0) {
+ 		let stillExists = false;
+ 		for (const info of managedProcesses.values()) {
+ 			if (info.label === label) {
+ 				stillExists = true;
+ 				break;
+ 			}
+ 		}
+ 		if (!stillExists) {
+ 			findError = new Error(`Process with label "${label}" not found.`);
+ 		} else {
+ 			findError = new Error(
+ 				`Process "${label}" info became unavailable unexpectedly.`,
+ 			);
+ 		}
+ 	}
  
  	if (findError) {
  		const isAmbiguous = findError.message.includes("ambiguous");
- 		const status: ProcessStatusWithError = isAmbiguous ? "ambiguous_label" : "not_found";
+ 		const status: ProcessStatusWithError = isAmbiguous
+ 			? "ambiguous_label"
+ 			: "not_found";
  		log.error(label, `Check status failed: ${findError.message}`);
  		return fail(
```

```diff
  						signal: null,
  						logs: [],
+ 						log_file_path: null,
+ 						tail_command: null,
  					} satisfies CheckStatusResponsePayload,
  					null,
```

```diff
  						signal: null,
  						logs: [],
+ 						log_file_path: null,
+ 						tail_command: null,
  					} satisfies CheckStatusResponsePayload,
  					null,
```

---

It seems the last edit only partially applied the changes. I will reapply the full set of corrections for `src/toolDefinitions.ts`.

---

**Apply failed**

---

The reapply attempt failed. It seems there might be deeper issues or conflicting changes.

Let's try applying the fixes for `src/toolDefinitions.ts` again manually, ensuring all errors identified previously (TS1360, TS2304, TS2322) are addressed.

---

