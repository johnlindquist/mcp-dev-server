<!-- Generated by SpecStory -->

# Improving Log Output from Node-PTY (2025-04-28 16:02:39)

_**User**_

Okay, let's break down why those weird formatting characters and artifacts are appearing in the logs.

You're right, the cleaning process isn't catching everything. Here's the likely cause:

1.  **`node-pty` Emulates a Full Terminal:** The core issue is that `node-pty` creates a pseudo-terminal (PTY). This isn't just capturing the final `stdout` and `stderr` of the *command* (`next dev`), but rather the *entire raw output stream* of the interactive shell session that `node-pty` spawns. This includes:
    *   **Shell Prompts:** Characters like `➜` or `%` are part of the shell's prompt showing up before/after the command runs.
    *   **Control Characters:**
        *   `\r` (Carriage Return): Used extensively in terminals to move the cursor back to the start of the line without advancing to the next. This is how progress indicators update in place, and how prompts often overwrite previous lines. When you just split by `\n`, lines ending in `\r` or containing `\r` for overwriting aren't handled cleanly.
        *   `\b` (Backspace): Seen in `"\bpn"`. This happens because the shell running inside the PTY is likely echoing the command characters *as they are being "typed"* (programmatically via `ptyProcess.write`). `pnpm dev` gets written, the shell echoes `p`, then `\b` (maybe?), then `p`, then `n`, etc.
        *   `\u0007` (BEL character): This is an audible bell or visual alert character, sometimes emitted by programs or the shell.
    *   **Input Echoing:** The sequence `"p", "\bpn", "pm", "d", "e", "v"` looks exactly like the shell echoing the `pnpm dev` command itself as it was written to the PTY's input.
    *   **ANSI Escape Codes (Partially Handled):** While `strip-ansi` *does* remove color codes and cursor movement *escape sequences* (like `\x1B[31m` for red text or `\x1B[1A` to move up), it **does not** typically remove basic control characters like `\r`, `\b`, or `\u0007`.

2.  **Insufficient Cleaning Logic:**
    *   **`stripAnsiSafe`:** As mentioned, it correctly removes standard ANSI escape codes but leaves other control characters behind.
    *   **`data.split(/\r?\n/)`:** In `_startProcess`, splitting the incoming data chunks by newline characters (`\n` or `\r\n`) doesn't properly process lines that use `\r` for in-line overwriting or cursor repositioning. A chunk might contain `Progress: 50%\rProgress: 75%`, and splitting by newline won't separate these logically.

**In Summary:**

You're logging the *raw terminal stream*, warts and all. The current `stripAnsiSafe` function only cleans up a subset of the non-printable/formatting characters (specifically ANSI escape sequences), leaving behind other common terminal control characters (`\r`, `\b`, `\u0007`) and shell artifacts (prompts, echoed input).

**How to Fix/Improve:**

1.  **More Aggressive Control Character Stripping:** Modify `stripAnsiSafe` or add another step in `addLogEntry` or `formatLogsForResponse` to explicitly remove or replace these characters. A common approach is to use a regular expression to remove control characters (except essentials like `\n` and `\t`).
    *   Example Regex (might need tuning): `/[^\x20-\x7E\n\t]/g` (This removes characters outside the printable ASCII range, plus newline and tab). Be careful, as this might strip legitimate UTF-8 characters if your output uses them. A safer range might target specific control codes: `/\r|\b|\u0007/g`.

2.  **Refine Line Splitting/Processing:** Instead of just splitting by `\r?\n`, you might need a more stateful approach to handle `\r` correctly, essentially simulating how a terminal would render the output line by line. This is significantly more complex. For logging, simply stripping `\r` might be good enough.

3.  **Targeted Stripping:** You could specifically target and remove the echoed command sequence if it's consistently problematic.

**Recommendation:**

Start by enhancing `stripAnsiSafe` (or creating a new function called by `formatLogsForResponse`) to remove `\r`, `\b`, and `\u0007`.

```typescript
// In utils.ts

const CONTROL_CHAR_REGEX = /\r|\b|\u0007/g; // Add other chars if needed

export function stripAnsiAndControlChars(input: string): string {
    if (typeof input !== "string") return input;
    try {
        // First remove specific control chars we don't want
        let cleanedInput = input.replace(CONTROL_CHAR_REGEX, '');
        // Then remove null bytes if any (though less common than \r, \b)
        cleanedInput = cleanedInput.replace(/\\u0000/g, "");
        // Finally, strip standard ANSI escape sequences
        return stripAnsi(cleanedInput);
    } catch (e: unknown) {
        log.error(
            null,
            `Error stripping ANSI/Control Chars: ${e instanceof Error ? e.message : String(e)}`,
            { originalInput: input.substring(0, 100) + '...' } // Log snippet on error
        );
        // Fallback to original or partially cleaned
        return typeof input === 'string' ? input.replace(CONTROL_CHAR_REGEX, '') : input;
    }
}

// In utils.ts - update formatLogsForResponse
export function formatLogsForResponse(
    logs: string[],
    lineCount: number,
): string[] {
    const recentLogs = logs.slice(-lineCount);
    // Use the enhanced stripping function
    return recentLogs.map(stripAnsiAndControlChars);
}
```

This should clean up the most common offenders (`\r`, `\b`, `\u0007`) while still benefiting from `strip-ansi` for colors etc., leading to much cleaner log output in the MCP response.

---

_**Assistant**_



---

Okay, that's a great explanation of the problem and a clear solution. Capturing the raw PTY stream definitely explains the presence of those control characters and shell artifacts. Enhancing the cleaning process to handle them makes perfect sense.

I'll implement the proposed changes in `src/utils.ts`.

First, I need to locate the existing `stripAnsiSafe` and `formatLogsForResponse` functions and see if `stripAnsiSafe` is used elsewhere. I'll search for `stripAnsiSafe`.

---

<details>
            <summary>Grep search for "stripAnsiSafe" • **2** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///Users/johnlindquist/dev/mcp-dev-server/src/toolHandler.ts` | L7 | `import { log, stripAnsiSafe } from "./utils.js";` |
| `file:///Users/johnlindquist/dev/mcp-dev-server/src/toolHandler.ts` | L30 | `const errorMessage = stripAnsiSafe(` |
| `file:///Users/johnlindquist/dev/mcp-dev-server/src/utils.ts` | L31 | `export function stripAnsiSafe(input: string): string {` |
| `file:///Users/johnlindquist/dev/mcp-dev-server/src/utils.ts` | L51 | `return recentLogs.map(stripAnsiSafe);` |

</details>

---

Okay, `stripAnsiSafe` is used in `src/toolHandler.ts` as well. So, I'll keep the existing `stripAnsiSafe` function and add the new `stripAnsiAndControlChars` function. Then, I'll update `formatLogsForResponse` to use the new function.

Now, I'll apply the code changes to `src/utils.ts`.

---

```diff
  import stripAnsi from "strip-ansi";
  import { SERVER_NAME } from "./constants.js";
+ import { log } from "./log.js";
  
  // Logging
```

```diff
  	}
  }
+ 
+ const CONTROL_CHAR_REGEX = /\r|\b|\u0007/g; // Add other chars if needed
+ const NULL_BYTE_REGEX = /\u0000/g;
+ 
+ export function stripAnsiAndControlChars(input: string): string {
+ 	if (typeof input !== "string") return input;
+ 	try {
+ 		// First remove specific control chars we don't want
+ 		let cleanedInput = input.replace(CONTROL_CHAR_REGEX, '');
+ 		// Then remove null bytes if any
+ 		cleanedInput = cleanedInput.replace(NULL_BYTE_REGEX, "");
+ 		// Finally, strip standard ANSI escape sequences
+ 		return stripAnsi(cleanedInput);
+ 	} catch (e: unknown) {
+ 		log.error(
+ 			null,
+ 			`Error stripping ANSI/Control Chars: ${e instanceof Error ? e.message : String(e)}`,
+ 			{ originalInput: input.substring(0, 100) + '...' } // Log snippet on error
+ 		);
+ 		// Fallback to original or partially cleaned
+ 		return typeof input === 'string' ? input.replace(CONTROL_CHAR_REGEX, '').replace(NULL_BYTE_REGEX, "") : input;
+ 	}
+ }
  
  export function formatLogsForResponse(
```

```diff
  ): string[] {
  	const recentLogs = logs.slice(-lineCount);
- 	return recentLogs.map(stripAnsiSafe);
+ 	// Use the enhanced stripping function
+ 	return recentLogs.map(stripAnsiAndControlChars);
  }
  
```

---

The changes have been applied to `src/utils.ts`. The new `stripAnsiAndControlChars` function is added, and `formatLogsForResponse` now uses it to provide cleaner logs. This should address the issue with control characters appearing in the process manager's output.

---

